# Хеш-таблица

## Цель работы

1. Реализовать базовые функции хеш-таблицы: поиск элемента, добавление элемента, удаление элемента.

1. Протестировать различные хеш-функций на равномерное распределение коллизий.

1. Оптимизировать хеш-таблицу по скорости аппаратными методами ([`SIM-D` инструкции], [`inline` ассемблер], [написание функции на ассемблере]). Найти узкие места программы и ускорить работу основных функций: вставки, удаления и поиска. Показать, что дальнейшие попытки оптимизации только ухудшают производительность / читаемость кода / модульность программы.

## Теоретическое введение

`Хеш-таблица` - это структура данных, которая позволяет быстро находить, добавлять и удалять элементы. В среднем поиск, вставка и удаление выполняются за `O(1)`.

Хеш-таблица содержит массив данных. Выполнение операции начинается с вычисления `хеш-функции`, которая каждому значению сопоставляет его индекс в массиве. При этом неизбежны `коллизии` - ситуации когда двум разным значениям хеш-функция сопоставляет один и тот же индекс. Существует два способа разрешения коллизий: `открытая адресация` (более подробную информацию об этом методе можно получить в [интернете](https://ru.wikipedia.org/wiki/Хеш-таблица#Открытая_адресация)) и `метод цепочек`.

В данной работе реализована хеш-таблица методом цепочек. Элементами массива хеш-таблицы являются связные списки. После вычисления хеш-функции, выполняемая операция перенаправляется соответствующему списку. Например, рассмотрим добавление элемента в хеш-таблицу. Сначала вычисляется хеш-функция - её значение будет индексом списка в массиве. Далее элемент добавляется в этот список. Обычно новый элемент добавляют в конец списка. При правильно подобранном размере хеш-таблицы, все списки содержат 1-2 элемента, поэтому поиск чаще всего осуществляется перебором.

<p align="center">
    <img src="images/Hashtable list method.png" width="600"/>
    <p align="center">Рисунок 1. Разрешение коллизий методом цепочек.</p>
</p>

В идеальном случае хеш-функция разным элементам хеш-таблицы сопоставляет разные индексы. В реальности это не так. Некоторые хеш-функции обладают `неравномерным распределением коллизий`: функция принимает одно и то же значение для большого набора аргументов. Такие `концентрации коллизий` замедляют работу хеш-таблицы, так как возникают перегруженные элементами списки и операции поиска и удаления начинают выполняться за `O(n)`. Такие хеш-функции не рекомендуется использовать для хеш-таблицы.

Хеш-функции, обладающие равномерным распределением коллизий, позволяют осуществлять операции с хеш-таблицей за примерно одинаковое время. При этом в каждом списке находится почти одно и тоже количество элементов.

На рисунке приведен пример хеш-функций, имеющих неравномерное и равномерное распределения коллизий.

<p align="center">
    <img src="images/Collisions.png" width="600"/>
    <p align="center">Рисунок 2. Распределение коллизий хеш-функций.</p>
</p>

## Исследование хеш-функций на распределение коллизий

В данной работе будем хранить в таблице слова. Исследуем следующие функции на равномерное распределение коллизий:

1. `Всегда единица`. Функция, сопоставляющая всем словам одно и тоже значение, равное 1.

1. `ASCII-код первого символа`. Функция, сопоставляющая слову `ASCII-код` первой буквы.

1. `Длина слова`. Функция, сопоставляющая слову, его длину.

1. `Сумма ASCII-кодов букв`. Функция, сопоставляющая слову, сумму его `ASCII-символов`.

1. `Ror`. Функция, содержащая циклический сдвиг вправо. Код на `C++`:
    ```C++
        // word - указатель на слово, оканчивающееся '\0'
        size_t Hash_Ror(char* word)
        {
            size_t hash = *word++;

            while (*word)
            {
                hash = ((hash & 1) << (8 * sizeof(size_t) - 1)) | (hash >> 1); // Циклический сдвиг вправо
                hash ^= *word++;
            }

            return hash;
        }
    ```

1. `CRC-32`. Последней хеш-функцией будет CRC-32.

### Методика исследования

Тестировать хеш-функции будем на произведениях Шекспира. Словами будем считать формально последовательности латинских заглавных и строчных букв, разделенных любыми другими символами. Слова чувствительны к регистру. Всего слов в наборе данных `~1 000 000`, из них различны `~30 000`.

Протестируем функции на разных количествах списков в хеш-таблице: 20, 100, 1500, 15000.

Номером списка, в который нужно поместить слово, будет значение хеш-функции по модулю количества списков: `listIndex = hash % listCount`.

### Предварительный анализ хеш-функций

Ожидается, что первые четыре функции будут давать не равномерное распределение коллизий:

1. `Всегда единица`. Все элементы хеш-таблицы будут храниться в одном списке, остальные списки будут пустыми. Очевидно, что распределение не равномерно.

1. `ASCII-код первого символа`. Множество значений функции ограничено 256. В нашей задаче слова начинаются с букв английского алфавита (26 букв, 2 регистра), то есть у функции всего 26 * 2 = 52 значения.

1. `Длина слова`. Большинство слов не превышают 32 символа.

1. `Сумма ASCII-кодов букв`. Количество значений этой функции можно оценить сверху следующим образом: наибольшее число букв 32, наибольшее значение ASCII-кода z = 122. То есть 122 * 32 = 3904 значений. Проведя измерения, увидим, что наибольшая сумма ASCII-кодов букв 2892, наименьшая 65, а средняя 750.

### Проведение измерений

Все изображения графиков хранятся в папках `images/group functions/` и `images/group lists/`. Графики построены в двух вариантах: группировка по типу функции (`hash_<functionName>.png`) и группировка по количеству списков в хеш-таблице (`hash_list_<listCount>.png`). В отчёте приведем и проанализируем графики с группировкой по типу функции как более наглядные.

На данных графиках по оси `x` откладывается индекс списка в хеш-таблице. По оси `y` откладывается количество элементов данного списка при заполненной словами таблице, то есть количество коллизий исследуемой функции. Горизонтальная красная линия на графике показывает число коллизий, если бы функция была идеальной. То есть если график функции совпадает с красной линией, то можно говорить о равномерном распределении функции на данном наборе данных, при данном размере хеш-таблицы. Если же изменить набор входных данных или размер хеш-таблицы, то распределение может измениться. Как будет видно далее, для некоторых функций при мелом размере хеш-таблицы распределение равномерно, а при больших размерах становится неравномерным.

При больших размерах хеш-таблицы построение столбчатых диаграмм `matplotlib.pyplot.bar()` затрудняется. Во-первых, отрисовка графика в `Python` начинает занимать значительное время. Во-вторых, столбики становятся слишком узкими так, что теряются некоторые значения графике. Эту проблему можно решить, если строить график `matplotlib.pyplot.plot()` и закрашивать область под ним `matplotlib.pyplot.fill_between()`. Но тогда перестают быть видны пустые списки. То есть при большом размере хеш-таблицы нет идеального варианта, поэтому будем использовать два способа.

Обозначим описанные выше способы, как `I` - построение столбчатых диаграмм, `II` - построение графика и закрашивание области под ним. При малом размере хеш-таблицы (20 и 100) будем использовать только `I` способ. При больших количествах списков (1500 и 15000) для графиков с группировкой по количеству списков в хеш-таблице `images/group lists/` будем использовать только `II` способ. Для группировки по типу функции построим графики при большом количестве списков как первым `I` (`images/group functions/bar/`), так и вторым `II` (`images/group functions/plot/`) способом. Далее в отчёте будет указано, каким способом был построен данный график. Также в скобках будет приведено описание, почему был выбран тот или иной способ.

Сравнить графики, построенные разными способами, предлагается читателю самостоятельно. Также читателю предоставляется возможность проанализировать графики, построенные с другим типом группировки (по количеству списков).

1. `Всегда единица`. График при больших размерах хеш-таблицы построен `II` способом (Первый `I` способ не отображает одиночный столбик при 15000 списков). Как и ожидалось график этой функции представлен одним столбцом. В хеш-таблице используется только один список. Это самая плохая хеш-функция.

    <p align="center">
        <img src="images/group functions/plot/hash_const.png" width="600"/>
    </p>

1. `ASCII-код первого символа`. График при больших размерах хеш-таблицы построен `II` способом (При первом `I` способе теряются данные при 1500 и 15000 списках). Данная функция имеет неравномерное распределение при всех размерах хеш-таблицы (количествах списков в ней). Видно, что значения функции находятся примерно в промежутке от 60 до 130.

    <p align="center">
        <img src="images/group functions/plot/hash_letter.png" width="600"/>
    </p>

1. `Длина слова`. График при больших размерах хеш-таблицы построен `II` способом (При первом `I` способе не видно столбиков при 15000 списках). Имеет неравномерное распределение при всех размерах хеш-таблицы. По графикам её множество значений ограничено 16 для большинства слов. Если провести точный подсчёт, то слов длиной 16 и больше окажется всего 7 из 30 000.

    <p align="center">
        <img src="images/group functions/plot/hash_length.png" width="600"/>
    </p>

1. `Сумма ASCII-кодов букв`. График при больших размерах хеш-таблицы построен `II` способом (При первом `I` способе видны пустые списки в промежутке [400; 1100], хотя на самом деле их нет. В этом промежутке все списки содержат элементы, но некоторые из них содержат мало элементов, что `Python` отображает их как пустые полосы, как будто там нет элементов.). При малом размере хеш-таблицы (20 списков) данная функция имеет равномерное распределение. Но уже начиная со 100 списков её распределение становится неравномерным, появляется область концентрации коллизий. Полностью убедиться в неравномерности распределения можно, если посмотреть на 3 график (1500 списков), на котором лучше всего видно неравномерность распределения функции. Данная функция не подходит для использования в хеш-таблице.

    Посчитаем точное количество пустых и переполненных списков.
    |Пустые списки|Число элементов больше среднего|Число элементов не больше среднего|Всего|
    |:-:|:-:|:-:|:-:|
    | 173 | 507 | 820 | 1500|
    | 13661 | 1078 | 261 | 15000|

    <p align="center">
        <img src="images/group functions/plot/hash_char_sum.png" width="600"/>
    </p>

1. `Ror`. График при больших размерах хеш-таблицы построен `I` способом (Для 1500 и 15000 списков при втором `II` способе кажется, что все значения больше среднего, хотя это не так. В основном количество коллизий меньше среднего (см. таблицу ниже)). По первым двум графикам видно, что распределение функции неравномерно. Тем не менее её распределение намного лучше, чем у 4 предыдущих функций.

    Посчитаем точное количество пустых и переполненных списков.
    |Пустые списки|Число элементов больше среднего|Число элементов не больше среднего|Всего|
    |:-:|:-:|:-:|:-:|
    | 296 | 375 | 829 | 1500|
    | 10335 | 2128 | 2537 | 15000|

    <p align="center">
        <img src="images/group functions/bar/hash_ror.png" width="600"/>
    </p>

1. `CRC-32`. График при больших размерах хеш-таблицы построен `I` способом. `Внимание! Для 1500 списков в первом способе I видно, что есть пустые списки, хотя это не так, все списки содержат не меньше 6 элементов`. (Второй способ `II` не отображает пустые списки при 15000). У данной функции распределение лучше, чем у предыдущих. Но оно не идеально: 13% списков пустые при размере хеш-таблицы 15000.

    Посчитаем точное количество пустых и переполненных списков.
    |Пустые списки|Число элементов больше среднего|Число элементов не больше среднего|Всего|
    |:-:|:-:|:-:|:-:|
    | 0 | 699 | 801 | 1500|
    | 1955 | 4980 | 8065 | 15000|

    Заполненность списков при размере хеш-таблицы 15000.

    |Количество элементов в списке|    0 |    1 |    2 |    3 |    4 |    5     |    6 |    7 |    8 |    9 |   10 |
    |----------------------------:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
    |Количество списков           | 1955 | 3978 | 4087 | 2779 | 1342 | 579   |  205 | 50   | 21   | 2    | 2    |

    <p align="center">
        <img src="images/group functions/bar/hash_crc32.png" width="600"/>
    </p>

### Вывод

1-5 функции не удачные для хеш-таблицы, так как их распределение неравномерно. Из приведенных функций лучше всего для хеш-таблицы использовать `CRC-32`.

## Оптимизация хеш-таблицы по скорости

Программа компилировалась с помощью `Microsoft Visual Studio Community 2022`.

Обозначим следующие опции компиляции:

`CompDebug`: `Debug x64`, `/Od`.

`CompReleaseMax`: `Release x64`, `/O2`, favor speed `/Ot`, enable intrinsic functions `/Oi`, inline function expansion any suitable `/Ob2`, whole program optimization `/GL`, enable enchanced instruction set `/arch:SSE2`, link time code generation `/LTCG`.

`CompRelease`: `Release x64`, `/O2`, favor speed `/Ot`, enable intrinsic functions `/Oi`, inline function expansion any suitable `/Ob2`, whole program optimization `/GL`, enable enchanced instruction set `/arch:SSE2`, link time code generation `/LTCG`.

Тестировать работу хеш-таблицы будем на том же наборе текстов Шекспира. Слов в наполненной хеш-таблице ~30 000. Количество списков установим 1 500, так в каждом списке в среднем будет 20 слов. Это сделано для того, чтобы можно было измерить время работы функций хеш-таблицы и оптимизировать узкие места. Если настроить среднюю длину списка на 1-2 слова, то операции будут выполняться за O(1), оптимизировать будет нечего.

Сначала один раз загрузим данные в хеш-таблицу, а затем n раз повторим цикл из тестирования оптимизируемой функции на наборе из ~1 000 000 слов (общее количество слов в текстах). То есть функция будет вызвана n * 10^6 раз. Этого будет достаточно, для точного измерения среднего времени выполнения функции. Для функции поиска элемента n = 500, для вставки-удаления n = 50.

Хеш-таблица предназначена для активного поиска, вставки и удаления элементов. Все три операции содержат вычисление хеш-функции и поиск элемента в списке по индексу. Поэтому в первую очередь нужно оптимизировать поиск элемента и вычисление хеша. Вставка и удаление элемента в хеш-таблице содержат операции вставки и удаления элемента в списке, которые выполняются за O(1), поэтому их оптимизировать нужно в последнюю очередь.

## Измерение времени работы не оптимизированной программы с опциями `CompDebug`.

### Поиск элемента в хеш-таблице. 109 530 мс.

<p align="center">
    <img src="images/Optimization/0 find unoptimized version compDebug.png" width="600"/>
</p>

Анализ результата: как и ожидалось, самые нагруженные - это функции поиска элемента в списке `ListFind`, компаратор элементов списка `ListComparator` и вычисление хеша `CalcHash`, `HashTableHash6`.

### Вставка-удаление элемента. 53 367 мс.

<p align="center">
    <img src="images/Optimization/0 insert-remove unoptimized version compDebug.png" width="600"/>
</p>

Анализ результата: как и в предыдущем случае, самые нагруженные - это поиск элемента и вычисление хеша. Далее идут вставка элемента в список и удаление элемента из списка.

## Измерение времени работы не оптимизированной программы с опциями `CompReleaseMax`.

### Поиск элемента в хеш-таблице. 63 395 мс.

<p align="center">
    <img src="images/Optimization/0 find unoptimized version compRelease.png" width="600"/>
</p>

Анализ результата: оптимизации компилятора ускорили программу в 1,7 раза по сравнению с `CompDebug`. При полной оптимизации программы, некоторые функции были оптимизированы и удалены, поэтому в отчёте о производительность есть только вычисление хеш-функции. Оставшееся время занимает системный код. 

### Вставка-удаление элемента. 27 756 мс.

<p align="center">
    <img src="images/Optimization/0 insert-remove unoptimized version compRelease.png" width="600"/>
</p>

Анализ результата: оптимизации компилятора ускорили программу в 1,9 раза по сравнению с `CompDebug`. Наибольшее время всё ещё занимают поиск элемента в списке и вычисление хеш-функции.

## Оптимизация функции поиска элемента.

Проанализируем набор входных данных: длина слова в основном не превышает 16 символов. Слов длиной 15 символов всего 33, длиной 16 - всего 3, длиной больше 16 - всего 4. Поэтому изменим тип данных `char*` на `__m128i`, чтобы применить `SSE4.2` инструкции.

Сравнения строк будут производиться одной командой `_mm_cmpeq_epi64`. При этом программа ускорится, но пропадёт возможность хранить слова длиной больше 16.

## Измерение времени работы программы. Оптимизация `__m128i` типа данных.

Опции компиляции `CompReleaseMax`.

### Поиск элемента в хеш-таблице. 56 711 мс.

<p align="center">
    <img src="images/Optimization/1 find __m128i.png" width="600"/>
</p>

Анализ результата: изменение типа данных ускорило программу в 1,1 раз по сравнению с версией без оптимизации.

### Вставка-удаление элемента. 13 958 мс.

<p align="center">
    <img src="images/Optimization/1 insert-remove __m128i.png" width="600"/>
</p>

Анализ результата: изменение типа данных ускорило программу в 1,9 раза по сравнению с версией без оптимизации.

Вывод: данная оптимизация ускорила функцию `ListFind`. Следующей нужно оптимизировать функцию вычисления хеша, так как она занимает больше всего времени.

## Оптимизация функции вычисления контрольной суммы.

Заменим функцию вычисления контрольной суммы на `SIM-D` инструкцию.

Опции компиляции `CompReleaseMax`.

### Поиск элемента в хеш-таблице. 28 940 мс.

<p align="center">
    <img src="images/Optimization/2 find crc32.png" width="600"/>
</p>

Анализ результата: изменение функции вычисления хеша ускорило программу в 2 раза по сравнению с версией без оптимизации.

### Вставка-удаление элемента. 8 102 мс.

<p align="center">
    <img src="images/Optimization/2 insert-remove crc32.png" width="600"/>
</p>

Анализ результата: изменение функции вычисления хеша ускорило программу в 3,4 раза по сравнению с версией без оптимизации.