# Хеш-таблица

## Содержание

1. [Цель работы](#цель-работы)
1. [Теоретическое введение](#теоретическое-введение)
1. [Исследование хеш-функций на равномерное распределение коллизий](#исследование-хеш-функций-на-равномерное-распределение-коллизий)

    1\. [Методика исследования](#методика-исследования)

    2\. [Предварительный анализ хеш-функций](#предварительный-анализ-хеш-функций)

    3\. [Проведение измерений и анализ результатов](#проведение-измерений-и-анализ-результатов)

    4\. [Исследование хеш-фукнций. Вывод](#исследование-хеш-фукнций-вывод)

1. [Оптимизация хеш-таблицы по скорости](#оптимизация-хеш-таблицы-по-скорости)
    1. [Общая методика оптимизации](#общая-методика-оптимизации)
    1. [Особенности оптимизации хеш-таблицы](#особенности-оптимизации-хеш-таблицы)
    1. [Опции компиляции, условия тестирования](#опции-компиляции-условия-тестирования)
    1. [Измерение времени работы не оптимизированной программы](#измерение-времени-работы-не-оптимизированной-программы)
    1. [Оптимизация типа данных](#оптимизация-типа-данных)
    1. [Оптимизация хеш-функции](#оптимизация-хеш-функции)
    1. [Ассемблерная оптимизация](#ассемблерная-оптимизация)
    1. [Inline оптимизация](#inline-оптимизация)
    1. [Исследование максимального прироста производительности](#исследование-максимального-прироста-производительности)
    1. [Оптимизация программы. Вывод](#оптимизация-программы-вывод)

## Цель работы

1. Реализовать базовые функции хеш-таблицы: поиск элемента, добавление элемента, удаление элемента.

1. Протестировать различные хеш-функций на равномерное распределение коллизий.

1. Оптимизировать хеш-таблицу по скорости аппаратными методами (`SIM-D` инструкции, `inline` ассемблер, написание функции на ассемблере). Найти узкие места программы и ускорить работу основных функций: вставки, удаления и поиска.

## Теоретическое введение

`Хеш-таблица` - это структура данных, которая позволяет быстро находить, добавлять и удалять элементы. В среднем поиск, вставка и удаление выполняются за `O(1)`.

Хеш-таблица содержит массив данных. Выполнение операции начинается с вычисления `хеш-функции`, которая каждому значению сопоставляет его индекс в массиве. При этом неизбежны `коллизии` - ситуации когда двум разным значениям хеш-функция сопоставляет один и тот же индекс. Существует два способа разрешения коллизий: `открытая адресация` (более подробную информацию об этом методе можно получить в [интернете](https://ru.wikipedia.org/wiki/Хеш-таблица#Открытая_адресация)) и `метод цепочек`.

В данной работе реализована хеш-таблица методом цепочек. Элементами массива хеш-таблицы являются связные списки. После вычисления хеш-функции, выполняемая операция перенаправляется соответствующему списку. Например, рассмотрим добавление элемента в хеш-таблицу. Сначала вычисляется хеш-функция - её значение будет индексом списка в массиве. Далее элемент добавляется в этот список. Обычно новый элемент добавляют в конец списка. При правильно подобранном размере хеш-таблицы, все списки содержат 1-2 элемента, поэтому поиск чаще всего осуществляется перебором.

<p align="center">
    <img src="images/Hashtable list method.png" width="600"/>
    <p align="center">Рисунок 1. Разрешение коллизий методом цепочек.</p>
</p>

В идеальном случае хеш-функция разным элементам хеш-таблицы сопоставляет разные индексы. В реальности это не так. Некоторые хеш-функции обладают `неравномерным распределением коллизий`: функция принимает одно и то же значение для большого набора аргументов. Такие `концентрации коллизий` замедляют работу хеш-таблицы, так как возникают перегруженные элементами списки и операции поиска и удаления начинают выполняться за `O(n)`. Такие хеш-функции не рекомендуется использовать для хеш-таблицы.

Хеш-функции, обладающие равномерным распределением коллизий, позволяют осуществлять операции с хеш-таблицей за примерно одинаковое время. При этом в каждом списке находится почти одно и тоже количество элементов.

На рисунке приведен пример хеш-функций, имеющих неравномерное и равномерное распределения коллизий.

<p align="center">
    <img src="images/Collisions.png" width="600"/>
    <p align="center">Рисунок 2. Распределение коллизий хеш-функций.</p>
</p>

## Исследование хеш-функций на равномерное распределение коллизий

В данной работе будем хранить в таблице слова. Исследуем следующие функции на равномерное распределение коллизий:

1. `Всегда единица`. Функция, сопоставляющая всем словам одно и тоже значение, равное 1.

1. `ASCII-код первого символа`. Функция, сопоставляющая слову `ASCII-код` первой буквы.

1. `Длина слова`. Функция, сопоставляющая слову, его длину.

1. `Сумма ASCII-кодов букв`. Функция, сопоставляющая слову, сумму его `ASCII-символов`.

1. `Ror`. Функция, содержащая циклический сдвиг вправо. Код на `C++`:
    ```C++
        // word - указатель на слово, оканчивающееся '\0'
        size_t Hash_Ror(char* word)
        {
            size_t hash = *word++;

            while (*word)
            {
                hash = ((hash & 1) << (8 * sizeof(size_t) - 1)) | (hash >> 1); // Циклический сдвиг вправо
                hash ^= *word++;
            }

            return hash;
        }
    ```

1. `CRC-32`. Последней хеш-функцией будет CRC-32.

### Методика исследования

Тестировать хеш-функции будем на произведениях Шекспира. Словами будем считать формально последовательности латинских заглавных и строчных букв, разделенных любыми другими символами. Слова чувствительны к регистру. Всего слов в наборе данных `~1 000 000`, из них различны `~30 000`.

Протестируем функции на разных количествах списков в хеш-таблице: 20, 100, 1500, 15000.

Номером списка, в который нужно поместить слово, будет значение хеш-функции по модулю количества списков: `listIndex = hash % listCount`.

### Предварительный анализ хеш-функций

Ожидается, что первые четыре функции будут давать не равномерное распределение коллизий:

1. `Всегда единица`. Все элементы хеш-таблицы будут храниться в одном списке, остальные списки будут пустыми. Очевидно, что распределение не равномерно.

1. `ASCII-код первого символа`. Множество значений функции ограничено 256. В нашей задаче слова начинаются с букв английского алфавита (26 букв, 2 регистра), то есть у функции всего 26 * 2 = 52 значения.

1. `Длина слова`. Большинство слов не превышают 32 символа.

1. `Сумма ASCII-кодов букв`. Количество значений этой функции можно оценить сверху следующим образом: наибольшее число букв 32, наибольшее значение ASCII-кода z = 122. То есть 122 * 32 = 3904 значений. Проведя измерения, увидим, что наибольшая сумма ASCII-кодов букв 2892, наименьшая 65, а средняя 750.

### Проведение измерений и анализ результатов

Все изображения графиков хранятся в папках `images/group functions/` и `images/group lists/`. Графики построены в двух вариантах: группировка по типу функции (`hash_<functionName>.png`) и группировка по количеству списков в хеш-таблице (`hash_list_<listCount>.png`). В отчёте приведем и проанализируем графики с группировкой по типу функции как более наглядные.

На данных графиках по оси `x` откладывается индекс списка в хеш-таблице. По оси `y` откладывается количество элементов данного списка при заполненной словами таблице, то есть количество коллизий исследуемой функции. Горизонтальная красная линия на графике показывает число коллизий, если бы функция была идеальной. Если график функции совпадает с красной линией, то можно говорить о равномерном распределении функции на данном наборе данных, при данном размере хеш-таблицы. Если же изменить набор входных данных или размер хеш-таблицы, то распределение может измениться. Как будет видно далее, для некоторых функций при мелом размере хеш-таблицы распределение равномерно, а при больших размерах становится неравномерным.

1. `Всегда единица`. Как и ожидалось график этой функции представлен одним столбцом. В хеш-таблице используется только один список. Это самая плохая хеш-функция.

    <p align="center">
        <img src="images/group functions/hash_const.png" width="600"/>
    </p>

1. `ASCII-код первого символа`. Данная функция имеет неравномерное распределение при всех размерах хеш-таблицы (количествах списков в ней). Видно, что значения функции находятся примерно в промежутке от 60 до 130.

    <p align="center">
        <img src="images/group functions/hash_letter dpi 1000.png" width="600"/>
    </p>

1. `Длина слова`. Имеет неравномерное распределение при всех размерах хеш-таблицы. По графикам её множество значений ограничено 16 для большинства слов. Если провести точный подсчёт, то слов длиной 16 и больше окажется всего 7 из 30 000.

    <p align="center">
        <img src="images/group functions/hash_length dpi 200.png" width="600"/>
    </p>

1. `Сумма ASCII-кодов букв`. При малом размере хеш-таблицы (20 списков) данная функция имеет равномерное распределение. Но уже начиная со 100 списков её распределение становится неравномерным, появляется область концентрации коллизий. Полностью убедиться в неравномерности распределения можно, если посмотреть на 3 график (1500 списков), на котором лучше всего видно неравномерность распределения функции. Данная функция не подходит для использования в хеш-таблице.

    Посчитаем точное количество пустых и переполненных списков.
    |Пустые списки|Число элементов больше среднего|Число элементов не больше среднего|Всего|
    |:-:|:-:|:-:|:-:|
    | 173 | 507 | 820 | 1500|
    | 13661 | 1078 | 261 | 15000|

    <p align="center">
        <img src="images/group functions/hash_char_sum dpi 200.png" width="600"/>
    </p>

1. `Ror`. По первым двум графикам видно, что распределение функции неравномерно. Тем не менее её распределение намного лучше, чем у 4 предыдущих функций.

    Посчитаем точное количество пустых и переполненных списков.
    |Пустые списки|Число элементов больше среднего|Число элементов не больше среднего|Всего|
    |:-:|:-:|:-:|:-:|
    | 296 | 375 | 829 | 1500|
    | 10335 | 2128 | 2537 | 15000|

    <p align="center">
        <img src="images/group functions/hash_ror dpi 200.png" width="600"/>
    </p>

1. `CRC-32`. У данной функции распределение лучше, чем у предыдущих. Но оно не идеально: 13% списков пустые при размере хеш-таблицы 15000.

    Посчитаем точное количество пустых и переполненных списков.
    |Пустые списки|Число элементов больше среднего|Число элементов не больше среднего|Всего|
    |:-:|:-:|:-:|:-:|
    | 0 | 699 | 801 | 1500|
    | 1955 | 4980 | 8065 | 15000|

    Заполненность списков при размере хеш-таблицы 15000.

    |Количество элементов в списке|    0 |    1 |    2 |    3 |    4 |    5     |    6 |    7 |    8 |    9 |   10 |
    |----------------------------:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
    |Количество списков           | 1955 | 3978 | 4087 | 2779 | 1342 | 579   |  205 | 50   | 21   | 2    | 2    |

    <p align="center">
        <img src="images/group functions/hash_crc32 dpi 200.png" width="600"/>
    </p>

### Исследование хеш-фукнций. Вывод

1-5 функции не удачные для хеш-таблицы, так как их распределение неравномерно. Из приведенных функций лучше всего для хеш-таблицы подходит `CRC-32`.

## Оптимизация хеш-таблицы по скорости

### Общая методика оптимизации

 Скорость выполнения программы иногда оценивают асимптотической сложностью алгоритма `O(f(n))`, где `f(n)` - некоторая функция от количества итераций `n` определённого участка кода (например, `f(n) = 1`, `f(n) = n`). `O(f(n)) = k * f(n)` и скорость выполнения определяется не только функцией `f(n)`, но и коэффициентом `k`. Чем больше коэффициент `k`, тем медленнее выполняется программа.

 Оптимизации по производительности чаще делятся на два вида:

 1. `Алгоритмические`. В таких оптимизациях применяется новый, более быстрый алгоритм. С изменением алгоритма меняется характеризующая его асимптотическую сложность функция `f(n)`.

 1. `Аппаратные`. В таких оптимизациях алгоритм не меняют, но стремятся уменьшить коэффициент `k`. При этом функция `f(n)` не изменяется. Таким способом можно добиться большого прироста производительности.

Алгоритм оптимизации следующий:

1. С помощью профилировщика находим `узкие места программы` - участки кода, выполнение которых занимает больше всего времени.

1. Оптимизируем в первую очередь функцию, которая выполняется дольше всего.

    Почему важно сначала оптимизировать высоконагруженные участки кода? Если начать оптимизацию с функций, которые мало выполняются (занимают малый процент от общего времени выполнения программы), то, во-первых, прирост скорости после оптимизации будет незначительным. Во-вторых, многие оптимизации снижают читаемость кода и модульность программы. В-третьих, если потом приступить к оптимизации высоконагруженных функций, то их оптимизация может стать несовместимой с уже написанными оптимизациями слабонагруженных функций. Поэтому оптимизацию программы нужно проводить высоконагруженных функций.

1. После оптимизации снова измеряем время выполнения программы профилировщиком.

1. Далее снова оптимизируем самую высоконагруженную функцию.

    Если самой высоконагруженной функцией является оптимизированная в прошлый раз, и для неё больше не получается придумать оптимизации, то оптимизировать нужно вторую по времени выполнения функцию.

1. Данный процесс стоит повторять, пока заметно ускорение программы.

1. Если оптимизация даёт незначительный прирост производительности, то стоит задуматься о том, чтобы убрать её. Как уже говорилось ранее, оптимизации могут ухудшать читаемость кода и модульность программы. Это может привести к трудностям при дальнейшей поддержке и масштабировании проекта. При этом если оптимизация не даёт заметный прирост производительности, то она приносит не пользу, а вред, и стоит отказаться от такой оптимизации.

### Особенности оптимизации хеш-таблицы

В данной работе основной акцент делается на аппаратных оптимизациях. В хеш-таблице будут ускоряться основные функции: поиска, вставки и удаления элементов, потому что во время обычной работы они выполняются больше всего. При этом не имеет смысла оптимизировать, например, функцию чтения слов из файла, так как она выполняется один раз в начале работы с хеш-таблицей.

В самом начале нужно использовать функцию, имеющую равномерное распределение коллизий. Тогда операции со всеми элементами будут выполняться за одно и тоже время. В первой части работы было показано, что `CRC-32` имеет самое удачно для хеш-таблицы распределение, поэтому будем использовать именно эту хеш-функцию.

Потом нужно правильно настроить размер хеш-таблицы. В рабочем состоянии в каждом списке должно быть примерно 1-2 слова. Тогда все операции будут выполняться быстро, в оптимизациях может отсутствовать необходимость, так как они будут давать минимальный прирост производительности. Так как данная работа учебная, то чтобы можно было сделать несколько оптимизаций, установим размер хеш-таблицы так, чтобы в каждом списке в среднем было 20-30 слов.

Все три операции (поиска, вставки и удаления) содержат вычисление хеш-функции. Реализованная хеш-таблица не может хранить одинаковые слова, поэтому перед вставкой необходимо проверить, добавлено ли уже это слово. При удалении, нужно сначала найти слово в списке, а затем удалить его. Поэтому все три операции также содержат поиск элемента в списке по индексу. Из этого следует, что скорее всего придется оптимизировать именно функцию вычисления хеша и поиска элемента в списке.

При оптимизации вставки и удаления элемента, важно правильно подобрать размер списков в хеш-таблице. Если его настроить слишком маленьким, то будет много выделений памяти. Тогда может оказаться, что самая нагруженная функция это `calloc`, который крайне сложно оптимизировать. Поэтому настроим размер списков так, чтобы во время работы хеш-таблицы было 0 выделений памяти.

### Опции компиляции, условия тестирования

Программа компилировалась с помощью `Microsoft Visual Studio Community 2022`. Для поиска узких мест использовался встроенный в `Visual Studio` профилировщик.

Обозначим следующие опции компиляции:

1. Максимальная оптимизация программы. `CompReleaseMax`: `Release x64`, `/O2`, favor speed `/Ot`, enable intrinsic functions `/Oi`, inline function expansion any suitable `/Ob2`, whole program optimization `/GL`, enable enchanced instruction set `/arch:SSE2`, link time code generation `/LTCG`.

1. Опции компиляции для профилирования и поиска узких мест. `CompReleaseProfiling`: `Release x64`, `/O2`, favor speed `/Ot`, enable intrinsic functions `/Oi`, inline function expansion disabled `/Ob0`, whole program optimization `No`, enable enchanced instruction set `/arch:SSE2`, link time code generation `Default`.

`CompReleaseProfiling` отличается от `CompReleaseMax` тем, что у него выключены `inline` функции, полная оптимизация программы и кодогенерация во время компоновки. Сделано это для того, чтобы можно было анализировать результат измерения производительности, так как `CompReleaseMax` очень сильно оптимизирует программу, и нельзя найти узкое место в программе. `CompReleaseMax` активно использует inline-расширение функций и в итоге в программе остаётся 2-3 функции, которые выполняется 90% времени. По таким данным нельзя определить функции, которые нужно оптимизировать.

Тестировать работу хеш-таблицы будем на том же наборе текстов Шекспира, на котором исследовалась равномерность распределения коллизий хеш-функций. Слов в текстах, включая повторяющиеся, ~1 000 000. Различных слов в заполненной хеш-таблице будет ~30 000.
Установим размер хеш-таблицы 1 500, чтобы в каждом списке было примерно 20-30 слов.

Чтобы правильно найти узкие места программы, нужно уменьшить вклад во время выполнения программы функций, которые выполняются один раз при инициализации таблицы. Для этого будем вызывать оптимизируемую функцию ~10^9 раз. Тогда профилировщик правильно покажет какая функция самая нагруженная.

При разных запусках время выполнения программы может колебаться около среднего значения. Чтобы получить достоверную оценку времени выполнения программы, измерять время профилировщиком будем 3 раза, а затем усредним полученные данные. Также вычислим среднеквадратичное отклонения для общего времени измерения. В отчёте приводятся результаты первого профилирования.

Все результаты профилирования находятся в папке `Profiling/`. Для каждого измерения в названии указано:

1. На каких тестах оно выполнялось:

    1. `find` - тестирование поиска;
    1. `insert-remove` - тестирование вставки и удаления.

1. К какой оптимизации относятся данные тесты:

    1. `unoptimized` - не оптимизированная программа;
    1. `type optimization` - оптимизация типа данных;
    1. `hash optimization` - оптимизация хеш функции;
    1. `asm optimization` - ассемблерная оптимизация;
    1. `inline optimization` - inline оптимизация.

1. Какие опции компиляции применялись:

    1. `release` - опции компиляции `CompReleaseProfiling`;
    1. `releaseMax` - опции компиляции `CompReleaseMax`.

1. Если в названии не указано [`x86`](#inline-оптимизация), то компиляция производилась под архитектуру `x64`.

### Измерение времени работы не оптимизированной программы

Опции компиляции `CompReleaseProfiling`

#### Поиск элемента в хеш-таблице

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|154 836|159 009|154 505|

Среднее время выполнения 156 ± 3 с

<p align="center">
    <img src="Profiling/find unoptimized release/1 find unoptimized release.png" width="600"/>
</p>

#### Вставка-удаление элемента

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|279 576|283 304|280 749|

Среднее время выполнения 281 ± 2 с

<p align="center">
    <img src="Profiling/insert-remove unoptimized release/1 insert-remove unoptimized release.png"  width="600"/>
</p>

#### Анализ результата

Самой нагруженной является функция поиска элемента в списке `ListFind`. Она содержит `ListComparator` - функцию, сравнивающую два слова. На втором месте находится `HashTable_HashCRC32_C` - функция вычисления хеша `CRC32` и `CalcHash` - обертка над `HashTable_HashCRC32_C`, которая значению хеш-функции сопоставляет индекс списка, который соответствует данному слову.

Первой оптимизацией ускорим поиск элемента в списке, как самую нагруженную функцию.

### Оптимизация типа данных

Проанализируем набор входных данных: длина слова в основном не превышает 16 символов. Слов длиной 15 символов всего 33, длиной 16 - всего 3, длиной больше 16 - всего 4. Если пренебречь словами длиной больше 16 символов, то можно изменить тип данных слов с `char*` на `__m128i`. Слово будет храниться в 16 байтовой переменной, компилятор сможет сравнивать слова двумя сравнениями 64-битных регистров, что выполняется быстрее, чем побайтовое сравнение слов.

Покажем основные изменения, которые нужны для оптимизации.

Старый тип данных:
```C++
    struct Word
    {
        /// Указатель на строку, содержащую слово.
        char* Data;

        /// Длина слова.
        size_t Size;
    };

    /// Тип элементов, хранящихся в списке.
    typedef Word ListType;
```

Убрали структуру `Word` и изменили тип элементов, хранящихся в списке. Также необходимо указать максимальную длину слов:
```C++
    /// Тип элементов, хранящихся в списке.
    typedef __m128i ListType;

    /// Максимальная длина слова.
    const size_t MaximumWordSize = 16;
```

Также нужно изменить функцию, сравнивающую слова. Старую функцию
```C++
    static inline bool ListComparator(const ListType val1, const ListType val2)
    {
        if (val1.Size != val2.Size)
            return false;

        size_t maxSize = val1.Size > val2.Size? val1.Size : val2.Size;

        return strncmp(val1.Data, val2.Data, maxSize) == 0;
    }
```

изменили на
```C++
    static inline bool ListComparator(const ListType val1, const ListType val2)
    {
        return memcmp(&val1, &val2, sizeof(ListType)) == 0;
    }
```

Измерим время выполнения программы с опциями компиляции `CompReleaseProfiling`.

#### Поиск элемента в хеш-таблице

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|77 847|77 518|77 986|

Среднее время выполнения 77,8 ± 0,3 с

<p align="center">
    <img src="Profiling/find type optimization release/1 find type optimization release.png"  width="600"/>
</p>

#### Вставка-удаление элемента

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|148 337|149 892|148 694|

Среднее время выполнения 149,0 ± 0,8 с

<p align="center">
    <img src="Profiling/insert-remove type optimization release/1 insert-remove type optimization release.png"  width="600"/>
</p>

#### Анализ результата

Изменение типа данных ускорило поиск и вставку-удаление в 2 раза по сравнению с версией без оптимизации (везде опции `CompReleaseProfiling`). Подчеркнем, что данная оптимизация основана на частном случае, и компилятор никогда не сможет применить её. В условиях данной задачи удалось применить такую оптимизацию, но в общем случае её применить не получиться. При данной оптимизации производительность повышается, но общность решения задачи пропадает.

Следующей самой нагруженной функцией является вычисление хеша, поэтому будем оптимизировать её.

### Оптимизация хеш-функции

Заменим функцию вычисления контрольной суммы на `SIM-D` инструкцию `_mm_crc32_u64`. Тогда хеш будет считаться за две инструкции.

Вместо старой функции вычисления `CRC-32` табличным методом
```C++
    size_t HashTable_HashCRC32_C(const ListType* element)
    {
        assert(element);

        static bool   inited         = false;
        static size_t crc_table[256] = { 0 };

        size_t hash = 0;

        if (!inited)
        {
            inited = true;
            for (int i = 0; i < 256; i++)
            {
                hash = i;
                for (int j = 0; j < 8; j++)
                    hash = hash & 1 ? (hash >> 1) ^ 0xEDB88320UL : hash >> 1;

                crc_table[i] = hash;
            };
        }

        hash = 0xFFFFFFFFUL;

        const char*  data = (char*)element;

        for (size_t st = 0; data[st] && st < MaximumWordSize; st++)
            hash = crc_table[(hash ^ data[st]) & 0xFF] ^ (hash >> 8);

        return (hash ^ 0xFFFFFFFFUL);
    }
```
напишем новую, используюшую `SSE` интсрукции:
```C++
    size_t HashTable_HashCRC32_Intrin(const ListType* element)
    {
        assert(element);

        size_t crc = 0;

        crc = _mm_crc32_u64(crc, ((uint64_t*)element)[0]);

        return _mm_crc32_u64(crc, ((uint64_t*)element)[1]);
    }
```

Измерим время выполнения программы с опциями компиляции `CompReleaseProfiling`.

#### Поиск элемента в хеш-таблице

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|29 753|29 567|29 700|

Среднее время выполнения 29,6 ± 0,1 с

<p align="center">
    <img src="Profiling/find hash optimization release/1 find hash optimization release.png"  width="600"/>
</p>

#### Вставка-удаление элемента

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|50 368|51 369|50 233|

Среднее время выполнения 50,6 ± 0,6 с

<p align="center">
    <img src="Profiling/insert-remove hash optimization release/1 insert-remove hash optimization release.png"  width="600"/>
</p>

#### Анализ результата

Изменение типа данных ускорило поиск в 2,6 раза и вставку-удаление в 2,9 раза по сравнению с предыдущей версией.

Найдем общий прирост производительности. Поиск ускорился в 5,3 раза, а вставка-удаление в 5,4 раза.

Если посмотреть на результаты профилирования, то можно увидеть, что самыми нагруженными функциями опять являются поиск элемента в списке и вычисление хеш-функции. В результатах профилирования вставки-удаления элементов видно, что удаление элемента из таблицы `HashTableRemove` и добавление элемента в таблицу `HashTableInsert` занимают 9% и 8% соответственно от общего времени выполнения. Однако оптимизировать их не получится, так как при попытке переписать их на ассемблере или добавить `inline`-ассемблерную вставку, модульность программы резко ухудшится. Частные случаи применить к этим функциям тоже не получится.

Так как данная задача учебная, и в задании было переписать функцию на ассемблере и использовать `inline`-ассемблер, то применим эти виды оптимизации к самой нагруженной функции - вычисления хеша. Ожидается, что эти оптимизации не дадут значительного прироста производительности, но ухудшат модульность программы и читаемость кода. В реальном проекте нужно было остановиться на применении в хеш-функции `SSE` инструкции.

### Ассемблерная оптимизация

Перепишем функцию `CRC-32` на ассемблере (`HashTable/HashTable/HashAsm.asm`):
```assembly
    global HashTable_HashCRC32_Asm

    section .text

    ;------------------------------------------------------------
    ; Calculate CRC32.
    ;
    ; Entry: rcx - __m128i pointer.
    ;
    ; Return: eax - calculated CRC32.
    ;
    ; Destr: rax, rcx, rdx, r8, r9, r10, r11.
    ;------------------------------------------------------------
    HashTable_HashCRC32_Asm:
            mov r11d, -1  ; r11d = 0xFFFFFFFF;
            mov eax, r11d ; eax  = 0xFFFFFFFF;
            
            mov r9, 0     ; r9   = counter;
            mov r8, rcx   ; r8   = dataPtr;
            
            lea r10, [rel Crc32Table] ; r10 = address of Crc32Table
            
            ; for (size_t st = 0; data[st] && st < 16; st++)
    .forCondition:

            cmp byte [r8], 0 ; if (data[st] == 0) return;
            je .endFor

            cmp r9, 16
            jae .endFor

            ; for body:
            
            movzx rcx, byte [r8] ; rcx = *data
            
            xor rcx, rax ; rcx = (rax ^ *data++)
            shr rax, 8   ; rax >>= 8;
            
            movzx edx, cl ; edx = (eax ^ *data++) & 0xFF;
            
            mov ecx, dword [r10 + rdx * 4] ; ecx = Crc32Table[(eax ^ *data++) & 0xFF];
            
            ; eax = (eax >> 8) ^ Crc32Table[(eax ^ *data++) & 0xFF];
            xor rax, rcx
        
            ; step: 
            inc r8
            inc r9
            
            jmp .forCondition
        
    .endFor:

            xor rax, r11 ; eax ^= 0xFFFFFFFF;
        
            ret
    ;-----------------------------------------------------------

    section .data

    Crc32Table:
        ; ... Таблица числовых констант для вычилсения CRC32. Для краткости приводить её здесь не будем.
```

Измерим время выполнения программы с опциями компиляции `CompReleaseProfiling`.

#### Поиск элемента в хеш-таблице

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|32 179|32 717|32 767|

Среднее время выполнения 32,5 ± 0,3 с

<p align="center">
    <img src="Profiling/find asm optimization release/1 find asm optimization release.png"  width="600"/>
</p>

#### Вставка-удаление элемента

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|57 453|57 739|57 389|

Среднее время выполнения 57,5 ± 0,2 с

<p align="center">
    <img src="Profiling/insert-remove asm optimization release/1 insert-remove asm optimization release.png"  width="600"/>
</p>

#### Анализ результата

Сравним текущую и предыдущую оптимизации:

|Оптимизация|Поиск|Вставка-удаление|
|:---------:|:---:|:--------------:|
|Оптимизация хеш-функции `SSE`-инструкцией|29,6|50,6|
|Ассемблерная оптимизация|32,5|57,5|

По результатам измерений, видим, что предыдущая оптимизация была лучше: текущая оптимизация снизила скорость работы программы. Итого, данную оптимизацию применять не будем.

### Inline оптимизация

До этого программа компилировалась под 64-битную систему. Но `Visual Studio C++` компилятор [не поддерживает inline-ассемблерные вставки для 64-битных систем](https://github.com/MicrosoftDocs/cpp-docs/blob/main/docs/assembler/inline/inline-assembler.md). Единственным вариантом написания кода на ассемблере является полное написание функции на ассемблере и дальнейшая компоновка, как делалось в [ассемблерной оптимизации](#ассемблерная-оптимизация).

Но `Visual Studio C++` компилятор поддерживает inline-ассемблер для архитектуры x86. Поэтому, чтобы выполнить задание, скомпилируем последную удачную оптимизацию (оптимизация хеш-функции) под x86 и проведем измерения времени работы программы. Затем применим inline-оптимизацию, снова измерения времени работы программы и сравним полученные результаты между собой.

Вместо вызова функции `CalcHash()` в `HashTableFind()`, `HashTableInsert()` и `HashTableRemove()`
```C++
size_t listIndex = CalcHash(table, element);
```

добавим ассемблерную вставку:
```C++
	size_t listIndex = 0;

    __asm
	{
		mov	ecx, dword ptr element[0]

		xor eax, eax
		crc32 eax, dword ptr[ecx]

		crc32 eax, dword ptr[ecx + 4]

		crc32 eax, dword ptr[ecx + 8]

		crc32 eax, dword ptr[ecx + 12]

		mov ebx, table
		mov ebx, dword ptr[ebx + 4] ; table->ListCount

		xor edx, edx
		div ebx

		mov listIndex, edx
	}
```

#### Оптимизация хеш-функции, x86

Измерим время выполнения программы с оптимизацией хеш-функции. Опции компиляции `CompReleaseProfiling`, но архитектура не x64, а x86!

#### Поиск элемента в хеш-таблице

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|38 534|38 804|38 152|

Среднее время выполнения 38,5 ± 0,3 с

<p align="center">
    <img src="Profiling/find hash optimization release x86/1 find hash optimization release x86.png"  width="600"/>
</p>

#### Вставка-удаление элемента

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|63 623|62 228|63 224|

Среднее время выполнения 63,0 ± 0,7 с

<p align="center">
    <img src="Profiling/insert-remove hash optimization release x86/1 insert-remove hash optimization release x86.png"  width="600"/>
</p>

#### Inline оптимизация, x86

Измерим время выполнения программы с inline оптимизацией. Опции компиляции `CompReleaseProfiling`, но архитектура не x64, а x86!

#### Поиск элемента в хеш-таблице

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|38 841|38 529|39 160|

Среднее время выполнения 38,9 ± 0,3 с

<p align="center">
    <img src="Profiling/find inline optimization release x86/1 find inline optimization release x86.png"  width="600"/>
</p>

#### Вставка-удаление элемента

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|61 046|61 062|61 259|

Среднее время выполнения 61,1 ± 0,1 с

<p align="center">
    <img src="Profiling/insert-remove inline optimization release x86/1 insert-remove inline optimization release x86.png"  width="600"/>
</p>

#### Анализ результата

Сравним полученные результаты:

|Оптимизация|Поиск|Вставка-удаление|
|:---------:|:---:|:--------------:|
|Оптимизация хеш-функции `SSE`-инструкцией|38,5|63,0|
|Inline оптимизация|38,9|61,1|

Видим, что inline оптимизация не дала значительного прироста скорости. Но появился участко кода, который сложно поддерживать. Итого, данную оптимизацию применять не будем.

### Исследование максимального прироста производительности

Чтобы можно было найти узкие места программы, до этого применялись опции компиляции `CompReleaseProfiling`. Это не максимальные возможности оптимизации компилятора. Применим более сильные оптимизации компилятора `CompReleaseMax` и измерим, во сколько раз ускорили аппаратные оптимизации программу.

#### Измерение времени работы не оптимизированной программы `CompReleaseMax`

#### Поиск элемента в хеш-таблице

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|140 005|139 716|141 084|

Среднее время выполнения 140 ± 1 с

<p align="center">
    <img src="Profiling/find unoptimized releaseMax/1 find unoptimized releaseMax.png" width="600"/>
</p>

#### Вставка-удаление элемента

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|270 763|259 610|277 511|

Среднее время выполнения 269 ± 9 с

<p align="center">
    <img src="Profiling/insert-remove unoptimized releaseMax/1 insert-remove unoptimized releaseMax.png"  width="600"/>
</p>

#### Измерение времени работы оптимизированной программы, оптимизация хеш-функции `SSE` инструкцией. Опции компиляции `CompReleaseMax`

#### Поиск элемента в хеш-таблице

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|19 813|19 842|20 495|

Среднее время выполнения 20,0 ± 0,4 с

<p align="center">
    <img src="Profiling/find hash optimization releaseMax/1 find hash optimization releaseMax.png" width="600"/>
</p>

#### Вставка-удаление элемента

|№ измерения               |1      |2      |3      |
|-------------------------:|:-----:|:-----:|:-----:|
|Общее время выполнения, мc|43 781|43 878|43 446|

Среднее время выполнения 43,7 ± 0,2 с

<p align="center">
    <img src="Profiling/insert-remove hash optimization releaseMax/1 insert-remove hash optimization releaseMax.png"  width="600"/>
</p>

#### Анализ результата

|Оптимизация|Поиск|Вставка-удаление|
|-------------------------:|:-----:|:-----:|
|Не оптимизированная программа, `CompReleaseProfiling`|156|281|
|Не оптимизированная программа, `CompReleaseMax`|140|269|
|`SSE` Оптимизация хеш-функции, `CompReleaseProfiling`|29,6|50,6|
|`SSE` Оптимизация хеш-функции, `CompReleaseMax`|20,0|43,7|

Сравнивая между собой опции компиляции `CompReleaseProfiling`, поиск ускорился в 5,3 раза, вставка-удаление ускорилась в 5,6 раза.

Сравнивая между собой опции компиляции `CompReleaseMax`, поиск ускорился в 7 раз, вставка-удаление ускорилась в 6,1 раза.

### Оптимизация программы. Вывод

Применяя аппаратные оптимизации удалось добиться ускорения поиска в 7 раз, вставка-удаление в 6,1 раза.
