; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31105.0 

	TITLE	D:\Language C\HashTable\HashTable\Release\List.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?ListConstructor@@YAHPAUList@@I@Z		; ListConstructor
PUBLIC	?ListDestructor@@YAXPAUList@@@Z			; ListDestructor
PUBLIC	?ClearList@@YAXPAUList@@@Z			; ClearList
PUBLIC	?ListAddElemAfter@@YAHPAUList@@PBT__m128i@@I@Z	; ListAddElemAfter
PUBLIC	?ListAddElemBefore@@YAHPAUList@@PBT__m128i@@I@Z	; ListAddElemBefore
PUBLIC	?ListRemoveElem@@YAHPAUList@@I@Z		; ListRemoveElem
PUBLIC	?ListGetElemAt@@YAPAT__m128i@@PAUList@@I@Z	; ListGetElemAt
PUBLIC	?GetPhysicalIndex@@YAIPAUList@@I@Z		; GetPhysicalIndex
PUBLIC	?ListSort@@YAHPAUList@@@Z			; ListSort
PUBLIC	?ListFind@@YAIPBUList@@PBT__m128i@@@Z		; ListFind
PUBLIC	??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@ ; `string'
PUBLIC	??_C@_0DO@JDKHDNEG@int?5__cdecl?5ListConstructor?$CIstr@ ; `string'
PUBLIC	??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@ ; `string'
PUBLIC	??_C@_0CN@DEHHELMC@?P?$OA?g?l?e?p?5?q?o?h?q?j?$OA?5?$DN?5?$CFzd?5?a?n?k?$PM?x?e?5?b?l?e?q@ ; `string'
PUBLIC	??_C@_0FF@OFEGCKDJ@int?5__cdecl?5ListAddElemAfter?$CIst@ ; `string'
PUBLIC	??_C@_0DJ@LCGIIKOJ@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?n?q?k?e?5@ ; `string'
PUBLIC	??_C@_0FG@FFEJPFPM@int?5__cdecl?5ListAddElemBefore?$CIs@ ; `string'
PUBLIC	??_C@_0DI@GIIDHNGH@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?e?p?e?d?5@ ; `string'
PUBLIC	??_C@_0DN@LJHLEGEB@int?5__cdecl?5ListRemoveElem?$CIstru@ ; `string'
PUBLIC	??_C@_0CL@IKBFECN@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?$PN?k?e?l?e?m?r?5?h?g?5?o?s?q?r@ ; `string'
PUBLIC	??_C@_0DB@GHEAINCG@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?o?s?q?r?n?i?5?$PN?k?e?l?e?m?r?4@ ; `string'
PUBLIC	??_C@_0GB@GEKNKDCH@?O?n?o?$PL?r?j?$OA?5?o?n?k?s?w?h?r?$PM?5?d?n?q?r?s?o?5?j?5?m?e?5?q?s@ ; `string'
PUBLIC	??_C@_0EH@HLJLCEEK@union?5__m128i?5?$CK__cdecl?5ListGetE@ ; `string'
PUBLIC	??_C@_0GB@ELFHLDAC@?M?e?o?p?e?d?b?h?d?e?m?m?$OA?$PP?5?n?x?h?a?j?$OA?4?5?H?q?o?n?k?m?e?m@ ; `string'
PUBLIC	??_C@_0EI@DHIPHLGP@unsigned?5int?5__cdecl?5GetPhysica@ ; `string'
PUBLIC	??_C@_0CG@HCIHDPOL@int?5__cdecl?5ListResize?$CIstruct?5L@ ; `string'
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__realloc:PROC
EXTRN	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z:PROC ; LogLine
EXTRN	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ:PROC ; LogFLine
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__dtol3:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT ??_C@_0CG@HCIHDPOL@int?5__cdecl?5ListResize?$CIstruct?5L@
CONST	SEGMENT
??_C@_0CG@HCIHDPOL@int?5__cdecl?5ListResize?$CIstruct?5L@ DB 'int __cdecl'
	DB	' ListResize(struct List *)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@DHIPHLGP@unsigned?5int?5__cdecl?5GetPhysica@
CONST	SEGMENT
??_C@_0EI@DHIPHLGP@unsigned?5int?5__cdecl?5GetPhysica@ DB 'unsigned int _'
	DB	'_cdecl GetPhysicalIndex(struct List *,const unsigned int)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@ELFHLDAC@?M?e?o?p?e?d?b?h?d?e?m?m?$OA?$PP?5?n?x?h?a?j?$OA?4?5?H?q?o?n?k?m?e?m@
CONST	SEGMENT
??_C@_0GB@ELFHLDAC@?M?e?o?p?e?d?b?h?d?e?m?m?$OA?$PP?5?n?x?h?a?j?$OA?4?5?H?q?o?n?k?m?e?m@ DB 0cdH
	DB	0e5H, 0efH, 0f0H, 0e5H, 0e4H, 0e2H, 0e8H, 0e4H, 0e5H, 0edH, 0edH
	DB	0e0H, 0ffH, ' ', 0eeH, 0f8H, 0e8H, 0e1H, 0eaH, 0e0H, '. ', 0c8H
	DB	0f1H, 0efH, 0eeH, 0ebH, 0edH, 0e5H, 0edH, 0e8H, 0e5H, ' ', 0edH
	DB	0e5H, ' ', 0e2H, 0eeH, 0e7H, 0ecH, 0eeH, 0e6H, 0edH, 0eeH, 0e3H
	DB	0eeH, ' ', 0eaH, 0eeH, 0e4H, 0e0H, '. ', 0cbH, 0eeH, 0e3H, 0e8H
	DB	0f7H, 0e5H, 0f1H, 0eaH, 0e8H, 0e9H, ' ', 0fdH, 0ebH, 0e5H, 0ecH
	DB	0e5H, 0edH, 0f2H, ' ', 0edH, 0e5H, ' ', 0e1H, 0fbH, 0ebH, ' ', 0edH
	DB	0e0H, 0e9H, 0e4H, 0e5H, 0edH, ' ', 0e2H, ' ', 0f1H, 0efH, 0e8H
	DB	0f1H, 0eaH, 0e5H, '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@HLJLCEEK@union?5__m128i?5?$CK__cdecl?5ListGetE@
CONST	SEGMENT
??_C@_0EH@HLJLCEEK@union?5__m128i?5?$CK__cdecl?5ListGetE@ DB 'union __m12'
	DB	'8i *__cdecl ListGetElemAt(struct List *,const unsigned int)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@GEKNKDCH@?O?n?o?$PL?r?j?$OA?5?o?n?k?s?w?h?r?$PM?5?d?n?q?r?s?o?5?j?5?m?e?5?q?s@
CONST	SEGMENT
??_C@_0GB@GEKNKDCH@?O?n?o?$PL?r?j?$OA?5?o?n?k?s?w?h?r?$PM?5?d?n?q?r?s?o?5?j?5?m?e?5?q?s@ DB 0cfH
	DB	0eeH, 0efH, 0fbH, 0f2H, 0eaH, 0e0H, ' ', 0efH, 0eeH, 0ebH, 0f3H
	DB	0f7H, 0e8H, 0f2H, 0fcH, ' ', 0e4H, 0eeH, 0f1H, 0f2H, 0f3H, 0efH
	DB	' ', 0eaH, ' ', 0edH, 0e5H, ' ', 0f1H, 0f3H, 0f9H, 0e5H, 0f1H, 0f2H
	DB	0e2H, 0f3H, 0feH, 0f9H, 0e5H, 0ecH, 0f3H, ' ', 0fdH, 0ebH, 0e5H
	DB	0ecH, 0e5H, 0edH, 0f2H, 0f3H, ' ', 0f1H, 0efH, 0e8H, 0f1H, 0eaH
	DB	0e0H, '. logicalIndex = %zd, list->Size = %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GHEAINCG@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?o?s?q?r?n?i?5?$PN?k?e?l?e?m?r?4@
CONST	SEGMENT
??_C@_0DB@GHEAINCG@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?o?s?q?r?n?i?5?$PN?k?e?l?e?m?r?4@ DB 0cfH
	DB	0eeH, 0efH, 0fbH, 0f2H, 0eaH, 0e0H, ' ', 0f3H, 0e4H, 0e0H, 0ebH
	DB	0e8H, 0f2H, 0fcH, ' ', 0efH, 0f3H, 0f1H, 0f2H, 0eeH, 0e9H, ' ', 0fdH
	DB	0ebH, 0e5H, 0ecH, 0e5H, 0edH, 0f2H, '. dataIndex = %zd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IKBFECN@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?$PN?k?e?l?e?m?r?5?h?g?5?o?s?q?r@
CONST	SEGMENT
??_C@_0CL@IKBFECN@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?$PN?k?e?l?e?m?r?5?h?g?5?o?s?q?r@ DB 0cfH
	DB	0eeH, 0efH, 0fbH, 0f2H, 0eaH, 0e0H, ' ', 0f3H, 0e4H, 0e0H, 0ebH
	DB	0e8H, 0f2H, 0fcH, ' ', 0fdH, 0ebH, 0e5H, 0ecH, 0e5H, 0edH, 0f2H
	DB	' ', 0e8H, 0e7H, ' ', 0efH, 0f3H, 0f1H, 0f2H, 0eeH, 0e3H, 0eeH
	DB	' ', 0f1H, 0efH, 0e8H, 0f1H, 0eaH, 0e0H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@LJHLEGEB@int?5__cdecl?5ListRemoveElem?$CIstru@
CONST	SEGMENT
??_C@_0DN@LJHLEGEB@int?5__cdecl?5ListRemoveElem?$CIstru@ DB 'int __cdecl '
	DB	'ListRemoveElem(struct List *,const unsigned int)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GIIDHNGH@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?e?p?e?d?5@
CONST	SEGMENT
??_C@_0DI@GIIDHNGH@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?e?p?e?d?5@ DB 0cfH
	DB	0eeH, 0efH, 0fbH, 0f2H, 0eaH, 0e0H, ' ', 0e4H, 0eeH, 0e1H, 0e0H
	DB	0e2H, 0e8H, 0f2H, 0fcH, ' ', 0fdH, 0ebH, 0e5H, 0ecH, 0e5H, 0edH
	DB	0f2H, ' ', 0efH, 0e5H, 0f0H, 0e5H, 0e4H, ' ', 0efH, 0f3H, 0f1H
	DB	0f2H, 0fbH, 0ecH, '. dataIndex = %zd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@FFEJPFPM@int?5__cdecl?5ListAddElemBefore?$CIs@
CONST	SEGMENT
??_C@_0FG@FFEJPFPM@int?5__cdecl?5ListAddElemBefore?$CIs@ DB 'int __cdecl '
	DB	'ListAddElemBefore(struct List *,const union __m128i *,const u'
	DB	'nsigned int)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LCGIIKOJ@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?n?q?k?e?5@
CONST	SEGMENT
??_C@_0DJ@LCGIIKOJ@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?n?q?k?e?5@ DB 0cfH
	DB	0eeH, 0efH, 0fbH, 0f2H, 0eaH, 0e0H, ' ', 0e4H, 0eeH, 0e1H, 0e0H
	DB	0e2H, 0e8H, 0f2H, 0fcH, ' ', 0fdH, 0ebH, 0e5H, 0ecH, 0e5H, 0edH
	DB	0f2H, ' ', 0efH, 0eeH, 0f1H, 0ebH, 0e5H, ' ', 0efH, 0f3H, 0f1H
	DB	0f2H, 0eeH, 0e3H, 0eeH, '. dataIndex = %zd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@OFEGCKDJ@int?5__cdecl?5ListAddElemAfter?$CIst@
CONST	SEGMENT
??_C@_0FF@OFEGCKDJ@int?5__cdecl?5ListAddElemAfter?$CIst@ DB 'int __cdecl '
	DB	'ListAddElemAfter(struct List *,const union __m128i *,const un'
	DB	'signed int)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DEHHELMC@?P?$OA?g?l?e?p?5?q?o?h?q?j?$OA?5?$DN?5?$CFzd?5?a?n?k?$PM?x?e?5?b?l?e?q@
CONST	SEGMENT
??_C@_0CN@DEHHELMC@?P?$OA?g?l?e?p?5?q?o?h?q?j?$OA?5?$DN?5?$CFzd?5?a?n?k?$PM?x?e?5?b?l?e?q@ DB 0d0H
	DB	0e0H, 0e7H, 0ecH, 0e5H, 0f0H, ' ', 0f1H, 0efH, 0e8H, 0f1H, 0eaH
	DB	0e0H, ' = %zd ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0e5H, ' ', 0e2H
	DB	0ecH, 0e5H, 0f1H, 0f2H, 0e8H, 0ecH, 0eeH, 0f1H, 0f2H, 0e8H, ' '
	DB	'= %zd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
CONST	SEGMENT
??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0e2H, 0fbH, 0e4H, 0e5H, 0ebH
	DB	0e5H, 0edH, 0e8H, 0ffH, ' ', 0efH, 0e0H, 0ecH, 0ffH, 0f2H, 0e8H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JDKHDNEG@int?5__cdecl?5ListConstructor?$CIstr@
CONST	SEGMENT
??_C@_0DO@JDKHDNEG@int?5__cdecl?5ListConstructor?$CIstr@ DB 'int __cdecl '
	DB	'ListConstructor(struct List *,const unsigned int)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
CONST	SEGMENT
??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@ DB 'D:\Language '
	DB	'C\HashTable\HashTable\List\List.cpp', 00H	; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListResize@@YAHPAUList@@@Z
_TEXT	SEGMENT
_oldCapacity$1$ = 8					; size = 4
_list$ = 8						; size = 4
?ListResize@@YAHPAUList@@@Z PROC			; ListResize, COMDAT

; 563  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 564  :     LOG_LIST_TRACE_FUNC_1;
; 565  : 
; 566  :     assert(list);
; 567  : 
; 568  :     LIST_ASSERT_STATUS;
; 569  :     
; 570  :     // Перед вызовом функции нужно проверять, что список полон.
; 571  :     assert(CHECK_LIST_FULL(list));
; 572  : 
; 573  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 574  :     
; 575  :     size_t oldCapacity = list->Capacity;

	mov	esi, DWORD PTR _list$[ebp]
	push	edi
	mov	ebx, DWORD PTR [esi+20]

; 576  :     size_t newCapacity = (size_t)((double)oldCapacity * ListResizeCoef);

	mov	eax, ebx
	shr	eax, 31					; 0000001fH
	mov	DWORD PTR _oldCapacity$1$[ebp], ebx
	movd	xmm0, ebx
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	addsd	xmm0, xmm0
	call	__dtol3
	mov	edi, eax

; 577  : 
; 578  :     if (newCapacity <= oldCapacity)

	cmp	edi, ebx
	ja	SHORT $LN5@ListResize

; 579  :     {
; 580  :         LOG_LIST_ERR_MEMORY;

	push	580					; 00000244H
$LN12@ListResize:

; 621  : }

	push	OFFSET ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0CG@HCIHDPOL@int?5__cdecl?5ListResize?$CIstruct?5L@
	push	1
	push	2
	push	4
	push	OFFSET ??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine
	mov	eax, DWORD PTR [esi+28]
	add	esp, 28					; 0000001cH
	or	eax, 1
	mov	DWORD PTR [esi+28], eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN5@ListResize:

; 581  : 
; 582  :         list->Status |= LIST_ERR_MEMORY;
; 583  : 
; 584  :         return list->Status;
; 585  :     }
; 586  : 
; 587  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 588  : 
; 589  :     ListNode* nodes = (ListNode*)realloc(list->Nodes, (newCapacity + 1) * sizeof(ListNode));

	xor	ecx, ecx
	lea	eax, DWORD PTR [edi+1]
	mov	edx, 32					; 00000020H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__realloc
	mov	ebx, eax
	add	esp, 8

; 590  : 
; 591  :     if (!nodes)

	test	ebx, ebx
	jne	SHORT $LN6@ListResize

; 592  :     {
; 593  :         LOG_LIST_ERR_MEMORY;

	push	593					; 00000251H

; 594  : 
; 595  :         list->Status |= LIST_ERR_MEMORY;
; 596  : 
; 597  :         return list->Status;

	jmp	SHORT $LN12@ListResize
$LN6@ListResize:

; 604  :     
; 605  :     // Очищаем новую память.
; 606  :     memset(nodes + (oldCapacity + 1), 0, (newCapacity - oldCapacity) * sizeof(ListNode));

	mov	ecx, DWORD PTR _oldCapacity$1$[ebp]
	mov	eax, edi
	sub	eax, ecx
	mov	DWORD PTR [esi], ebx
	shl	eax, 5
	push	eax
	lea	eax, DWORD PTR [ecx+1]
	shl	eax, 5
	add	eax, ebx
	push	0
	push	eax
	call	_memset

; 607  : 
; 608  :     // Добавляем выделенную память в список свободных элементов.
; 609  :     for (size_t st = oldCapacity + 1; st <= newCapacity; st++)

	mov	eax, DWORD PTR _oldCapacity$1$[ebp]
	add	esp, 12					; 0000000cH
	inc	eax
	mov	ecx, eax
	cmp	ecx, edi
	ja	SHORT $LN3@ListResize

; 598  :     }
; 599  : 
; 600  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 601  :     
; 602  :     // Выделение памяти произошло успешно, сохраняем указатель на новый блок памяти.
; 603  :     list->Nodes = nodes;

	mov	edx, ecx
	shl	edx, 5
	add	edx, ebx
$LL4@ListResize:

; 610  :         nodes[st].Next = st + 1;

	inc	ecx
	lea	edx, DWORD PTR [edx+32]
	mov	DWORD PTR [edx-32], ecx
	cmp	ecx, edi
	jbe	SHORT $LL4@ListResize
$LN3@ListResize:

; 611  : 
; 612  :     // Ново выделенная память добавляется перед старой свободной памятью, от этого собьётся сортировка.
; 613  :     nodes[newCapacity].Next = 0;

	mov	ecx, edi

; 614  :     list->Free = oldCapacity + 1;
; 615  : 
; 616  :     list->Capacity = newCapacity;

	mov	DWORD PTR [esi+20], edi
	shl	ecx, 5
	mov	DWORD PTR [esi+4], eax

; 617  : 
; 618  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 619  :     
; 620  :     return list->Status;

	mov	eax, DWORD PTR [esi+28]
	pop	edi

; 621  : }

	pop	esi
	mov	DWORD PTR [ecx+ebx], 0
	pop	ebx
	pop	ebp
	ret	0
?ListResize@@YAHPAUList@@@Z ENDP			; ListResize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListFind@@YAIPBUList@@PBT__m128i@@@Z
_TEXT	SEGMENT
_nodes$1$ = -8						; size = 4
_listSize$1$ = -4					; size = 4
tv157 = 8						; size = 4
_list$ = 8						; size = 4
_element$ = 12						; size = 4
?ListFind@@YAIPBUList@@PBT__m128i@@@Z PROC		; ListFind, COMDAT

; 530  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 531  :     LOG_LIST_TRACE_FUNC_0;
; 532  : 
; 533  :     assert(list);
; 534  :     assert(element);
; 535  : 
; 536  :     LIST_ASSERT_STATUS;
; 537  : 
; 538  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 539  :     
; 540  :     size_t          current   = list->Head;

	mov	eax, DWORD PTR _list$[ebp]
	push	esi
	push	edi

; 541  :     const size_t    listSize  = list->Size;
; 542  :     const ListNode* nodes     = list->Nodes;
; 543  :     const ListType  elemValue = *element;
; 544  : 
; 545  :     // Линейный поиск элементов.
; 546  :     for (size_t st = 0; st < listSize; st++)

	xor	esi, esi
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _element$[ebp]
	mov	DWORD PTR _listSize$1$[ebp], ecx
	mov	DWORD PTR _nodes$1$[ebp], edx
	movups	xmm0, XMMWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@ListFind
$LL4@ListFind:

; 547  :     {
; 548  :         if (ListComparator(elemValue, nodes[current].Data))

	mov	eax, edi
	shl	eax, 5
	add	eax, edx
	mov	DWORD PTR tv157[ebp], eax
	movups	xmm1, XMMWORD PTR [eax+16]
	call	?ListComparator@@YA_NT__m128i@@0@Z	; ListComparator
	test	al, al
	jne	SHORT $LN8@ListFind

; 550  : 
; 551  :         current = nodes[current].Next;

	mov	edi, DWORD PTR tv157[ebp]
	inc	esi
	mov	edx, DWORD PTR _nodes$1$[ebp]
	mov	edi, DWORD PTR [edi]
	cmp	esi, DWORD PTR _listSize$1$[ebp]
	jb	SHORT $LL4@ListFind
$LN3@ListFind:
	pop	edi

; 552  :     }
; 553  : 
; 554  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 555  : 
; 556  :     return 0;

	xor	eax, eax

; 557  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@ListFind:

; 549  :             return current;

	mov	eax, edi
	pop	edi

; 557  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?ListFind@@YAIPBUList@@PBT__m128i@@@Z ENDP		; ListFind
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListSort@@YAHPAUList@@@Z
_TEXT	SEGMENT
_listCapacity$1$ = -16					; size = 4
tv399 = -12						; size = 4
_nextIndex$1$ = -12					; size = 4
_listSize$1$ = -8					; size = 4
_nodes$1$ = -4						; size = 4
_list$ = 8						; size = 4
?ListSort@@YAHPAUList@@@Z PROC				; ListSort, COMDAT

; 446  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 447  :     LOG_LIST_TRACE_FUNC_0;
; 448  : 
; 449  :     assert(list);
; 450  : 
; 451  :     LIST_ASSERT_STATUS;
; 452  : 
; 453  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 454  : 
; 455  :     const size_t listSize     = list->Size;

	mov	ecx, DWORD PTR _list$[ebp]
	push	esi
	push	edi

; 456  :     const size_t listCapacity = list->Capacity;
; 457  :     size_t       currentIndex = 0;

	xor	esi, esi
	mov	eax, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [ecx+20]
	mov	DWORD PTR _listSize$1$[ebp], eax

; 458  :     size_t       nextIndex    = 0;
; 459  : 
; 460  :     ListNode     tmp          = {};
; 461  : 
; 462  :     ListNode*    nodes        = list->Nodes;

	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	mov	DWORD PTR _listCapacity$1$[ebp], edi
	mov	edx, eax
	mov	DWORD PTR _nodes$1$[ebp], eax
$LL4@ListSort:

; 463  : 
; 464  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 465  : 
; 466  :     // Размещаем узлы в нужном порядке.
; 467  :     for (size_t correctIndex = 0; correctIndex <= listSize; correctIndex++)
; 468  :     {
; 469  :         nextIndex = nodes[currentIndex].Next;

	mov	edi, DWORD PTR _nodes$1$[ebp]
	mov	eax, esi
	shl	eax, 5
	mov	edi, DWORD PTR [eax+edi]
	mov	DWORD PTR _nextIndex$1$[ebp], edi

; 470  : 
; 471  :         // Если элемент находится не на своём месте, то его нужно поставить на правильное место.
; 472  :         if (currentIndex != correctIndex)

	mov	edi, DWORD PTR _listSize$1$[ebp]
	cmp	esi, ecx
	je	SHORT $LN11@ListSort

; 473  :         {
; 474  :             memcpy(&tmp, nodes + currentIndex, sizeof(ListNode));

	mov	esi, DWORD PTR _nodes$1$[ebp]

; 475  : 
; 476  :             memcpy(nodes + currentIndex, nodes + correctIndex, sizeof(ListNode));

	movups	xmm0, XMMWORD PTR [edx]
	movups	xmm1, XMMWORD PTR [eax+esi]
	movups	xmm2, XMMWORD PTR [eax+esi+16]
	movups	XMMWORD PTR [eax+esi], xmm0
	movups	xmm0, XMMWORD PTR [edx+16]
	movups	XMMWORD PTR [eax+esi+16], xmm0

; 477  : 
; 478  :             memcpy(nodes + correctIndex, &tmp, sizeof(ListNode));

	movups	XMMWORD PTR [edx], xmm1
	movups	XMMWORD PTR [edx+16], xmm2
$LN11@ListSort:

; 479  :         }
; 480  : 
; 481  :         currentIndex = nextIndex;

	mov	esi, DWORD PTR _nextIndex$1$[ebp]
	inc	ecx
	add	edx, 32					; 00000020H
	cmp	ecx, edi
	jbe	SHORT $LL4@ListSort

; 482  :     }
; 483  : 
; 484  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 485  : 
; 486  :     // Устанавливаем голову и хвост.
; 487  :     list->Head = 1;

	mov	eax, DWORD PTR _list$[ebp]
	lea	esi, DWORD PTR [edi+1]
	mov	edx, DWORD PTR _nodes$1$[ebp]
	or	ecx, -1

; 488  :     list->Tail = listSize;

	mov	DWORD PTR [eax+12], edi
	mov	edi, DWORD PTR _listCapacity$1$[ebp]
	mov	DWORD PTR [eax+8], 1
	npad	2
$LL7@ListSort:

; 489  : 
; 490  :     // Устанавливаем значения указателей Next и Prev.
; 491  : 
; 492  :     // Устанавливаем значения Next и Prev для заполненной части.
; 493  :     for (size_t listIndex = 0; listIndex <= listSize; listIndex++)
; 494  :     {
; 495  :         nodes[listIndex].Next = listIndex + 1;

	lea	eax, DWORD PTR [ecx+2]

; 496  :         nodes[listIndex].Prev = listIndex - 1;

	mov	DWORD PTR [edx+4], ecx
	inc	ecx
	mov	DWORD PTR [edx], eax
	lea	edx, DWORD PTR [edx+32]
	sub	esi, 1
	jne	SHORT $LL7@ListSort

; 497  :     }
; 498  : 
; 499  :     // Закольцовываем массивы.
; 500  :     nodes[0].Prev        = listSize;

	mov	ecx, DWORD PTR _listSize$1$[ebp]

; 501  :     nodes[listSize].Next = 0;

	mov	eax, ecx
	mov	edx, DWORD PTR _nodes$1$[ebp]
	shl	eax, 5
	mov	DWORD PTR [edx+4], ecx
	add	edx, eax

; 502  : 
; 503  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 504  : 
; 505  :     // Инициализируем свободные элементы.
; 506  :     if (listSize < listCapacity)

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx], esi
	lea	esi, DWORD PTR [ecx+1]
	cmp	ecx, edi
	jae	SHORT $LN12@ListSort

; 507  :     {
; 508  :         // Свободные элементы есть.
; 509  :         list->Free = listSize + 1;

	mov	DWORD PTR [eax+4], esi

; 510  : 
; 511  :         // Очищаем новую память.
; 512  :         memset(nodes + (listSize + 1), 0, (listCapacity - listSize) * sizeof(ListNode));

	mov	eax, edi
	sub	eax, ecx
	shl	eax, 5
	push	eax
	lea	eax, DWORD PTR [edx+32]
	push	0
	push	eax
	call	_memset

; 513  : 
; 514  :         // Устанавливаем значения Next и Prev для свободных элементов.
; 515  :         for (size_t st = listSize + 1; st < listCapacity; st++)

	mov	eax, DWORD PTR _nodes$1$[ebp]
	add	esp, 12					; 0000000cH
	cmp	esi, edi
	jae	SHORT $LN9@ListSort

; 507  :     {
; 508  :         // Свободные элементы есть.
; 509  :         list->Free = listSize + 1;

	mov	ecx, esi
	shl	ecx, 5
	add	ecx, eax
$LL10@ListSort:

; 516  :             nodes[st].Next = st + 1;

	inc	esi
	lea	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx-32], esi
	cmp	esi, edi
	jb	SHORT $LL10@ListSort
$LN9@ListSort:

; 517  : 
; 518  :         // Последний элемент указывает на 0.
; 519  :         nodes[listCapacity].Next = 0;

	shl	edi, 5
	mov	DWORD PTR [edi+eax], 0

; 523  : 
; 524  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 525  : 
; 526  :     return list->Status;

	mov	eax, DWORD PTR _list$[ebp]
	pop	edi

; 527  : }

	pop	esi
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@ListSort:
	pop	edi

; 520  :     }
; 521  :     else
; 522  :         list->Free = 0;            // Список полон.

	mov	DWORD PTR [eax+4], 0

; 527  : }

	mov	eax, DWORD PTR [eax+28]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?ListSort@@YAHPAUList@@@Z ENDP				; ListSort
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?GetPhysicalIndex@@YAIPAUList@@I@Z
_TEXT	SEGMENT
_list$ = 8						; size = 4
_logicalIndex$ = 12					; size = 4
?GetPhysicalIndex@@YAIPAUList@@I@Z PROC			; GetPhysicalIndex, COMDAT

; 406  : {

	push	ebp
	mov	ebp, esp

; 407  :     LOG_LIST_TRACE_FUNC_0;
; 408  : 
; 409  :     assert(list);
; 410  : 
; 411  :     LIST_ASSERT_STATUS;
; 412  : 
; 413  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 414  : 
; 415  :     if (logicalIndex > list->Size)

	mov	ecx, DWORD PTR _logicalIndex$[ebp]
	push	esi
	mov	esi, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [esi+16]
	cmp	ecx, eax
	jbe	SHORT $LN5@GetPhysica

; 416  :     {
; 417  :         LOG_F_LIST_ERR("Попытка получить доступ к не существующему элементу списка. "

	push	eax
	push	ecx
	push	OFFSET ??_C@_0GB@GEKNKDCH@?O?n?o?$PL?r?j?$OA?5?o?n?k?s?w?h?r?$PM?5?d?n?q?r?s?o?5?j?5?m?e?5?q?s@
	push	418					; 000001a2H
	push	OFFSET ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0EI@DHIPHLGP@unsigned?5int?5__cdecl?5GetPhysica@
	push	1
	push	2
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 418  :                        "logicalIndex = %zd, list->Size = %zd", logicalIndex, list->Size);
; 419  : 
; 420  :         list->Status |= LIST_ERR_SELECT_FREE;

	or	DWORD PTR [esi+28], 4
	add	esp, 36					; 00000024H

; 421  : 
; 422  :         return 0;

	xor	eax, eax
	pop	esi

; 436  : 
; 437  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 438  : 
; 439  :     return cur;
; 440  : }

	pop	ebp
	ret	0
$LN5@GetPhysica:

; 423  :     }
; 424  : 
; 425  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 426  : 
; 427  :     // Если список отсортирован, то логический индекс совпадает с физическим.
; 428  :     if (list->Sorted)

	cmp	BYTE PTR [esi+24], 0
	mov	eax, DWORD PTR [esi+8]
	je	SHORT $LN6@GetPhysica

; 429  :         return logicalIndex + list->Head;

	add	eax, ecx
	pop	esi

; 436  : 
; 437  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 438  : 
; 439  :     return cur;
; 440  : }

	pop	ebp
	ret	0
$LN6@GetPhysica:

; 430  : 
; 431  :     // Иначе поиск за линейное время.
; 432  :     size_t cur = list->Head;
; 433  : 
; 434  :     for (size_t st = 0; st < logicalIndex; st++)

	test	ecx, ecx
	je	SHORT $LN1@GetPhysica

; 435  :         cur = list->Nodes[cur].Next;

	mov	edx, DWORD PTR [esi]
$LL4@GetPhysica:
	shl	eax, 5
	mov	eax, DWORD PTR [eax+edx]
	sub	ecx, 1
	jne	SHORT $LL4@GetPhysica
$LN1@GetPhysica:
	pop	esi

; 436  : 
; 437  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 438  : 
; 439  :     return cur;
; 440  : }

	pop	ebp
	ret	0
?GetPhysicalIndex@@YAIPAUList@@I@Z ENDP			; GetPhysicalIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListGetElemAt@@YAPAT__m128i@@PAUList@@I@Z
_TEXT	SEGMENT
_list$ = 8						; size = 4
_logicalIndex$ = 12					; size = 4
?ListGetElemAt@@YAPAT__m128i@@PAUList@@I@Z PROC		; ListGetElemAt, COMDAT

; 349  : {

	push	ebp
	mov	ebp, esp

; 350  :     LOG_LIST_TRACE_FUNC_0;
; 351  : 
; 352  :     assert(list);
; 353  : 
; 354  :     LIST_ASSERT_STATUS;
; 355  : 
; 356  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 357  : 
; 358  :     if (logicalIndex > list->Size)

	mov	edx, DWORD PTR _logicalIndex$[ebp]
	push	esi
	mov	esi, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [esi+16]
	cmp	edx, eax
	jbe	SHORT $LN4@ListGetEle

; 359  :     {
; 360  :         LOG_F_LIST_ERR("Попытка получить доступ к не существующему элементу списка. "

	push	eax
	push	edx
	push	OFFSET ??_C@_0GB@GEKNKDCH@?O?n?o?$PL?r?j?$OA?5?o?n?k?s?w?h?r?$PM?5?d?n?q?r?s?o?5?j?5?m?e?5?q?s@
	push	361					; 00000169H
	push	OFFSET ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0EH@HLJLCEEK@union?5__m128i?5?$CK__cdecl?5ListGetE@
	push	1
	push	2
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 361  :                      "logicalIndex = %zd, list->Size = %zd", logicalIndex, list->Size);
; 362  : 
; 363  :         list->Status |= LIST_ERR_SELECT_FREE;

	or	DWORD PTR [esi+28], 4
	add	esp, 36					; 00000024H

; 364  : 
; 365  :         return nullptr;

	xor	eax, eax
	pop	esi

; 403  : }

	pop	ebp
	ret	0
$LN4@ListGetEle:

; 366  :     }
; 367  : 
; 368  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 369  : 
; 370  :     ListNode* nodes = list->Nodes;
; 371  : 
; 372  :     // Если список отсортирован, то логический индекс равен физическому.
; 373  :     // Иначе ищем индекс за линейное время.
; 374  :     if (list->Sorted)

	cmp	BYTE PTR [esi+24], 0
	mov	eax, DWORD PTR [esi+8]
	push	ebx
	mov	ebx, DWORD PTR [esi]
	je	SHORT $LN5@ListGetEle

; 375  :     {
; 376  :         return &nodes[logicalIndex + list->Head].Data;

	add	eax, edx
	shl	eax, 5
	add	eax, 16					; 00000010H
	add	eax, ebx
	pop	ebx
	pop	esi

; 403  : }

	pop	ebp
	ret	0
$LN5@ListGetEle:
	push	edi

; 377  :     }
; 378  :     else
; 379  :     {
; 380  :         size_t cur   = list->Head;
; 381  :         size_t end   = list->Tail;

	mov	edi, DWORD PTR [esi+12]

; 382  :         size_t index = 0;

	xor	ecx, ecx

; 383  : 
; 384  :         while (cur != end)

	cmp	eax, edi
	je	SHORT $LN3@ListGetEle
$LL2@ListGetEle:

; 385  :         {
; 386  :             if (index == logicalIndex)

	shl	eax, 5
	add	eax, ebx
	cmp	ecx, edx
	je	SHORT $LN10@ListGetEle

; 388  : 
; 389  :             index++;
; 390  :             cur = nodes[cur].Next;

	mov	eax, DWORD PTR [eax]
	inc	ecx
	cmp	eax, edi
	jne	SHORT $LL2@ListGetEle
$LN3@ListGetEle:

; 391  :         }
; 392  :     }
; 393  : 
; 394  :     // Данный код физически не может исполниться.
; 395  :     LOG_LIST_ERR("Непредвиденная ошибка. Исполнение не возможного кода. "

	push	396					; 0000018cH
	push	OFFSET ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0EH@HLJLCEEK@union?5__m128i?5?$CK__cdecl?5ListGetE@
	push	1
	push	2
	push	4
	push	OFFSET ??_C@_0GB@ELFHLDAC@?M?e?o?p?e?d?b?h?d?e?m?m?$OA?$PP?5?n?x?h?a?j?$OA?4?5?H?q?o?n?k?m?e?m@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine

; 396  :                  "Логический элемент не был найден в списке.");
; 397  : 
; 398  :     list->Status |= LIST_ERR_SELECT_FREE;

	or	DWORD PTR [esi+28], 4
	add	esp, 28					; 0000001cH

; 399  : 
; 400  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 401  : 
; 402  :     return nullptr;

	xor	eax, eax
	pop	edi
	pop	ebx
	pop	esi

; 403  : }

	pop	ebp
	ret	0
$LN10@ListGetEle:
	pop	edi
	pop	ebx

; 387  :                 return &nodes[cur].Data;

	add	eax, 16					; 00000010H
	pop	esi

; 403  : }

	pop	ebp
	ret	0
?ListGetElemAt@@YAPAT__m128i@@PAUList@@I@Z ENDP		; ListGetElemAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListRemoveElem@@YAHPAUList@@I@Z
_TEXT	SEGMENT
_nodes$1$ = -4						; size = 4
_prevIndex$1$ = 8					; size = 4
_list$ = 8						; size = 4
_dataIndex$ = 12					; size = 4
?ListRemoveElem@@YAHPAUList@@I@Z PROC			; ListRemoveElem, COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	edx, DWORD PTR _dataIndex$[ebp]
	push	esi

; 283  :     LOG_LIST_TRACE_FUNC_0;
; 284  : 
; 285  :     assert(list);
; 286  : 
; 287  :     LIST_ASSERT_STATUS;
; 288  : 
; 289  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 290  : 
; 291  :     if (list->Size <= 0)

	mov	esi, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [esi+16], 0
	ja	SHORT $LN2@ListRemove

; 292  :     {
; 293  :         LOG_LIST_ERR("Попытка удалить элемент из пустого списка.");

	push	293					; 00000125H
	push	OFFSET ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0DN@LJHLEGEB@int?5__cdecl?5ListRemoveElem?$CIstru@
	push	1
	push	2
	push	4
	push	OFFSET ??_C@_0CL@IKBFECN@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?$PN?k?e?l?e?m?r?5?h?g?5?o?s?q?r@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine

; 294  : 
; 295  :         list->Status |= LIST_ERR_REMOVE_EMPTY;

	mov	eax, DWORD PTR [esi+28]
	add	esp, 28					; 0000001cH
	or	eax, 16					; 00000010H
	mov	DWORD PTR [esi+28], eax
	pop	esi

; 346  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@ListRemove:

; 296  : 
; 297  :         return list->Status;
; 298  :     }
; 299  : 
; 300  :     if (CHECK_FREE_ELEM(list, dataIndex))

	mov	ecx, edx
	push	ebx
	mov	ebx, DWORD PTR [esi+8]
	shl	ecx, 5
	cmp	edx, ebx
	je	SHORT $LN8@ListRemove
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+ecx+4], 0
	jne	SHORT $LN8@ListRemove

; 301  :     {
; 302  :         LOG_F_LIST_ERR("Попытка удалить пустой элемент. dataIndex = %zd.", dataIndex);

	push	edx
	push	OFFSET ??_C@_0DB@GHEAINCG@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?o?s?q?r?n?i?5?$PN?k?e?l?e?m?r?4@
	push	302					; 0000012eH
	push	OFFSET ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0DN@LJHLEGEB@int?5__cdecl?5ListRemoveElem?$CIstru@
	push	1
	push	2
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 303  : 
; 304  :         list->Status |= LIST_ERR_REMOVE_FREE;

	mov	eax, DWORD PTR [esi+28]
	add	esp, 32					; 00000020H
	or	eax, 32					; 00000020H
	mov	DWORD PTR [esi+28], eax
	pop	ebx
	pop	esi

; 346  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@ListRemove:

; 305  : 
; 306  :         return list->Status;
; 307  :     }
; 308  : 
; 309  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 310  : 
; 311  :     ListNode* nodes = list->Nodes;

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	DWORD PTR _nodes$1$[ebp], eax

; 312  : 
; 313  :     size_t nextIndex = nodes[dataIndex].Next;

	lea	edi, DWORD PTR [ecx+eax]

; 314  :     size_t prevIndex = nodes[dataIndex].Prev;

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR _prevIndex$1$[ebp], eax

; 315  : 
; 316  :     // Удаление элемента из середины сбивает сортировку.
; 317  :     if (dataIndex != list->Tail && dataIndex != list->Head)

	cmp	edx, DWORD PTR [esi+12]
	je	SHORT $LN4@ListRemove
	cmp	edx, ebx
	je	SHORT $LN4@ListRemove

; 318  :         list->Sorted = false;

	mov	BYTE PTR [esi+24], 0
$LN4@ListRemove:

; 319  : 
; 320  :     // Удалить элемент списка.
; 321  :     memset(nodes + dataIndex, 0, sizeof(ListNode));
; 322  : 
; 323  :     // Изменяем связи элементов списка
; 324  :     nodes[nextIndex].Prev = prevIndex;

	mov	edx, DWORD PTR _nodes$1$[ebp]
	mov	eax, ecx
	mov	ebx, DWORD PTR _prevIndex$1$[ebp]
	xorps	xmm0, xmm0
	shl	eax, 5
	movups	XMMWORD PTR [edi], xmm0
	movups	XMMWORD PTR [edi+16], xmm0
	mov	DWORD PTR [eax+edx+4], ebx

; 325  :     nodes[prevIndex].Next = nextIndex;

	mov	eax, ebx
	shl	eax, 5
	mov	DWORD PTR [eax+edx], ecx

; 326  : 
; 327  :     // Изменяем голову и хвост списка.
; 328  :     if (list->Tail == dataIndex)

	mov	edx, DWORD PTR _dataIndex$[ebp]
	cmp	DWORD PTR [esi+12], edx
	jne	SHORT $LN5@ListRemove

; 329  :         list->Tail = prevIndex;

	mov	DWORD PTR [esi+12], ebx
$LN5@ListRemove:

; 330  : 
; 331  :     if (list->Head == dataIndex)

	cmp	DWORD PTR [esi+8], edx
	jne	SHORT $LN6@ListRemove

; 332  :         list->Head = nextIndex;

	mov	DWORD PTR [esi+8], ecx
$LN6@ListRemove:

; 333  : 
; 334  :     // Помечаем освободившийся элемент пустым.
; 335  :     nodes[dataIndex].Next = list->Free;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], ecx

; 336  :     nodes[dataIndex].Prev = 0;

	mov	DWORD PTR [edi+4], 0

; 337  : 
; 338  :     list->Free = dataIndex;
; 339  : 
; 340  :     // Уменьшаем размер списка.
; 341  :     list->Size--;

	dec	DWORD PTR [esi+16]

; 342  : 
; 343  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 344  :     
; 345  :     return list->Status;

	mov	eax, DWORD PTR [esi+28]
	pop	edi
	pop	ebx
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 346  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ListRemoveElem@@YAHPAUList@@I@Z ENDP			; ListRemoveElem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListAddElemBefore@@YAHPAUList@@PBT__m128i@@I@Z
_TEXT	SEGMENT
_nodes$1$ = 8						; size = 4
_list$ = 8						; size = 4
_value$ = 12						; size = 4
_dataIndex$ = 16					; size = 4
?ListAddElemBefore@@YAHPAUList@@PBT__m128i@@I@Z PROC	; ListAddElemBefore, COMDAT

; 202  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR _dataIndex$[ebp]
	push	esi

; 203  :     LOG_LIST_TRACE_FUNC_0;
; 204  : 
; 205  :     assert(list);
; 206  :     assert(value);
; 207  : 
; 208  :     LIST_ASSERT_STATUS;
; 209  : 
; 210  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 211  : 
; 212  :     if (list->Size > list->Capacity)

	mov	esi, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+20]
	cmp	ecx, edx
	jbe	SHORT $LN2@ListAddEle

; 213  :     {
; 214  :         LOG_F_LIST_ERR("Размер списка = %zd больше вместимости = %zd", list->Size, list->Capacity);

	push	edx
	push	ecx
	push	OFFSET ??_C@_0CN@DEHHELMC@?P?$OA?g?l?e?p?5?q?o?h?q?j?$OA?5?$DN?5?$CFzd?5?a?n?k?$PM?x?e?5?b?l?e?q@
	push	214					; 000000d6H
	push	OFFSET ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0FG@FFEJPFPM@int?5__cdecl?5ListAddElemBefore?$CIs@
	push	1
	push	2
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 215  : 
; 216  :         list->Status |= LIST_ERR_SIZE;

	mov	eax, DWORD PTR [esi+28]
	add	esp, 36					; 00000024H
	or	eax, 2
	mov	DWORD PTR [esi+28], eax
	pop	esi

; 279  : }

	pop	ebx
	pop	ebp
	ret	0
$LN2@ListAddEle:
	push	edi

; 217  : 
; 218  :         return list->Status;
; 219  :     }
; 220  : 
; 221  :     if (CHECK_FREE_ELEM(list, dataIndex))

	mov	edi, ebx
	shl	edi, 5
	cmp	ebx, DWORD PTR [esi+8]
	je	SHORT $LN8@ListAddEle
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+edi+4], 0
	jne	SHORT $LN8@ListAddEle

; 222  :     {
; 223  :         LOG_F_LIST_ERR("Попытка добавить элемент перед пустым. dataIndex = %zd.", dataIndex);

	push	ebx
	push	OFFSET ??_C@_0DI@GIIDHNGH@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?e?p?e?d?5@
	push	223					; 000000dfH
	push	OFFSET ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0FG@FFEJPFPM@int?5__cdecl?5ListAddElemBefore?$CIs@
	push	1
	push	2
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 224  : 
; 225  :         list->Status |= LIST_ERR_ADD_FREE;

	mov	eax, DWORD PTR [esi+28]
	add	esp, 32					; 00000020H
	or	eax, 8
	mov	DWORD PTR [esi+28], eax
	pop	edi
	pop	esi

; 279  : }

	pop	ebx
	pop	ebp
	ret	0
$LN8@ListAddEle:

; 226  : 
; 227  :         return list->Status;
; 228  :     }
; 229  : 
; 230  :     // Список полон, выделяем место.
; 231  :     if (CHECK_LIST_FULL(list))

	cmp	ecx, edx
	jne	SHORT $LN11@ListAddEle

; 232  :     {
; 233  :         if (ListResize(list) != LIST_ERR_NO_ERRORS)

	push	esi
	call	?ListResize@@YAHPAUList@@@Z		; ListResize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@ListAddEle
$LN11@ListAddEle:

; 234  :             return list->Status;
; 235  :     }
; 236  : 
; 237  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 238  : 
; 239  :     ListNode* nodes = list->Nodes;

	mov	ecx, DWORD PTR [esi]

; 240  : 
; 241  :     // Найти пустое место в списке.
; 242  :     const size_t insertElemIndex = FIND_EMPTY_PLACE(list);

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _nodes$1$[ebp], ecx

; 243  : 
; 244  :     // В общем случае любая вставка в начало списка сбивает сортировку
; 245  :     list->Sorted = false; 

	mov	BYTE PTR [esi+24], 0

; 246  : 
; 247  :     // Если вставляем элемент перед головой списка, то он становиться новой головой.
; 248  :     if (list->Head == dataIndex)

	cmp	DWORD PTR [esi+8], ebx
	jne	SHORT $LN6@ListAddEle

; 249  :         list->Head = insertElemIndex;

	mov	DWORD PTR [esi+8], edx
$LN6@ListAddEle:

; 250  : 
; 251  :     // Копируем содержимое вставляемого элемента.
; 252  :     memcpy(&nodes[insertElemIndex].Data, value, sizeof(ListType));

	mov	eax, edx
	shl	eax, 5
	add	ecx, eax
	mov	eax, DWORD PTR _value$[ebp]
	movups	xmm0, XMMWORD PTR [eax]

; 253  : 
; 254  :     // Поле Next пустых элементов является односвязным списком пустых мест.
; 255  :     list->Free = nodes[insertElemIndex].Next;

	mov	eax, DWORD PTR [ecx]
	movups	XMMWORD PTR [ecx+16], xmm0
	mov	DWORD PTR [esi+4], eax

; 256  : 
; 257  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 258  :     // Изменяем поле Prev:
; 259  : 
; 260  :     // Поле Prev вставляемого элемента.
; 261  :     nodes[insertElemIndex].Prev = nodes[dataIndex].Prev;

	mov	eax, DWORD PTR _nodes$1$[ebp]
	mov	eax, DWORD PTR [edi+eax+4]
	mov	DWORD PTR [ecx+4], eax

; 262  :     // Поле Prev следующего за вставляемым элементом.
; 263  :     nodes[dataIndex].Prev = insertElemIndex;

	mov	eax, DWORD PTR _nodes$1$[ebp]
	mov	DWORD PTR [edi+eax+4], edx

; 264  : 
; 265  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 266  :     // Изменяем поле Next в списке:
; 267  : 
; 268  :     // Поле Next предшествующего элемента.
; 269  :     nodes[nodes[insertElemIndex].Prev].Next = insertElemIndex;

	mov	eax, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR _nodes$1$[ebp]
	shl	eax, 5
	mov	DWORD PTR [eax+edi], edx

; 270  :     // Поле Next вставляемого элемента.
; 271  :     nodes[insertElemIndex].Next = dataIndex;

	mov	DWORD PTR [ecx], ebx

; 272  : 
; 273  :     // Размер списка увеличился.
; 274  :     list->Size++;

	inc	DWORD PTR [esi+16]
$LN13@ListAddEle:

; 275  : 
; 276  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 277  : 
; 278  :     return list->Status;

	mov	eax, DWORD PTR [esi+28]
	pop	edi
	pop	esi

; 279  : }

	pop	ebx
	pop	ebp
	ret	0
?ListAddElemBefore@@YAHPAUList@@PBT__m128i@@I@Z ENDP	; ListAddElemBefore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListAddElemAfter@@YAHPAUList@@PBT__m128i@@I@Z
_TEXT	SEGMENT
_nodes$1$ = 8						; size = 4
_list$ = 8						; size = 4
_value$ = 12						; size = 4
_dataIndex$ = 16					; size = 4
?ListAddElemAfter@@YAHPAUList@@PBT__m128i@@I@Z PROC	; ListAddElemAfter, COMDAT

; 118  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 119  :     LOG_LIST_TRACE_FUNC_0;
; 120  : 
; 121  :     assert(list);
; 122  :     assert(value);
; 123  : 
; 124  :     LIST_ASSERT_STATUS;
; 125  : 
; 126  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 127  : 
; 128  :     if (list->Size > list->Capacity)

	mov	esi, DWORD PTR _list$[ebp]
	push	edi
	mov	edi, DWORD PTR _dataIndex$[ebp]
	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+20]
	cmp	ecx, edx
	jbe	SHORT $LN2@ListAddEle

; 129  :     {
; 130  :         LOG_F_LIST_ERR("Размер списка = %zd больше вместимости = %zd", list->Size, list->Capacity);

	push	edx
	push	ecx
	push	OFFSET ??_C@_0CN@DEHHELMC@?P?$OA?g?l?e?p?5?q?o?h?q?j?$OA?5?$DN?5?$CFzd?5?a?n?k?$PM?x?e?5?b?l?e?q@
	push	130					; 00000082H
	push	OFFSET ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0FF@OFEGCKDJ@int?5__cdecl?5ListAddElemAfter?$CIst@
	push	1
	push	2
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 131  : 
; 132  :         list->Status |= LIST_ERR_SIZE;

	mov	eax, DWORD PTR [esi+28]
	add	esp, 36					; 00000024H
	or	eax, 2
	mov	DWORD PTR [esi+28], eax
	pop	edi

; 199  : }

	pop	esi
	pop	ebp
	ret	0
$LN2@ListAddEle:
	push	ebx

; 133  : 
; 134  :         return list->Status;
; 135  :     }
; 136  : 
; 137  :     if (CHECK_FREE_ELEM(list, dataIndex))

	mov	ebx, edi
	shl	ebx, 5
	cmp	edi, DWORD PTR [esi+8]
	je	SHORT $LN10@ListAddEle
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+ebx+4], 0
	jne	SHORT $LN10@ListAddEle

; 138  :     {
; 139  :         LOG_F_LIST_ERR("Попытка добавить элемент после пустого. dataIndex = %zd.", dataIndex);

	push	edi
	push	OFFSET ??_C@_0DJ@LCGIIKOJ@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?n?q?k?e?5@
	push	139					; 0000008bH
	push	OFFSET ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0FF@OFEGCKDJ@int?5__cdecl?5ListAddElemAfter?$CIst@
	push	1
	push	2
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 140  : 
; 141  :         list->Status |= LIST_ERR_ADD_FREE;

	mov	eax, DWORD PTR [esi+28]
	add	esp, 32					; 00000020H
	or	eax, 8
	mov	DWORD PTR [esi+28], eax
	pop	ebx
	pop	edi

; 199  : }

	pop	esi
	pop	ebp
	ret	0
$LN10@ListAddEle:

; 142  : 
; 143  :         return list->Status;
; 144  :     }
; 145  : 
; 146  :     // Список полон, выделяем место.
; 147  :     if (CHECK_LIST_FULL(list))

	cmp	ecx, edx
	jne	SHORT $LN13@ListAddEle

; 148  :     {
; 149  :         if (ListResize(list) != LIST_ERR_NO_ERRORS)

	push	esi
	call	?ListResize@@YAHPAUList@@@Z		; ListResize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@ListAddEle
$LN13@ListAddEle:

; 150  :             return list->Status;
; 151  :     }
; 152  : 
; 153  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 154  : 
; 155  :     ListNode* nodes = list->Nodes;

	mov	ecx, DWORD PTR [esi]

; 156  : 
; 157  :     // Найти пустое место в списке.
; 158  :     const size_t insertElemIndex = FIND_EMPTY_PLACE(list);

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _nodes$1$[ebp], ecx

; 159  : 
; 160  :     // Если вставляем элемент не в конец списка, то сбивается сортировка.
; 161  :     // Иначе он становится хвостом списка.
; 162  :     if (list->Tail != dataIndex) 

	cmp	DWORD PTR [esi+12], edi
	je	SHORT $LN6@ListAddEle

; 163  :         list->Sorted = false;

	mov	BYTE PTR [esi+24], 0
	jmp	SHORT $LN7@ListAddEle
$LN6@ListAddEle:

; 164  :     else
; 165  :         list->Tail = insertElemIndex;

	mov	DWORD PTR [esi+12], edx
$LN7@ListAddEle:

; 166  : 
; 167  :     // Если вставляем элемент перед головой списка.
; 168  :     if (dataIndex == 0)

	test	edi, edi
	jne	SHORT $LN8@ListAddEle

; 169  :         list->Head = insertElemIndex;

	mov	DWORD PTR [esi+8], edx
$LN8@ListAddEle:

; 170  : 
; 171  :     // Копируем содержимое вставляемого элемента.
; 172  :     memcpy(&nodes[insertElemIndex].Data, value, sizeof(ListType)); 

	mov	eax, edx
	shl	eax, 5
	add	ecx, eax
	mov	eax, DWORD PTR _value$[ebp]
	movups	xmm0, XMMWORD PTR [eax]

; 173  :     
; 174  :     // Поле Next пустых элементов является односвязным списком пустых мест.
; 175  :     list->Free = nodes[insertElemIndex].Next;

	mov	eax, DWORD PTR [ecx]
	movups	XMMWORD PTR [ecx+16], xmm0
	mov	DWORD PTR [esi+4], eax

; 176  : 
; 177  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 178  :     // Изменяем поле Next в списке:
; 179  : 
; 180  :     // Поле Next вставляемого элемента.
; 181  :     nodes[insertElemIndex].Next = nodes[dataIndex].Next;

	mov	eax, DWORD PTR _nodes$1$[ebp]
	mov	eax, DWORD PTR [ebx+eax]
	mov	DWORD PTR [ecx], eax

; 182  :     // Поле Next предшествующего элемента.
; 183  :     nodes[dataIndex].Next = insertElemIndex;

	mov	eax, DWORD PTR _nodes$1$[ebp]
	mov	DWORD PTR [ebx+eax], edx

; 184  : 
; 185  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 186  :     // Изменяем поле Prev:
; 187  : 
; 188  :     // Поле Prev вставляемого элемента.
; 189  :     nodes[insertElemIndex].Prev = dataIndex;
; 190  :     // Поле Prev следующего за вставляемым элементом.
; 191  :     nodes[nodes[insertElemIndex].Next].Prev = insertElemIndex;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edi
	mov	ecx, DWORD PTR _nodes$1$[ebp]
	shl	eax, 5
	mov	DWORD PTR [eax+ecx+4], edx

; 192  : 
; 193  :     // Размер списка увеличился.
; 194  :     list->Size++;

	inc	DWORD PTR [esi+16]
$LN15@ListAddEle:

; 195  : 
; 196  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 197  : 
; 198  :     return list->Status;

	mov	eax, DWORD PTR [esi+28]
	pop	ebx
	pop	edi

; 199  : }

	pop	esi
	pop	ebp
	ret	0
?ListAddElemAfter@@YAHPAUList@@PBT__m128i@@I@Z ENDP	; ListAddElemAfter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ClearList@@YAXPAUList@@@Z
_TEXT	SEGMENT
_list$ = 8						; size = 4
?ClearList@@YAXPAUList@@@Z PROC				; ClearList, COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp

; 82   :     LOG_LIST_TRACE_CTOR;
; 83   : 
; 84   :     assert(list);
; 85   : 
; 86   :     LIST_ASSERT_STATUS;
; 87   : 
; 88   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 89   : 
; 90   :     const size_t capacity = list->Capacity;

	mov	eax, DWORD PTR _list$[ebp]
	push	esi
	push	edi
	mov	esi, DWORD PTR [eax+20]

; 91   : 
; 92   :     list->Sorted = true;
; 93   : 
; 94   :     list->Head = 0;
; 95   :     list->Tail = 0;
; 96   :     list->Size = 0;
; 97   :     list->Free = 1;
; 98   : 
; 99   :     ListNode* nodes = list->Nodes;

	mov	edi, DWORD PTR [eax]
	mov	BYTE PTR [eax+24], 1
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+4], 1

; 100  : 
; 101  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 102  : 
; 103  :     // Обнуляем массивы
; 104  :     memset(nodes, 0, (capacity + 1) * sizeof(ListType));

	lea	eax, DWORD PTR [esi+1]
	shl	eax, 4
	push	eax
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
	mov	ecx, edi
	xor	eax, eax
$LL4@ClearList:

; 105  : 
; 106  :     // Создаём список пустых элементов.
; 107  :     for (int st = 0; st <= capacity; st++)
; 108  :         nodes[st].Next = st + 1;

	inc	eax
	lea	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx-32], eax
	cmp	eax, esi
	jbe	SHORT $LL4@ClearList

; 109  : 
; 110  :     // Закольцовываем массив.
; 111  :     nodes[capacity].Next = 0;

	shl	esi, 5
	mov	DWORD PTR [esi+edi], 0
	pop	edi
	pop	esi

; 112  : }

	pop	ebp
	ret	0
?ClearList@@YAXPAUList@@@Z ENDP				; ClearList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListDestructor@@YAXPAUList@@@Z
_TEXT	SEGMENT
_list$ = 8						; size = 4
?ListDestructor@@YAXPAUList@@@Z PROC			; ListDestructor, COMDAT

; 66   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 67   :     LOG_LIST_TRACE_CTOR;
; 68   : 
; 69   :     assert(list);
; 70   : 
; 71   :     LIST_ASSERT_STATUS;
; 72   : 
; 73   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 74   : 
; 75   :     free(list->Nodes);

	mov	esi, DWORD PTR _list$[ebp]
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__free
	add	esp, 4
	xorps	xmm0, xmm0

; 76   : 
; 77   :     memset(list, 0, sizeof(List));

	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0
	pop	esi

; 78   : }

	pop	ebp
	ret	0
?ListDestructor@@YAXPAUList@@@Z ENDP			; ListDestructor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListConstructor@@YAHPAUList@@I@Z
_TEXT	SEGMENT
_list$ = 8						; size = 4
_capacity$ = 12						; size = 4
?ListConstructor@@YAHPAUList@@I@Z PROC			; ListConstructor, COMDAT

; 20   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 21   :     LOG_LIST_TRACE_CTOR;
; 22   : 
; 23   :     assert(list);
; 24   : 
; 25   :     LIST_ASSERT_STATUS;
; 26   : 
; 27   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 28   : 
; 29   :     list->Capacity = capacity;

	mov	esi, DWORD PTR _capacity$[ebp]

; 30   :     list->Sorted   = true;
; 31   :     list->Status   = LIST_ERR_NO_ERRORS;
; 32   : 
; 33   :     list->Head = 0;
; 34   :     list->Tail = 0;
; 35   :     list->Size = 0;
; 36   :     list->Free = 1;
; 37   : 
; 38   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 39   : 
; 40   :     list->Nodes = (ListNode*)calloc(capacity + 1, sizeof(ListNode));

	xor	ecx, ecx
	mov	eax, esi
	add	eax, 1
	push	edi
	mov	edi, DWORD PTR _list$[ebp]
	setb	cl
	neg	ecx
	or	ecx, eax
	push	32					; 00000020H
	push	ecx
	mov	DWORD PTR [edi+20], esi
	mov	BYTE PTR [edi+24], 1
	mov	DWORD PTR [edi+28], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+4], 1
	call	DWORD PTR __imp__calloc
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR [edi], edx

; 41   : 
; 42   :     if (!list->Nodes)

	test	edx, edx
	jne	SHORT $LN5@ListConstr

; 43   :     {
; 44   :         LOG_LIST_ERR_MEMORY;

	push	44					; 0000002cH
	push	OFFSET ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0DO@JDKHDNEG@int?5__cdecl?5ListConstructor?$CIstr@
	push	1
	push	2
	push	4
	push	OFFSET ??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine

; 45   : 
; 46   :         list->Status |= LIST_ERR_MEMORY;

	mov	eax, DWORD PTR [edi+28]
	add	esp, 28					; 0000001cH
	or	eax, 1
	mov	DWORD PTR [edi+28], eax
	pop	edi

; 63   : }

	pop	esi
	pop	ebp
	ret	0
$LN5@ListConstr:

; 47   : 
; 48   :         return list->Status;
; 49   :     }
; 50   : 
; 51   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 52   : 
; 53   :     ListNode* nodes = list->Nodes;

	mov	eax, 1

; 54   : 
; 55   :     for (size_t st = 1; st < capacity; st++)

	cmp	esi, eax
	jbe	SHORT $LN3@ListConstr

; 47   : 
; 48   :         return list->Status;
; 49   :     }
; 50   : 
; 51   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 52   : 
; 53   :     ListNode* nodes = list->Nodes;

	lea	ecx, DWORD PTR [edx+32]
	npad	1
$LL4@ListConstr:

; 56   :         nodes[st].Next = st + 1;

	inc	eax
	lea	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx-32], eax
	cmp	eax, esi
	jb	SHORT $LL4@ListConstr
$LN3@ListConstr:

; 57   : 
; 58   :     nodes[capacity].Next = 0;

	shl	esi, 5
	mov	DWORD PTR [esi+edx], 0

; 59   : 
; 60   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 61   : 
; 62   :     return list->Status;

	mov	eax, DWORD PTR [edi+28]
	pop	edi

; 63   : }

	pop	esi
	pop	ebp
	ret	0
?ListConstructor@@YAHPAUList@@I@Z ENDP			; ListConstructor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List_Config.h
;	COMDAT ?ListComparator@@YA_NT__m128i@@0@Z
_TEXT	SEGMENT
_val2$ = -48						; size = 16
_val1$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
?ListComparator@@YA_NT__m128i@@0@Z PROC			; ListComparator, COMDAT
; _val1$ = xmm0
; _val2$ = xmm1

; 48   : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	movaps	XMMWORD PTR _val2$[ebp], xmm1

; 49   : 	return memcmp(&val1, &val2, sizeof(ListType)) == 0;

	lea	edx, DWORD PTR _val1$[ebp]
	movaps	XMMWORD PTR _val1$[ebp], xmm0
	lea	eax, DWORD PTR _val2$[ebp]
	mov	esi, 12					; 0000000cH
$LL5@ListCompar:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN4@ListCompar
	add	edx, 4
	add	eax, 4
	sub	esi, 4
	jae	SHORT $LL5@ListCompar
	mov	al, 1

; 50   : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
$LN4@ListCompar:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	al, al
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?ListComparator@@YA_NT__m128i@@0@Z ENDP			; ListComparator
_TEXT	ENDS
END
