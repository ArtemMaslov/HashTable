; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31105.0 

	TITLE	D:\Language C\HashTable\HashTable\Release\HashTable.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?HashTableConstructor@@YAHPAUHashTable@@IIP6AIPBT__m128i@@@Z@Z ; HashTableConstructor
PUBLIC	?HashTableDestructor@@YAHPAUHashTable@@@Z	; HashTableDestructor
PUBLIC	?HashTableInsert@@YAHPAUHashTable@@PBT__m128i@@@Z ; HashTableInsert
PUBLIC	?HashTableFind@@YAPAT__m128i@@PBUHashTable@@PBT1@@Z ; HashTableFind
PUBLIC	?HashTableRemove@@YAHPAUHashTable@@PBT__m128i@@@Z ; HashTableRemove
PUBLIC	??_C@_0DK@PMCBLCOD@D?3?2Language?5C?2HashTable?2HashTab@ ; `string'
PUBLIC	??_C@_0IL@LDKNIHDM@int?5__cdecl?5HashTableConstructo@ ; `string'
PUBLIC	??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@ ; `string'
PUBLIC	??_C@_0EF@JDHLNIEH@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?l?$OA?q?q?h?b?$OA?5?q?o?h?q?j?n?b@ ; `string'
PUBLIC	??_C@_0EI@EKLNNALM@?N?x?h?a?j?$OA?5?d?n?a?$OA?b?k?e?m?h?$PP?5?$PN?k?e?l?e?m?r?$OA?5?b?5?q?o@ ; `string'
PUBLIC	??_C@_0EG@OFHKIGCK@int?5__cdecl?5HashTableInsert?$CIstr@ ; `string'
PUBLIC	??_C@_0EH@IOMJPDDC@?N?x?h?a?j?$OA?5?s?d?$OA?k?e?m?h?$PP?5?$PN?k?e?l?e?m?r?$OA?5?h?g?5?q?o?h@ ; `string'
PUBLIC	??_C@_0EG@CHDBCOBG@int?5__cdecl?5HashTableRemove?$CIstr@ ; `string'
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	?ListConstructor@@YAHPAUList@@I@Z:PROC		; ListConstructor
EXTRN	?ListDestructor@@YAXPAUList@@@Z:PROC		; ListDestructor
EXTRN	?ListAddElemAfter@@YAHPAUList@@PBT__m128i@@I@Z:PROC ; ListAddElemAfter
EXTRN	?ListRemoveElem@@YAHPAUList@@I@Z:PROC		; ListRemoveElem
EXTRN	?ListFind@@YAIPBUList@@PBT__m128i@@@Z:PROC	; ListFind
EXTRN	?HashTableVerifyInit@@YAHPBUHashTable@@@Z:PROC	; HashTableVerifyInit
EXTRN	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z:PROC ; LogLine
EXTRN	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ:PROC ; LogFLine
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0EG@CHDBCOBG@int?5__cdecl?5HashTableRemove?$CIstr@
CONST	SEGMENT
??_C@_0EG@CHDBCOBG@int?5__cdecl?5HashTableRemove?$CIstr@ DB 'int __cdecl '
	DB	'HashTableRemove(struct HashTable *,const union __m128i *)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@IOMJPDDC@?N?x?h?a?j?$OA?5?s?d?$OA?k?e?m?h?$PP?5?$PN?k?e?l?e?m?r?$OA?5?h?g?5?q?o?h@
CONST	SEGMENT
??_C@_0EH@IOMJPDDC@?N?x?h?a?j?$OA?5?s?d?$OA?k?e?m?h?$PP?5?$PN?k?e?l?e?m?r?$OA?5?h?g?5?q?o?h@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0f3H, 0e4H, 0e0H, 0ebH, 0e5H
	DB	0edH, 0e8H, 0ffH, ' ', 0fdH, 0ebH, 0e5H, 0ecH, 0e5H, 0edH, 0f2H
	DB	0e0H, ' ', 0e8H, 0e7H, ' ', 0f1H, 0efH, 0e8H, 0f1H, 0eaH, 0e0H
	DB	'. listIndex = %zd. wordData = "%16s"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@OFHKIGCK@int?5__cdecl?5HashTableInsert?$CIstr@
CONST	SEGMENT
??_C@_0EG@OFHKIGCK@int?5__cdecl?5HashTableInsert?$CIstr@ DB 'int __cdecl '
	DB	'HashTableInsert(struct HashTable *,const union __m128i *)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@EKLNNALM@?N?x?h?a?j?$OA?5?d?n?a?$OA?b?k?e?m?h?$PP?5?$PN?k?e?l?e?m?r?$OA?5?b?5?q?o@
CONST	SEGMENT
??_C@_0EI@EKLNNALM@?N?x?h?a?j?$OA?5?d?n?a?$OA?b?k?e?m?h?$PP?5?$PN?k?e?l?e?m?r?$OA?5?b?5?q?o@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0e4H, 0eeH, 0e1H, 0e0H, 0e2H
	DB	0ebH, 0e5H, 0edH, 0e8H, 0ffH, ' ', 0fdH, 0ebH, 0e5H, 0ecH, 0e5H
	DB	0edH, 0f2H, 0e0H, ' ', 0e2H, ' ', 0f1H, 0efH, 0e8H, 0f1H, 0eeH
	DB	0eaH, '. listIndex = %zd. wordData = "%16s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@JDHLNIEH@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?l?$OA?q?q?h?b?$OA?5?q?o?h?q?j?n?b@
CONST	SEGMENT
??_C@_0EF@JDHLNIEH@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?l?$OA?q?q?h?b?$OA?5?q?o?h?q?j?n?b@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0f1H, 0eeH, 0e7H, 0e4H, 0e0H
	DB	0edH, 0e8H, 0ffH, ' ', 0ecH, 0e0H, 0f1H, 0f1H, 0e8H, 0e2H, 0e0H
	DB	' ', 0f1H, 0efH, 0e8H, 0f1H, 0eaH, 0eeH, 0e2H, ' ', 0e2H, ' ', 0eaH
	DB	0eeH, 0edH, 0f1H, 0f2H, 0f0H, 0f3H, 0eaH, 0f2H, 0eeH, 0f0H, 0e5H
	DB	'. ', 0d1H, 0eeH, 0e7H, 0e4H, 0e0H, 0edH, 0eeH, ' ', 0f1H, 0efH
	DB	0e8H, 0f1H, 0eaH, 0eeH, 0e2H, ' %zd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
CONST	SEGMENT
??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0e2H, 0fbH, 0e4H, 0e5H, 0ebH
	DB	0e5H, 0edH, 0e8H, 0ffH, ' ', 0efH, 0e0H, 0ecH, 0ffH, 0f2H, 0e8H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0IL@LDKNIHDM@int?5__cdecl?5HashTableConstructo@
CONST	SEGMENT
??_C@_0IL@LDKNIHDM@int?5__cdecl?5HashTableConstructo@ DB 'int __cdecl Has'
	DB	'hTableConstructor(struct HashTable *,const unsigned int,const'
	DB	' unsigned int,unsigned int (__cdecl *)(const union __m128i *)'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@PMCBLCOD@D?3?2Language?5C?2HashTable?2HashTab@
CONST	SEGMENT
??_C@_0DK@PMCBLCOD@D?3?2Language?5C?2HashTable?2HashTab@ DB 'D:\Language '
	DB	'C\HashTable\HashTable\HashTable\HashTable.cpp', 00H ; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\HashTable\HashTable.cpp
;	COMDAT ?HashTableRemove@@YAHPAUHashTable@@PBT__m128i@@@Z
_TEXT	SEGMENT
_table$GSCopy$ = -16					; size = 4
_listIndex$ = -12					; size = 4
_element$GSCopy$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_table$ = 8						; size = 4
_element$ = 12						; size = 4
?HashTableRemove@@YAHPAUHashTable@@PBT__m128i@@@Z PROC	; HashTableRemove, COMDAT

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _table$[ebp]
	push	edi
	mov	edi, DWORD PTR _element$[ebp]
	mov	DWORD PTR _table$GSCopy$[ebp], esi
	mov	DWORD PTR _element$GSCopy$[ebp], edi

; 148  : 	LOG_HASH_TABLE_TRACE_FUNC_0;
; 149  : 
; 150  : 	assert(table);
; 151  : 	assert(element);
; 152  : 
; 153  : 	HASH_TABLE_ASSERT_STATUS;
; 154  : 
; 155  : 	size_t listIndex = 0;

	mov	DWORD PTR _listIndex$[ebp], 0

; 156  : 
; 157  : 	__asm
; 158  : 	{
; 159  : 		mov	ecx, dword ptr element[0]

	mov	ecx, DWORD PTR _element$GSCopy$[ebp]

; 160  : 
; 161  : 		xor eax, eax

	xor	eax, eax

; 162  : 		crc32 eax, dword ptr[ecx]

	crc32	eax, DWORD PTR [ecx]

; 163  : 
; 164  : 		crc32 eax, dword ptr[ecx + 4]

	crc32	eax, DWORD PTR [ecx+4]

; 165  : 
; 166  : 		crc32 eax, dword ptr[ecx + 8]

	crc32	eax, DWORD PTR [ecx+8]

; 167  : 
; 168  : 		crc32 eax, dword ptr[ecx + 12]

	crc32	eax, DWORD PTR [ecx+12]

; 169  : 
; 170  : 		mov ebx, table

	mov	ebx, DWORD PTR _table$GSCopy$[ebp]

; 171  : 		mov ebx, dword ptr[ebx + 4]; table->ListCount

	mov	ebx, DWORD PTR [ebx+4]

; 172  : 
; 173  : 		xor edx, edx

	xor	edx, edx

; 174  : 		div ebx

	div	ebx

; 175  : 
; 176  : 		mov listIndex, edx

	mov	DWORD PTR _listIndex$[ebp], edx

; 177  : 	}
; 178  : 
; 179  : 	size_t elemIndex = ListFind(table->Lists + listIndex, element);

	mov	eax, DWORD PTR _listIndex$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [esi+8]
	push	edi
	push	eax
	call	?ListFind@@YAIPBUList@@PBT__m128i@@@Z	; ListFind
	add	esp, 8

; 180  : 
; 181  : 	if (elemIndex == 0)

	test	eax, eax
	jne	SHORT $LN2@HashTableR

; 182  : 	{
; 183  : 		table->Warnings = HASH_TABLE_WRN_REMOVE_VOID;

	pop	edi
	mov	DWORD PTR [esi+20], 2

; 184  : 		return table->Warnings;

	mov	eax, 2

; 200  : }

	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@HashTableR:

; 185  : 	}
; 186  : 
; 187  : 	if (ListRemoveElem(table->Lists + listIndex, elemIndex) != LIST_ERR_NO_ERRORS)

	push	eax
	mov	eax, DWORD PTR _listIndex$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [esi+8]
	push	eax
	call	?ListRemoveElem@@YAHPAUList@@I@Z	; ListRemoveElem
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@HashTableR

; 188  : 	{
; 189  : 		LOG_F_HASH_TABLE_ERR("Ошибка удаления элемента из списка. "

	push	edi
	push	DWORD PTR _listIndex$[ebp]
	push	OFFSET ??_C@_0EH@IOMJPDDC@?N?x?h?a?j?$OA?5?s?d?$OA?k?e?m?h?$PP?5?$PN?k?e?l?e?m?r?$OA?5?h?g?5?q?o?h@
	push	191					; 000000bfH
	push	OFFSET ??_C@_0DK@PMCBLCOD@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0EG@CHDBCOBG@int?5__cdecl?5HashTableRemove?$CIstr@
	push	1
	push	1
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 190  : 							 "listIndex = %zd. "
; 191  : 							 "wordData = \"%16s\"", listIndex, (char*)element);
; 192  : 
; 193  : 		table->ExtStatus = table->Lists[listIndex].Status;

	mov	ecx, DWORD PTR _listIndex$[ebp]
	add	esp, 36					; 00000024H
	mov	eax, DWORD PTR [esi+8]
	shl	ecx, 5
	pop	edi
	mov	eax, DWORD PTR [ecx+eax+28]
	mov	DWORD PTR [esi+16], eax

; 194  : 		table->Status = HASH_TABLE_ERR_LIST;
; 195  : 
; 196  : 		return table->Status;

	mov	eax, 1048576				; 00100000H
	mov	DWORD PTR [esi+12], 1048576		; 00100000H

; 200  : }

	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@HashTableR:

; 197  : 	}
; 198  : 
; 199  : 	return table->Status;

	mov	eax, DWORD PTR [esi+12]

; 200  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?HashTableRemove@@YAHPAUHashTable@@PBT__m128i@@@Z ENDP	; HashTableRemove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\HashTable\HashTable.cpp
;	COMDAT ?HashTableFind@@YAPAT__m128i@@PBUHashTable@@PBT1@@Z
_TEXT	SEGMENT
_table$GSCopy$ = -16					; size = 4
_listIndex$ = -12					; size = 4
_element$GSCopy$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_table$ = 8						; size = 4
_element$ = 12						; size = 4
?HashTableFind@@YAPAT__m128i@@PBUHashTable@@PBT1@@Z PROC ; HashTableFind, COMDAT

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _element$[ebp]
	push	edi
	mov	edi, DWORD PTR _table$[ebp]
	mov	DWORD PTR _table$GSCopy$[ebp], edi
	mov	DWORD PTR _element$GSCopy$[ebp], esi

; 204  : 	LOG_HASH_TABLE_TRACE_FUNC_0;
; 205  : 
; 206  : 	assert(table);
; 207  : 	assert(element);
; 208  : 
; 209  : 	HASH_TABLE_ASSERT_STATUS;
; 210  : 
; 211  : 	size_t listIndex = 0;

	mov	DWORD PTR _listIndex$[ebp], 0

; 212  : 
; 213  : 	__asm
; 214  : 	{
; 215  : 		mov	ecx, dword ptr element[0]

	mov	ecx, DWORD PTR _element$GSCopy$[ebp]

; 216  : 
; 217  : 		xor eax, eax

	xor	eax, eax

; 218  : 		crc32 eax, dword ptr[ecx]

	crc32	eax, DWORD PTR [ecx]

; 219  : 
; 220  : 		crc32 eax, dword ptr[ecx + 4]

	crc32	eax, DWORD PTR [ecx+4]

; 221  : 
; 222  : 		crc32 eax, dword ptr[ecx + 8]

	crc32	eax, DWORD PTR [ecx+8]

; 223  : 
; 224  : 		crc32 eax, dword ptr[ecx + 12]

	crc32	eax, DWORD PTR [ecx+12]

; 225  : 
; 226  : 		mov ebx, table

	mov	ebx, DWORD PTR _table$GSCopy$[ebp]

; 227  : 		mov ebx, dword ptr[ebx + 4]; table->ListCount

	mov	ebx, DWORD PTR [ebx+4]

; 228  : 
; 229  : 		xor edx, edx

	xor	edx, edx

; 230  : 		div ebx

	div	ebx

; 231  : 
; 232  : 		mov listIndex, edx

	mov	DWORD PTR _listIndex$[ebp], edx

; 233  : 	}
; 234  : 
; 235  : 	size_t findIndex = ListFind(table->Lists + listIndex, element);

	mov	eax, DWORD PTR _listIndex$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [edi+8]
	push	esi
	push	eax
	call	?ListFind@@YAIPBUList@@PBT__m128i@@@Z	; ListFind
	mov	edx, eax
	add	esp, 8

; 236  : 
; 237  : 	if (findIndex == 0)

	test	edx, edx
	jne	SHORT $LN2@HashTableF

; 241  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@HashTableF:

; 238  : 		return nullptr;
; 239  : 
; 240  : 	return &table->Lists[listIndex].Nodes[findIndex].Data;

	mov	ecx, DWORD PTR _listIndex$[ebp]
	mov	eax, DWORD PTR [edi+8]
	shl	ecx, 5
	pop	edi
	shl	edx, 5

; 241  : }

	pop	esi
	mov	eax, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	eax, 16					; 00000010H
	xor	ecx, ebp
	add	eax, edx
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?HashTableFind@@YAPAT__m128i@@PBUHashTable@@PBT1@@Z ENDP ; HashTableFind
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\HashTable\HashTable.cpp
;	COMDAT ?HashTableInsert@@YAHPAUHashTable@@PBT__m128i@@@Z
_TEXT	SEGMENT
_table$GSCopy$ = -16					; size = 4
_listIndex$ = -12					; size = 4
_element$GSCopy$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_table$ = 8						; size = 4
_element$ = 12						; size = 4
?HashTableInsert@@YAHPAUHashTable@@PBT__m128i@@@Z PROC	; HashTableInsert, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _table$[ebp]
	push	edi
	mov	edi, DWORD PTR _element$[ebp]
	mov	DWORD PTR _table$GSCopy$[ebp], esi
	mov	DWORD PTR _element$GSCopy$[ebp], edi

; 92   : 	LOG_HASH_TABLE_TRACE_FUNC_0;
; 93   : 
; 94   : 	assert(table);
; 95   : 	assert(element);
; 96   : 
; 97   : 	HASH_TABLE_ASSERT_STATUS;
; 98   : 
; 99   : 	size_t listIndex = 0;

	mov	DWORD PTR _listIndex$[ebp], 0

; 100  : 
; 101  : 	__asm
; 102  : 	{
; 103  : 		mov	ecx, dword ptr element[0]

	mov	ecx, DWORD PTR _element$GSCopy$[ebp]

; 104  : 
; 105  : 		xor eax, eax

	xor	eax, eax

; 106  : 		crc32 eax, dword ptr[ecx]

	crc32	eax, DWORD PTR [ecx]

; 107  : 
; 108  : 		crc32 eax, dword ptr[ecx + 4]

	crc32	eax, DWORD PTR [ecx+4]

; 109  : 
; 110  : 		crc32 eax, dword ptr[ecx + 8]

	crc32	eax, DWORD PTR [ecx+8]

; 111  : 
; 112  : 		crc32 eax, dword ptr[ecx + 12]

	crc32	eax, DWORD PTR [ecx+12]

; 113  : 
; 114  : 		mov ebx, table

	mov	ebx, DWORD PTR _table$GSCopy$[ebp]

; 115  : 		mov ebx, dword ptr[ebx + 4] ; table->ListCount

	mov	ebx, DWORD PTR [ebx+4]

; 116  : 
; 117  : 		xor edx, edx

	xor	edx, edx

; 118  : 		div ebx

	div	ebx

; 119  : 
; 120  : 		mov listIndex, edx

	mov	DWORD PTR _listIndex$[ebp], edx

; 121  : 	}
; 122  : 
; 123  : 	size_t elemIndex = ListFind(table->Lists + listIndex, element);

	mov	eax, DWORD PTR _listIndex$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [esi+8]
	push	edi
	push	eax
	call	?ListFind@@YAIPBUList@@PBT__m128i@@@Z	; ListFind
	add	esp, 8

; 124  : 
; 125  : 	if (elemIndex != 0)

	test	eax, eax
	je	SHORT $LN2@HashTableI

; 126  : 	{
; 127  : 		table->Warnings = HASH_TABLE_WRN_INSERT_EXIST;

	pop	edi
	mov	DWORD PTR [esi+20], 1

; 128  : 		return table->Warnings;

	mov	eax, 1

; 144  : }

	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@HashTableI:

; 129  : 	}
; 130  : 
; 131  : 	if (ListAddElemAfter(table->Lists + listIndex, element, table->Lists[listIndex].Tail) != LIST_ERR_NO_ERRORS)

	mov	ecx, DWORD PTR _listIndex$[ebp]
	mov	eax, DWORD PTR [esi+8]
	shl	ecx, 5
	add	eax, ecx
	push	DWORD PTR [eax+12]
	push	edi
	push	eax
	call	?ListAddElemAfter@@YAHPAUList@@PBT__m128i@@I@Z ; ListAddElemAfter
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@HashTableI

; 132  : 	{
; 133  : 		LOG_F_HASH_TABLE_ERR("Ошибка добавления элемента в список. "

	push	edi
	push	DWORD PTR _listIndex$[ebp]
	push	OFFSET ??_C@_0EI@EKLNNALM@?N?x?h?a?j?$OA?5?d?n?a?$OA?b?k?e?m?h?$PP?5?$PN?k?e?l?e?m?r?$OA?5?b?5?q?o@
	push	135					; 00000087H
	push	OFFSET ??_C@_0DK@PMCBLCOD@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0EG@OFHKIGCK@int?5__cdecl?5HashTableInsert?$CIstr@
	push	1
	push	1
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 134  : 							 "listIndex = %zd. "
; 135  : 							 "wordData = \"%16s\"", listIndex, (char*)element);
; 136  : 
; 137  : 		table->ExtStatus = table->Lists[listIndex].Status;

	mov	ecx, DWORD PTR _listIndex$[ebp]
	add	esp, 36					; 00000024H
	mov	eax, DWORD PTR [esi+8]
	shl	ecx, 5
	pop	edi
	mov	eax, DWORD PTR [ecx+eax+28]
	mov	DWORD PTR [esi+16], eax

; 138  : 		table->Status = HASH_TABLE_ERR_LIST;
; 139  : 
; 140  : 		return table->Status;

	mov	eax, 1048576				; 00100000H
	mov	DWORD PTR [esi+12], 1048576		; 00100000H

; 144  : }

	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@HashTableI:

; 141  : 	}
; 142  : 
; 143  : 	return table->Status;

	mov	eax, DWORD PTR [esi+12]

; 144  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?HashTableInsert@@YAHPAUHashTable@@PBT__m128i@@@Z ENDP	; HashTableInsert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\HashTable\HashTable.cpp
;	COMDAT ?HashTableDestructor@@YAHPAUHashTable@@@Z
_TEXT	SEGMENT
_table$ = 8						; size = 4
?HashTableDestructor@@YAHPAUHashTable@@@Z PROC		; HashTableDestructor, COMDAT

; 68   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR _table$[ebp]
	push	esi

; 69   : 	LOG_HASH_TABLE_TRACE_CTOR;
; 70   : 
; 71   : 	assert(table);
; 72   : 
; 73   : 	HASH_TABLE_ASSERT_STATUS;
; 74   : 
; 75   : 	int status = HASH_TABLE_ERR_NO_ERRORS;
; 76   : 
; 77   : 	for (size_t st = 0; st < table->ListCount; st++)

	xor	esi, esi
	cmp	DWORD PTR [ebx+4], esi
	jbe	SHORT $LN10@HashTableD
	push	edi
	xor	edi, edi
$LL4@HashTableD:

; 78   : 	{
; 79   : 		ListDestructor(table->Lists + st);

	mov	eax, DWORD PTR [ebx+8]
	add	eax, edi
	push	eax
	call	?ListDestructor@@YAXPAUList@@@Z		; ListDestructor
	inc	esi
	add	esp, 4
	add	edi, 32					; 00000020H
	cmp	esi, DWORD PTR [ebx+4]
	jb	SHORT $LL4@HashTableD
	pop	edi
$LN10@HashTableD:

; 80   : 	}
; 81   : 
; 82   : 	free(table->Lists);

	push	DWORD PTR [ebx+8]
	call	DWORD PTR __imp__free
	add	esp, 4

; 83   : 
; 84   : 	return status;

	xor	eax, eax
	pop	esi
	pop	ebx

; 85   : }

	pop	ebp
	ret	0
?HashTableDestructor@@YAHPAUHashTable@@@Z ENDP		; HashTableDestructor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\HashTable\HashTable.cpp
;	COMDAT ?HashTableConstructor@@YAHPAUHashTable@@IIP6AIPBT__m128i@@@Z@Z
_TEXT	SEGMENT
_table$ = 8						; size = 4
_listCount$ = 12					; size = 4
_listCapacity$ = 16					; size = 4
_hashFunction$ = 20					; size = 4
?HashTableConstructor@@YAHPAUHashTable@@IIP6AIPBT__m128i@@@Z@Z PROC ; HashTableConstructor, COMDAT

; 19   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 20   : 	LOG_HASH_TABLE_TRACE_CTOR;
; 21   : 
; 22   : 	assert(table);
; 23   : 	assert(hashFunction);
; 24   : 
; 25   : 	HASH_TABLE_ASSERT_STATUS;
; 26   : 
; 27   : 	if ((table->Status = HashTableVerifyInit(table)) != HASH_TABLE_ERR_NO_ERRORS)

	mov	esi, DWORD PTR _table$[ebp]
	push	esi
	call	?HashTableVerifyInit@@YAHPBUHashTable@@@Z ; HashTableVerifyInit
	add	esp, 4
	mov	DWORD PTR [esi+12], eax
	test	eax, eax
	jne	$LN1@HashTableC

; 28   : 		return table->Status;
; 29   : 
; 30   : 	table->Status    = HASH_TABLE_ERR_NO_ERRORS;

	mov	DWORD PTR [esi+12], eax

; 31   : 	table->ExtStatus = HASH_TABLE_ERR_NO_ERRORS;

	mov	DWORD PTR [esi+16], eax

; 32   : 	table->Warnings  = HASH_TABLE_WRN_NO_WARNINGS;

	mov	DWORD PTR [esi+20], eax

; 33   : 
; 34   : 	table->ListCount = listCount;

	mov	eax, DWORD PTR _listCount$[ebp]

; 35   : 	table->Lists     = (List*)calloc(sizeof(List), listCount);

	push	eax
	push	32					; 00000020H
	mov	DWORD PTR [esi+4], eax
	call	DWORD PTR __imp__calloc

; 36   : 
; 37   : 	table->HashFunction  = hashFunction;

	mov	ecx, DWORD PTR _hashFunction$[ebp]
	add	esp, 8
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi], ecx

; 38   : 
; 39   : 	if (!table->Lists)

	test	eax, eax
	jne	SHORT $LN6@HashTableC

; 40   : 	{
; 41   : 		LOG_HASH_TABLE_ERR_MEMORY;

	push	41					; 00000029H
	push	OFFSET ??_C@_0DK@PMCBLCOD@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0IL@LDKNIHDM@int?5__cdecl?5HashTableConstructo@
	push	1
	push	1
	push	4
	push	OFFSET ??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine

; 42   : 
; 43   : 		table->Status |= HASH_TABLE_ERR_MEMORY;

	mov	eax, DWORD PTR [esi+12]
	add	esp, 28					; 0000001cH
	or	eax, 2
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 65   : }

	pop	ebp
	ret	0
$LN6@HashTableC:
	push	edi

; 44   : 
; 45   : 		return table->Status;
; 46   : 	}
; 47   : 
; 48   : 	for (size_t st = 0; st < table->ListCount; st++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jbe	SHORT $LN3@HashTableC
	push	ebx
	xor	ebx, ebx
$LL4@HashTableC:

; 49   : 	{
; 50   : 		if (ListConstructor(table->Lists + st, listCapacity) != LIST_ERR_NO_ERRORS)

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR _listCapacity$[ebp]
	add	eax, ebx
	push	eax
	call	?ListConstructor@@YAHPAUList@@I@Z	; ListConstructor
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@HashTableC

; 44   : 
; 45   : 		return table->Status;
; 46   : 	}
; 47   : 
; 48   : 	for (size_t st = 0; st < table->ListCount; st++)

	inc	edi
	add	ebx, 32					; 00000020H
	cmp	edi, DWORD PTR [esi+4]
	jb	SHORT $LL4@HashTableC

; 60   : 			break;
; 61   : 		}
; 62   : 	}
; 63   : 
; 64   : 	return HASH_TABLE_ERR_NO_ERRORS;

	pop	ebx
	pop	edi
	pop	esi

; 65   : }

	pop	ebp
	ret	0
$LN10@HashTableC:

; 51   : 		{
; 52   : 			LOG_F_HASH_TABLE_ERR("Ошибка создания массива списков в конструкторе. "

	push	edi
	push	OFFSET ??_C@_0EF@JDHLNIEH@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?l?$OA?q?q?h?b?$OA?5?q?o?h?q?j?n?b@
	push	53					; 00000035H
	push	OFFSET ??_C@_0DK@PMCBLCOD@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0IL@LDKNIHDM@int?5__cdecl?5HashTableConstructo@
	push	1
	push	1
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 53   : 								 "Создано списков %zd.", st);
; 54   : 
; 55   : 			table->ListCount = st;
; 56   : 
; 57   : 			table->Status |= HASH_TABLE_ERR_LIST;

	or	DWORD PTR [esi+12], 1048576		; 00100000H

; 58   : 
; 59   : 			HashTableDestructor(table);

	push	esi
	mov	DWORD PTR [esi+4], edi
	call	?HashTableDestructor@@YAHPAUHashTable@@@Z ; HashTableDestructor
	add	esp, 36					; 00000024H
	pop	ebx
$LN3@HashTableC:

; 60   : 			break;
; 61   : 		}
; 62   : 	}
; 63   : 
; 64   : 	return HASH_TABLE_ERR_NO_ERRORS;

	xor	eax, eax
	pop	edi
$LN1@HashTableC:
	pop	esi

; 65   : }

	pop	ebp
	ret	0
?HashTableConstructor@@YAHPAUHashTable@@IIP6AIPBT__m128i@@@Z@Z ENDP ; HashTableConstructor
_TEXT	ENDS
END
