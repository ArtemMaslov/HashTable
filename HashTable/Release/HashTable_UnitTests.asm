; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31105.0 

	TITLE	D:\Language C\HashTable\HashTable\Release\HashTable_UnitTests.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	?TestHashTable_Sheakspear@@YAXXZ		; TestHashTable_Sheakspear
PUBLIC	?TestHashTable_OptimizationFind@@YAXXZ		; TestHashTable_OptimizationFind
PUBLIC	?TestHashTable_OptimizationInsertRemove@@YAXXZ	; TestHashTable_OptimizationInsertRemove
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0M@NJFEAFHH@tests?2?$CK?4txt@		; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0BI@LNKAJNEN@hash_statistic_list?4csv@	; `string'
PUBLIC	??_C@_0BL@MGLKJJGI@Hash?5function?5?$CFzd?5loaded?4?6@ ; `string'
PUBLIC	??_C@_09PLEPEFIC@hash?$CFzd?0?5@		; `string'
PUBLIC	??_C@_05LKKJMJMF@?$CFzd?0?5@			; `string'
PUBLIC	??_C@_05NAOIJFC@Error@				; `string'
PUBLIC	??_C@_04IBEPGDBI@?$CFzd?6@			; `string'
PUBLIC	??_C@_0EE@GMLEBJOP@D?3?2Language?5C?2HashTable?2HashTab@ ; `string'
PUBLIC	??_C@_0FE@NCGNBDBL@void?5__cdecl?5HashTableLoadWords@ ; `string'
PUBLIC	??_C@_0M@IBPGCMGL@Data?5loaded@			; `string'
PUBLIC	??_C@_0EL@NBEGEBLP@int?5__cdecl?5ConvertWordsType?$CIst@ ; `string'
PUBLIC	??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@ ; `string'
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fputc:PROC
EXTRN	__imp__puts:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	?TextConstructor@@YAHPAUTextAnalyzer@@II@Z:PROC	; TextConstructor
EXTRN	?TextDestructor@@YAXPAUTextAnalyzer@@@Z:PROC	; TextDestructor
EXTRN	?TextParseIntoWordsDirectory_32@@YAXPAUTextAnalyzer@@PBDI@Z:PROC ; TextParseIntoWordsDirectory_32
EXTRN	?HashTableConstructor@@YAHPAUHashTable@@IIP6AIPBT__m128i@@@Z@Z:PROC ; HashTableConstructor
EXTRN	?HashTableDestructor@@YAHPAUHashTable@@@Z:PROC	; HashTableDestructor
EXTRN	?HashTableInsert@@YAHPAUHashTable@@PBT__m128i@@@Z:PROC ; HashTableInsert
EXTRN	?HashTableFind@@YAPAT__m128i@@PBUHashTable@@PBT1@@Z:PROC ; HashTableFind
EXTRN	?HashTableRemove@@YAHPAUHashTable@@PBT__m128i@@@Z:PROC ; HashTableRemove
EXTRN	?HashTableClearLists@@YAXPAUHashTable@@@Z:PROC	; HashTableClearLists
EXTRN	?HashTable_HashConstant@@YAIPBT__m128i@@@Z:PROC	; HashTable_HashConstant
EXTRN	?HashTable_HashLetter@@YAIPBT__m128i@@@Z:PROC	; HashTable_HashLetter
EXTRN	?HashTable_HashLength@@YAIPBT__m128i@@@Z:PROC	; HashTable_HashLength
EXTRN	?HashTable_HashCharSum@@YAIPBT__m128i@@@Z:PROC	; HashTable_HashCharSum
EXTRN	?HashTable_HashRor@@YAIPBT__m128i@@@Z:PROC	; HashTable_HashRor
EXTRN	?HashTable_HashCRC32_C@@YAIPBT__m128i@@@Z:PROC	; HashTable_HashCRC32_C
EXTRN	?HashTable_HashCRC32_Intrin_32@@YAIPBT__m128i@@@Z:PROC ; HashTable_HashCRC32_Intrin_32
EXTRN	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z:PROC ; LogLine
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
CONST	SEGMENT
??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0e2H, 0fbH, 0e4H, 0e5H, 0ebH
	DB	0e5H, 0edH, 0e8H, 0ffH, ' ', 0efH, 0e0H, 0ecH, 0ffH, 0f2H, 0e8H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NBEGEBLP@int?5__cdecl?5ConvertWordsType?$CIst@
CONST	SEGMENT
??_C@_0EL@NBEGEBLP@int?5__cdecl?5ConvertWordsType?$CIst@ DB 'int __cdecl '
	DB	'ConvertWordsType(struct WordsArray128 *,struct TextAnalyzer *'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IBPGCMGL@Data?5loaded@
CONST	SEGMENT
??_C@_0M@IBPGCMGL@Data?5loaded@ DB 'Data loaded', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@NCGNBDBL@void?5__cdecl?5HashTableLoadWords@
CONST	SEGMENT
??_C@_0FE@NCGNBDBL@void?5__cdecl?5HashTableLoadWords@ DB 'void __cdecl Ha'
	DB	'shTableLoadWordsIntoTable(struct HashTable *,struct WordsArra'
	DB	'y128 *)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@GMLEBJOP@D?3?2Language?5C?2HashTable?2HashTab@
CONST	SEGMENT
??_C@_0EE@GMLEBJOP@D?3?2Language?5C?2HashTable?2HashTab@ DB 'D:\Language '
	DB	'C\HashTable\HashTable\HashTable\HashTable_UnitTests.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBEPGDBI@?$CFzd?6@
CONST	SEGMENT
??_C@_04IBEPGDBI@?$CFzd?6@ DB '%zd', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error@
CONST	SEGMENT
??_C@_05NAOIJFC@Error@ DB 'Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LKKJMJMF@?$CFzd?0?5@
CONST	SEGMENT
??_C@_05LKKJMJMF@?$CFzd?0?5@ DB '%zd, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PLEPEFIC@hash?$CFzd?0?5@
CONST	SEGMENT
??_C@_09PLEPEFIC@hash?$CFzd?0?5@ DB 'hash%zd, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MGLKJJGI@Hash?5function?5?$CFzd?5loaded?4?6@
CONST	SEGMENT
??_C@_0BL@MGLKJJGI@Hash?5function?5?$CFzd?5loaded?4?6@ DB 'Hash function '
	DB	'%zd loaded.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LNKAJNEN@hash_statistic_list?4csv@
CONST	SEGMENT
??_C@_0BI@LNKAJNEN@hash_statistic_list?4csv@ DB 'hash_statistic_list.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJFEAFHH@tests?2?$CK?4txt@
CONST	SEGMENT
??_C@_0M@NJFEAFHH@tests?2?$CK?4txt@ DB 'tests\*.txt', 00H ; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\HashTable\HashTable_UnitTests.cpp
;	COMDAT ?WordsArrayDestructor@@YAXPAUWordsArray128@@@Z
_TEXT	SEGMENT
_words$ = 8						; size = 4
?WordsArrayDestructor@@YAXPAUWordsArray128@@@Z PROC	; WordsArrayDestructor, COMDAT

; 343  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 344  : 	assert(words);
; 345  : 
; 346  : 	free(words->Data);

	mov	esi, DWORD PTR _words$[ebp]
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__free
	add	esp, 4

; 347  : 
; 348  : 	words->Data = nullptr;

	mov	DWORD PTR [esi], 0

; 349  : 	words->Size = 0;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 350  : }

	pop	ebp
	ret	0
?WordsArrayDestructor@@YAXPAUWordsArray128@@@Z ENDP	; WordsArrayDestructor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\HashTable\HashTable_UnitTests.cpp
;	COMDAT ?ConvertWordsType@@YAHPAUWordsArray128@@PAUTextAnalyzer@@@Z
_TEXT	SEGMENT
_words$GSCopy$1$ = -48					; size = 4
_wordsArray$1$ = -44					; size = 4
_wordsSize$1$ = -40					; size = 4
_textWords$1$ = -36					; size = 4
_word$1 = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_words$ = 8						; size = 4
_text$ = 12						; size = 4
?ConvertWordsType@@YAHPAUWordsArray128@@PAUTextAnalyzer@@@Z PROC ; ConvertWordsType, COMDAT

; 302  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _text$[ebx]
	push	esi
	mov	esi, DWORD PTR _words$[ebx]
	push	edi

; 303  : 	LOG_HASH_TABLE_TRACE_FUNC_1;
; 304  : 
; 305  : 	assert(words);
; 306  : 	assert(text);
; 307  : 
; 308  : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 309  : 
; 310  : 	const size_t wordsSize = text->WordsSize;

	mov	edi, DWORD PTR [eax+12]

; 311  : 
; 312  : 	const Word* textWords  = text->Words;

	mov	eax, DWORD PTR [eax+20]

; 313  : 
; 314  : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 315  : 
; 316  : 	__m128i* wordsArray = (__m128i*)calloc(wordsSize, sizeof(__m128i));

	push	16					; 00000010H
	push	edi
	mov	DWORD PTR _words$GSCopy$1$[ebp], esi
	mov	DWORD PTR _wordsSize$1$[ebp], edi
	mov	DWORD PTR _textWords$1$[ebp], eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	mov	DWORD PTR _wordsArray$1$[ebp], eax

; 317  : 
; 318  : 	if (!wordsArray)

	test	eax, eax
	jne	SHORT $LN5@ConvertWor

; 319  : 	{
; 320  : 		LOG_HASH_TABLE_ERR_MEMORY;

	push	320					; 00000140H
	push	OFFSET ??_C@_0EE@GMLEBJOP@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0EL@NBEGEBLP@int?5__cdecl?5ConvertWordsType?$CIst@
	push	1
	push	1
	push	4
	push	OFFSET ??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine
	add	esp, 28					; 0000001cH

; 321  : 
; 322  : 		return HASH_TABLE_ERR_MEMORY;

	mov	eax, 2

; 334  : 	}
; 335  : 
; 336  : 	words->Data = wordsArray;
; 337  : 	words->Size = wordsSize;
; 338  : 
; 339  : 	return HASH_TABLE_ERR_NO_ERRORS;
; 340  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
$LN5@ConvertWor:

; 323  : 	}
; 324  : 
; 325  : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 326  : 
; 327  : 	for (size_t st = 0; st < wordsSize; st++)

	test	edi, edi
	je	SHORT $LN3@ConvertWor

; 328  : 	{
; 329  : 		__m128i word = _mm_set1_epi32(0);
; 330  : 
; 331  : 		memcpy(&word, textWords->Data, textWords->Size);

	xorps	xmm0, xmm0
	mov	esi, eax
$LL4@ConvertWor:
	mov	eax, DWORD PTR _textWords$1$[ebp]
	movaps	XMMWORD PTR _word$1[ebp], xmm0
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _word$1[ebp]
	push	eax
	call	_memcpy

; 332  : 
; 333  : 		wordsArray[st] = word;

	movaps	xmm0, XMMWORD PTR _word$1[ebp]
	lea	esi, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	movups	XMMWORD PTR [esi-16], xmm0
	xorps	xmm0, xmm0
	sub	edi, 1
	jne	SHORT $LL4@ConvertWor
	mov	edi, DWORD PTR _wordsSize$1$[ebp]
	mov	eax, DWORD PTR _wordsArray$1$[ebp]
	mov	esi, DWORD PTR _words$GSCopy$1$[ebp]
$LN3@ConvertWor:

; 334  : 	}
; 335  : 
; 336  : 	words->Data = wordsArray;
; 337  : 	words->Size = wordsSize;
; 338  : 
; 339  : 	return HASH_TABLE_ERR_NO_ERRORS;
; 340  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	DWORD PTR [esi+4], edi
	xor	ecx, ebp
	mov	DWORD PTR [esi], eax
	xor	eax, eax
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?ConvertWordsType@@YAHPAUWordsArray128@@PAUTextAnalyzer@@@Z ENDP ; ConvertWordsType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\HashTable\HashTable_UnitTests.cpp
;	COMDAT ?HashTableLoadWordsIntoTable@@YAXPAUHashTable@@PAUWordsArray128@@@Z
_TEXT	SEGMENT
_table$ = 8						; size = 4
_wordsSize$1$ = 12					; size = 4
_words$ = 12						; size = 4
?HashTableLoadWordsIntoTable@@YAXPAUHashTable@@PAUWordsArray128@@@Z PROC ; HashTableLoadWordsIntoTable, COMDAT

; 276  : {

	push	ebp
	mov	ebp, esp

; 277  : 	LOG_HASH_TABLE_TRACE_FUNC_1;
; 278  : 
; 279  : 	assert(table);
; 280  : 	assert(words);
; 281  : 
; 282  : 	HASH_TABLE_ASSERT_STATUS;
; 283  : 
; 284  : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 285  : 
; 286  : 	const size_t wordsSize = words->Size;

	mov	eax, DWORD PTR _words$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	ecx, DWORD PTR [eax+4]

; 287  : 
; 288  : 	const __m128i* data = words->Data;
; 289  : 
; 290  : 	for (size_t st = 0; st < wordsSize; st++)

	xor	edi, edi
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _wordsSize$1$[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN3@HashTableL

; 277  : 	LOG_HASH_TABLE_TRACE_FUNC_1;
; 278  : 
; 279  : 	assert(table);
; 280  : 	assert(words);
; 281  : 
; 282  : 	HASH_TABLE_ASSERT_STATUS;
; 283  : 
; 284  : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 285  : 
; 286  : 	const size_t wordsSize = words->Size;

	mov	ebx, DWORD PTR _table$[ebp]
	npad	6
$LL4@HashTableL:

; 291  : 	{
; 292  : 		HashTableInsert(table, data + st);

	push	esi
	push	ebx
	call	?HashTableInsert@@YAHPAUHashTable@@PBT__m128i@@@Z ; HashTableInsert
	add	esp, 8

; 293  : 
; 294  : 		if (table->Status != HASH_TABLE_ERR_NO_ERRORS)

	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN1@HashTableL

; 287  : 
; 288  : 	const __m128i* data = words->Data;
; 289  : 
; 290  : 	for (size_t st = 0; st < wordsSize; st++)

	inc	edi
	add	esi, 16					; 00000010H
	cmp	edi, DWORD PTR _wordsSize$1$[ebp]
	jb	SHORT $LL4@HashTableL
$LN3@HashTableL:

; 295  : 			return;
; 296  : 	}
; 297  : 
; 298  : 	LOG_HASH_TABLE_DBG("Data loaded");

	push	298					; 0000012aH
	push	OFFSET ??_C@_0EE@GMLEBJOP@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0FE@NCGNBDBL@void?5__cdecl?5HashTableLoadWords@
	push	1
	push	1
	push	1
	push	OFFSET ??_C@_0M@IBPGCMGL@Data?5loaded@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine
	add	esp, 28					; 0000001cH
$LN1@HashTableL:

; 299  : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
?HashTableLoadWordsIntoTable@@YAXPAUHashTable@@PAUWordsArray128@@@Z ENDP ; HashTableLoadWordsIntoTable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\HashTable\HashTable_UnitTests.cpp
;	COMDAT ?TestHashTable_OptimizationInsertRemove@@YAXXZ
_TEXT	SEGMENT
_st1$1$ = -92						; size = 4
_words$ = -88						; size = 8
_text$ = -80						; size = 28
_table$ = -48						; size = 24
__$ArrayPad$ = -4					; size = 4
?TestHashTable_OptimizationInsertRemove@@YAXXZ PROC	; TestHashTable_OptimizationInsertRemove, COMDAT

; 216  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 217  : 	HashTable     table = {};
; 218  : 
; 219  : 	TextAnalyzer  text  = {};
; 220  : 
; 221  : 	WordsArray128 words = {};
; 222  : 
; 223  : 	HashTableConstructor(&table, DefaultListCount, DefaultListCapacity, HashTable_HashCRC32_Intrin_32);

	push	OFFSET ?HashTable_HashCRC32_Intrin_32@@YAIPBT__m128i@@@Z ; HashTable_HashCRC32_Intrin_32
	xorps	xmm0, xmm0
	mov	DWORD PTR _text$[ebp+24], 0
	push	1000					; 000003e8H
	lea	eax, DWORD PTR _table$[ebp]
	movaps	XMMWORD PTR _table$[ebp], xmm0
	push	1500					; 000005dcH
	push	eax
	movq	QWORD PTR _table$[ebp+16], xmm0
	movaps	XMMWORD PTR _text$[ebp], xmm0
	movq	QWORD PTR _text$[ebp+16], xmm0
	movlpd	QWORD PTR _words$[ebp], xmm0
	call	?HashTableConstructor@@YAHPAUHashTable@@IIP6AIPBT__m128i@@@Z@Z ; HashTableConstructor
	add	esp, 16					; 00000010H

; 224  : 
; 225  : 	if (table.Status != HASH_TABLE_ERR_NO_ERRORS)

	cmp	DWORD PTR _table$[ebp+12], 0
	jne	$clear_and_return$36

; 226  : 		CLEAR_AND_RETURN;
; 227  : 
; 228  : 	TextConstructor(&text, DefaultWordsCapacity, TextsCount);

	push	42					; 0000002aH
	lea	eax, DWORD PTR _text$[ebp]
	push	1000000					; 000f4240H
	push	eax
	call	?TextConstructor@@YAHPAUTextAnalyzer@@II@Z ; TextConstructor
	add	esp, 12					; 0000000cH

; 229  : 
; 230  : 	if (text.Status != TEXT_ERR_NO_ERRORS)

	cmp	DWORD PTR _text$[ebp+24], 0
	jne	$clear_and_return$36

; 231  : 		CLEAR_AND_RETURN;
; 232  : 
; 233  : 	TextParseIntoWordsDirectory_32(&text, "tests\\*.txt", MaximumWordSize);

	push	16					; 00000010H
	lea	eax, DWORD PTR _text$[ebp]
	push	OFFSET ??_C@_0M@NJFEAFHH@tests?2?$CK?4txt@
	push	eax
	call	?TextParseIntoWordsDirectory_32@@YAXPAUTextAnalyzer@@PBDI@Z ; TextParseIntoWordsDirectory_32

; 234  : 
; 235  : 	if (ConvertWordsType(&words, &text) != HASH_TABLE_ERR_NO_ERRORS)

	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	lea	eax, DWORD PTR _words$[ebp]
	push	eax
	call	?ConvertWordsType@@YAHPAUWordsArray128@@PAUTextAnalyzer@@@Z ; ConvertWordsType
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$clear_and_return$36

; 236  : 		CLEAR_AND_RETURN;
; 237  : 
; 238  : 	if (table.Status != HASH_TABLE_ERR_NO_ERRORS)

	cmp	DWORD PTR _table$[ebp+12], eax
	jne	$clear_and_return$36

; 239  : 		CLEAR_AND_RETURN;
; 240  : 
; 241  : 	HashTableLoadWordsIntoTable(&table, &words);

	lea	eax, DWORD PTR _words$[ebp]
	push	eax
	lea	eax, DWORD PTR _table$[ebp]
	push	eax
	call	?HashTableLoadWordsIntoTable@@YAXPAUHashTable@@PAUWordsArray128@@@Z ; HashTableLoadWordsIntoTable
	add	esp, 8

; 242  : 
; 243  : 	if (table.Status != HASH_TABLE_ERR_NO_ERRORS)

	cmp	DWORD PTR _table$[ebp+12], 0
	jne	SHORT $clear_and_return$36

; 244  : 		CLEAR_AND_RETURN;
; 245  : 
; 246  : 	{
; 247  : 		const size_t wordsCount = words.Size;

	mov	eax, DWORD PTR _words$[ebp+4]
	xor	esi, esi
	mov	ecx, DWORD PTR _words$[ebp]
	mov	DWORD PTR _st1$1$[ebp], esi
	npad	6
$LL4@TestHashTa:

; 248  : 
; 249  : 		for (size_t st1 = 0; st1 < 1000; st1++)
; 250  : 		{
; 251  : 			for (size_t st = 0; st < wordsCount; st++)

	test	eax, eax
	je	SHORT $LN9@TestHashTa
	mov	esi, ecx
	mov	edi, eax
$LL7@TestHashTa:

; 252  : 			{
; 253  : 				HashTableRemove(&table, &words.Data[st]);

	lea	eax, DWORD PTR _table$[ebp]
	push	esi
	push	eax
	call	?HashTableRemove@@YAHPAUHashTable@@PBT__m128i@@@Z ; HashTableRemove
	add	esp, 8
	add	esi, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL7@TestHashTa

; 254  : 			}
; 255  : 
; 256  : 			for (size_t st = 0; st < wordsCount; st++)

	mov	eax, DWORD PTR _words$[ebp+4]
	mov	esi, DWORD PTR _st1$1$[ebp]
	mov	ecx, DWORD PTR _words$[ebp]
	test	eax, eax
	je	SHORT $LN9@TestHashTa
	mov	esi, ecx
	mov	edi, eax
	npad	2
$LL10@TestHashTa:

; 257  : 			{
; 258  : 				HashTableInsert(&table, &words.Data[st]);

	lea	eax, DWORD PTR _table$[ebp]
	push	esi
	push	eax
	call	?HashTableInsert@@YAHPAUHashTable@@PBT__m128i@@@Z ; HashTableInsert
	add	esp, 8
	add	esi, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL10@TestHashTa
	mov	esi, DWORD PTR _st1$1$[ebp]
$LN9@TestHashTa:

; 259  : 			}
; 260  : 
; 261  : 			printf("%zd\n", st1);

	push	esi
	push	OFFSET ??_C@_04IBEPGDBI@?$CFzd?6@
	call	_printf
	mov	eax, DWORD PTR _words$[ebp+4]
	inc	esi
	mov	ecx, DWORD PTR _words$[ebp]
	add	esp, 8
	mov	DWORD PTR _st1$1$[ebp], esi
	cmp	esi, 1000				; 000003e8H
	jb	SHORT $LL4@TestHashTa
$clear_and_return$36:

; 262  : 		}
; 263  : 	}
; 264  : 
; 265  : clear_and_return:
; 266  : 
; 267  : 	HashTableDestructor(&table);

	lea	eax, DWORD PTR _table$[ebp]
	push	eax
	call	?HashTableDestructor@@YAHPAUHashTable@@@Z ; HashTableDestructor

; 268  : 	TextDestructor(&text);

	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	?TextDestructor@@YAXPAUTextAnalyzer@@@Z	; TextDestructor

; 269  : 	WordsArrayDestructor(&words);

	lea	eax, DWORD PTR _words$[ebp]
	push	eax
	call	?WordsArrayDestructor@@YAXPAUWordsArray128@@@Z ; WordsArrayDestructor

; 270  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	xor	ecx, ebp
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?TestHashTable_OptimizationInsertRemove@@YAXXZ ENDP	; TestHashTable_OptimizationInsertRemove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\HashTable\HashTable_UnitTests.cpp
;	COMDAT ?TestHashTable_OptimizationFind@@YAXXZ
_TEXT	SEGMENT
_st1$1$ = -92						; size = 4
_words$ = -88						; size = 8
_text$ = -80						; size = 28
_table$ = -48						; size = 24
__$ArrayPad$ = -4					; size = 4
?TestHashTable_OptimizationFind@@YAXXZ PROC		; TestHashTable_OptimizationFind, COMDAT

; 159  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 160  : 	HashTable     table = {};
; 161  : 
; 162  : 	TextAnalyzer  text  = {};
; 163  : 
; 164  : 	WordsArray128 words = {};
; 165  : 
; 166  : 	HashTableConstructor(&table, DefaultListCount, DefaultListCapacity, HashTable_HashCRC32_Intrin_32);

	push	OFFSET ?HashTable_HashCRC32_Intrin_32@@YAIPBT__m128i@@@Z ; HashTable_HashCRC32_Intrin_32
	xorps	xmm0, xmm0
	mov	DWORD PTR _text$[ebp+24], 0
	push	1000					; 000003e8H
	lea	eax, DWORD PTR _table$[ebp]
	movaps	XMMWORD PTR _table$[ebp], xmm0
	push	1500					; 000005dcH
	push	eax
	movq	QWORD PTR _table$[ebp+16], xmm0
	movaps	XMMWORD PTR _text$[ebp], xmm0
	movq	QWORD PTR _text$[ebp+16], xmm0
	movlpd	QWORD PTR _words$[ebp], xmm0
	call	?HashTableConstructor@@YAHPAUHashTable@@IIP6AIPBT__m128i@@@Z@Z ; HashTableConstructor
	add	esp, 16					; 00000010H

; 167  : 
; 168  : 	if (table.Status != HASH_TABLE_ERR_NO_ERRORS)

	cmp	DWORD PTR _table$[ebp+12], 0
	jne	$clear_and_return$32

; 169  : 		CLEAR_AND_RETURN;
; 170  : 
; 171  : 	TextConstructor(&text, DefaultWordsCapacity, TextsCount);

	push	42					; 0000002aH
	lea	eax, DWORD PTR _text$[ebp]
	push	1000000					; 000f4240H
	push	eax
	call	?TextConstructor@@YAHPAUTextAnalyzer@@II@Z ; TextConstructor
	add	esp, 12					; 0000000cH

; 172  : 
; 173  : 	if (text.Status != TEXT_ERR_NO_ERRORS)

	cmp	DWORD PTR _text$[ebp+24], 0
	jne	$clear_and_return$32

; 174  : 		CLEAR_AND_RETURN;
; 175  : 
; 176  : 	TextParseIntoWordsDirectory_32(&text, "tests\\*.txt", MaximumWordSize);

	push	16					; 00000010H
	lea	eax, DWORD PTR _text$[ebp]
	push	OFFSET ??_C@_0M@NJFEAFHH@tests?2?$CK?4txt@
	push	eax
	call	?TextParseIntoWordsDirectory_32@@YAXPAUTextAnalyzer@@PBDI@Z ; TextParseIntoWordsDirectory_32

; 177  : 
; 178  : 	if (ConvertWordsType(&words, &text) != HASH_TABLE_ERR_NO_ERRORS)

	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	lea	eax, DWORD PTR _words$[ebp]
	push	eax
	call	?ConvertWordsType@@YAHPAUWordsArray128@@PAUTextAnalyzer@@@Z ; ConvertWordsType
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $clear_and_return$32

; 179  : 		CLEAR_AND_RETURN;
; 180  : 
; 181  : 	if (table.Status != HASH_TABLE_ERR_NO_ERRORS)

	cmp	DWORD PTR _table$[ebp+12], eax
	jne	SHORT $clear_and_return$32

; 182  : 		CLEAR_AND_RETURN;
; 183  : 
; 184  : 	HashTableLoadWordsIntoTable(&table, &words);

	lea	eax, DWORD PTR _words$[ebp]
	push	eax
	lea	eax, DWORD PTR _table$[ebp]
	push	eax
	call	?HashTableLoadWordsIntoTable@@YAXPAUHashTable@@PAUWordsArray128@@@Z ; HashTableLoadWordsIntoTable
	add	esp, 8

; 185  : 
; 186  : 	if (table.Status != HASH_TABLE_ERR_NO_ERRORS)

	cmp	DWORD PTR _table$[ebp+12], 0
	jne	SHORT $clear_and_return$32

; 187  : 		CLEAR_AND_RETURN;
; 188  : 
; 189  : 	{
; 190  : 		const size_t wordsCount = words.Size;
; 191  : 	
; 192  : 		for (size_t st1 = 0; st1 < 1000; st1++)

	xor	edi, edi
	mov	DWORD PTR _st1$1$[ebp], edi
	npad	4
$LL4@TestHashTa:

; 193  : 		{
; 194  : 			for (size_t st = 0; st < wordsCount; st++)

	xor	esi, esi
	cmp	DWORD PTR _words$[ebp+4], esi
	jbe	SHORT $LN6@TestHashTa
	mov	edi, DWORD PTR _words$[ebp]
	npad	6
$LL7@TestHashTa:

; 195  : 			{
; 196  : 				__m128i* word = HashTableFind(&table, &words.Data[st]);

	lea	eax, DWORD PTR _table$[ebp]
	push	edi
	push	eax
	call	?HashTableFind@@YAPAT__m128i@@PBUHashTable@@PBT1@@Z ; HashTableFind
	add	esp, 8

; 197  : 
; 198  : 				if (word == nullptr)

	test	eax, eax
	je	SHORT $LN23@TestHashTa

; 193  : 		{
; 194  : 			for (size_t st = 0; st < wordsCount; st++)

	inc	esi
	add	edi, 16					; 00000010H
	cmp	esi, DWORD PTR _words$[ebp+4]
	jb	SHORT $LL7@TestHashTa
	mov	edi, DWORD PTR _st1$1$[ebp]
$LN6@TestHashTa:

; 201  : 					CLEAR_AND_RETURN;
; 202  : 				}
; 203  : 			}
; 204  : 			printf("%zd\n", st1);

	push	edi
	push	OFFSET ??_C@_04IBEPGDBI@?$CFzd?6@
	call	_printf
	inc	edi
	add	esp, 8
	mov	DWORD PTR _st1$1$[ebp], edi
	cmp	edi, 1000				; 000003e8H
	jb	SHORT $LL4@TestHashTa

; 187  : 		CLEAR_AND_RETURN;
; 188  : 
; 189  : 	{
; 190  : 		const size_t wordsCount = words.Size;
; 191  : 	
; 192  : 		for (size_t st1 = 0; st1 < 1000; st1++)

	jmp	SHORT $clear_and_return$32
$LN23@TestHashTa:

; 199  : 				{
; 200  : 					puts("Error");

	push	OFFSET ??_C@_05NAOIJFC@Error@
	call	DWORD PTR __imp__puts
	add	esp, 4
$clear_and_return$32:

; 205  : 		}
; 206  : 	}
; 207  : 
; 208  : clear_and_return:
; 209  : 
; 210  : 	HashTableDestructor(&table);

	lea	eax, DWORD PTR _table$[ebp]
	push	eax
	call	?HashTableDestructor@@YAHPAUHashTable@@@Z ; HashTableDestructor

; 211  : 	TextDestructor(&text);

	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	?TextDestructor@@YAXPAUTextAnalyzer@@@Z	; TextDestructor

; 212  : 	WordsArrayDestructor(&words);

	lea	eax, DWORD PTR _words$[ebp]
	push	eax
	call	?WordsArrayDestructor@@YAXPAUWordsArray128@@@Z ; WordsArrayDestructor

; 213  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	xor	ecx, ebp
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?TestHashTable_OptimizationFind@@YAXXZ ENDP		; TestHashTable_OptimizationFind
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\HashTable\HashTable_UnitTests.cpp
;	COMDAT ?TestHashTable_Sheakspear@@YAXXZ
_TEXT	SEGMENT
_hashFunctions$ = -132					; size = 24
_words$ = -108						; size = 8
_outFile$1$ = -100					; size = 4
_listCount$1$ = -96					; size = 4
tv547 = -92						; size = 4
_funcIndex$1$ = -92					; size = 4
tv555 = -88						; size = 4
_listIndex$1$ = -88					; size = 4
_hash_data$1$ = -84					; size = 4
_table$ = -80						; size = 24
_text$ = -48						; size = 28
__$ArrayPad$ = -4					; size = 4
?TestHashTable_Sheakspear@@YAXXZ PROC			; TestHashTable_Sheakspear, COMDAT

; 66   : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 67   : 	HashTable     table = {};
; 68   : 
; 69   : 	TextAnalyzer  text  = {};
; 70   : 
; 71   : 	WordsArray128 words = {};
; 72   : 
; 73   : 	const size_t functionsCount = 6;
; 74   : 
; 75   : 	size_t (*hashFunctions[functionsCount])(const ListType*) =
; 76   : 	{
; 77   : 		HashTable_HashConstant,
; 78   : 		HashTable_HashLetter,
; 79   : 		HashTable_HashLength,
; 80   : 		HashTable_HashCharSum,
; 81   : 		HashTable_HashRor,
; 82   : 		HashTable_HashCRC32_C
; 83   : 	};
; 84   : 
; 85   : 	size_t* hash_data = nullptr;
; 86   : 
; 87   : 	FILE*   outFile   = nullptr;
; 88   : 
; 89   : 	HashTableConstructor(&table, DefaultListCount, DefaultListCapacity, HashTable_HashCRC32_C);

	push	OFFSET ?HashTable_HashCRC32_C@@YAIPBT__m128i@@@Z ; HashTable_HashCRC32_C
	xorps	xmm0, xmm0
	mov	DWORD PTR _text$[ebp+24], 0
	push	1000					; 000003e8H
	lea	eax, DWORD PTR _table$[ebp]
	movaps	XMMWORD PTR _table$[ebp], xmm0
	push	1500					; 000005dcH
	push	eax
	movq	QWORD PTR _table$[ebp+16], xmm0
	movaps	XMMWORD PTR _text$[ebp], xmm0
	movq	QWORD PTR _text$[ebp+16], xmm0
	movlpd	QWORD PTR _words$[ebp], xmm0
	mov	DWORD PTR _hashFunctions$[ebp], OFFSET ?HashTable_HashConstant@@YAIPBT__m128i@@@Z ; HashTable_HashConstant
	mov	DWORD PTR _hashFunctions$[ebp+4], OFFSET ?HashTable_HashLetter@@YAIPBT__m128i@@@Z ; HashTable_HashLetter
	mov	DWORD PTR _hashFunctions$[ebp+8], OFFSET ?HashTable_HashLength@@YAIPBT__m128i@@@Z ; HashTable_HashLength
	mov	DWORD PTR _hashFunctions$[ebp+12], OFFSET ?HashTable_HashCharSum@@YAIPBT__m128i@@@Z ; HashTable_HashCharSum
	mov	DWORD PTR _hashFunctions$[ebp+16], OFFSET ?HashTable_HashRor@@YAIPBT__m128i@@@Z ; HashTable_HashRor
	mov	DWORD PTR _hashFunctions$[ebp+20], OFFSET ?HashTable_HashCRC32_C@@YAIPBT__m128i@@@Z ; HashTable_HashCRC32_C
	call	?HashTableConstructor@@YAHPAUHashTable@@IIP6AIPBT__m128i@@@Z@Z ; HashTableConstructor
	add	esp, 16					; 00000010H

; 90   : 
; 91   : 	if (table.Status != HASH_TABLE_ERR_NO_ERRORS)

	cmp	DWORD PTR _table$[ebp+12], 0
	jne	$LN55@TestHashTa

; 92   : 		CLEAR_AND_RETURN;
; 93   : 
; 94   : 	TextConstructor(&text, DefaultWordsCapacity, TextsCount);

	push	42					; 0000002aH
	lea	eax, DWORD PTR _text$[ebp]
	push	1000000					; 000f4240H
	push	eax
	call	?TextConstructor@@YAHPAUTextAnalyzer@@II@Z ; TextConstructor
	add	esp, 12					; 0000000cH

; 95   : 
; 96   : 	if (text.Status != TEXT_ERR_NO_ERRORS)

	cmp	DWORD PTR _text$[ebp+24], 0
	jne	$LN55@TestHashTa

; 97   : 		CLEAR_AND_RETURN;
; 98   : 
; 99   : 	TextParseIntoWordsDirectory_32(&text, "tests\\*.txt", 32);

	push	32					; 00000020H
	lea	eax, DWORD PTR _text$[ebp]
	push	OFFSET ??_C@_0M@NJFEAFHH@tests?2?$CK?4txt@
	push	eax
	call	?TextParseIntoWordsDirectory_32@@YAXPAUTextAnalyzer@@PBDI@Z ; TextParseIntoWordsDirectory_32
	add	esp, 12					; 0000000cH

; 100  : 
; 101  : 	if (text.Status != HASH_TABLE_ERR_NO_ERRORS)

	cmp	DWORD PTR _text$[ebp+24], 0
	jne	$LN55@TestHashTa

; 102  : 		CLEAR_AND_RETURN;
; 103  : 
; 104  : 	if (ConvertWordsType(&words, &text) != HASH_TABLE_ERR_NO_ERRORS)

	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	lea	eax, DWORD PTR _words$[ebp]
	push	eax
	call	?ConvertWordsType@@YAHPAUWordsArray128@@PAUTextAnalyzer@@@Z ; ConvertWordsType
	add	esp, 8
	test	eax, eax
	jne	$LN55@TestHashTa

; 105  : 		CLEAR_AND_RETURN;
; 106  : 
; 107  : 	outFile = fopen("hash_statistic_list.csv", "w");

	push	OFFSET ??_C@_01NOFIACDB@w@
	push	OFFSET ??_C@_0BI@LNKAJNEN@hash_statistic_list?4csv@
	call	DWORD PTR __imp__fopen
	mov	edi, eax
	add	esp, 8
	mov	DWORD PTR _outFile$1$[ebp], edi

; 108  : 
; 109  : 	if (!outFile)

	test	edi, edi
	je	$LN55@TestHashTa

; 110  : 		CLEAR_AND_RETURN;
; 111  : 
; 112  : 	hash_data = (size_t*)calloc(functionsCount * table.ListCount, sizeof(size_t));

	mov	eax, DWORD PTR _table$[ebp+4]
	xor	ecx, ecx
	mov	edx, 6
	mul	edx
	push	4
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	DWORD PTR __imp__calloc
	add	esp, 8
	mov	DWORD PTR _hash_data$1$[ebp], eax

; 113  : 
; 114  : 	if (!hash_data)

	test	eax, eax
	je	$clear_and_return$58

; 115  : 		CLEAR_AND_RETURN;
; 116  : 
; 117  : 	{
; 118  : 		const size_t listCount = table.ListCount;

	mov	eax, DWORD PTR _table$[ebp+4]
	xor	esi, esi
	mov	edi, DWORD PTR _hash_data$1$[ebp]
	mov	DWORD PTR _listCount$1$[ebp], eax
	shl	eax, 2
	mov	DWORD PTR tv555[ebp], eax
	npad	8
$LL4@TestHashTa:

; 119  : 
; 120  : 		for (size_t funcIndex = 0; funcIndex < functionsCount; funcIndex++)
; 121  : 		{
; 122  : 			table.HashFunction = hashFunctions[funcIndex];

	mov	eax, DWORD PTR _hashFunctions$[ebp+esi*4]
	mov	DWORD PTR _table$[ebp], eax

; 123  : 
; 124  : 			HashTableLoadWordsIntoTable(&table, &words);

	lea	eax, DWORD PTR _words$[ebp]
	push	eax
	lea	eax, DWORD PTR _table$[ebp]
	push	eax
	call	?HashTableLoadWordsIntoTable@@YAXPAUHashTable@@PAUWordsArray128@@@Z ; HashTableLoadWordsIntoTable

; 125  : 
; 126  : 			printf("Hash function %zd loaded.\n", funcIndex + 1);

	lea	eax, DWORD PTR [esi+1]
	push	eax
	mov	esi, eax
	push	OFFSET ??_C@_0BL@MGLKJJGI@Hash?5function?5?$CFzd?5loaded?4?6@
	mov	DWORD PTR _funcIndex$1$[ebp], esi
	call	_printf
	add	esp, 16					; 00000010H

; 127  : 
; 128  : 			for (size_t listIndex = 0; listIndex < listCount; listIndex++)

	cmp	DWORD PTR _listCount$1$[ebp], 0
	jbe	SHORT $LN6@TestHashTa

; 129  : 			{
; 130  : 				hash_data[funcIndex * listCount + listIndex] = table.Lists[listIndex].Size;

	mov	edx, DWORD PTR _table$[ebp+8]
	mov	ecx, edi
	mov	esi, DWORD PTR _listCount$1$[ebp]
	add	edx, 16					; 00000010H
	npad	2
$LL7@TestHashTa:
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx-4], eax
	lea	edx, DWORD PTR [edx+32]
	sub	esi, 1
	jne	SHORT $LL7@TestHashTa
	mov	esi, DWORD PTR _funcIndex$1$[ebp]
$LN6@TestHashTa:

; 131  : 			}
; 132  : 
; 133  : 			HashTableClearLists(&table);

	lea	eax, DWORD PTR _table$[ebp]
	push	eax
	call	?HashTableClearLists@@YAXPAUHashTable@@@Z ; HashTableClearLists
	add	edi, DWORD PTR tv555[ebp]
	add	esp, 4
	cmp	esi, 6
	jb	SHORT $LL4@TestHashTa

; 134  : 		}
; 135  : 
; 136  : 		for (size_t funcIndex = 0; funcIndex < functionsCount; funcIndex++)

	mov	edi, DWORD PTR _outFile$1$[ebp]
	xor	esi, esi
	npad	4
$LL10@TestHashTa:

; 137  : 			fprintf(outFile, "hash%zd, ", funcIndex + 1);

	inc	esi
	push	esi
	push	OFFSET ??_C@_09PLEPEFIC@hash?$CFzd?0?5@
	push	edi
	call	_fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, 6
	jb	SHORT $LL10@TestHashTa

; 138  : 
; 139  : 		fputc('\n', outFile);

	push	edi
	push	10					; 0000000aH
	call	DWORD PTR __imp__fputc

; 140  : 
; 141  : 		for (size_t listIndex = 0; listIndex < table.ListCount; listIndex++)

	mov	eax, DWORD PTR _hash_data$1$[ebp]
	add	esp, 8
	cmp	DWORD PTR _table$[ebp+4], 0
	mov	DWORD PTR _listIndex$1$[ebp], 0
	jbe	SHORT $clear_and_return$58

; 138  : 
; 139  : 		fputc('\n', outFile);

	mov	DWORD PTR tv547[ebp], eax
$LL13@TestHashTa:

; 142  : 		{
; 143  : 			for (size_t funcIndex = 0; funcIndex < functionsCount; funcIndex++)

	mov	esi, eax
	mov	edi, 6
	npad	5
$LL16@TestHashTa:

; 144  : 				fprintf(outFile, "%zd, ", hash_data[funcIndex * listCount + listIndex]);

	push	DWORD PTR [esi]
	push	OFFSET ??_C@_05LKKJMJMF@?$CFzd?0?5@
	push	DWORD PTR _outFile$1$[ebp]
	call	_fprintf
	mov	ecx, DWORD PTR _listCount$1$[ebp]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR [ecx*4]
	add	esi, eax
	sub	edi, 1
	jne	SHORT $LL16@TestHashTa

; 145  : 
; 146  : 			fputc('\n', outFile);

	push	DWORD PTR _outFile$1$[ebp]
	push	10					; 0000000aH
	call	DWORD PTR __imp__fputc
	mov	ecx, DWORD PTR _listIndex$1$[ebp]
	add	esp, 8
	mov	eax, DWORD PTR tv547[ebp]
	inc	ecx
	add	eax, 4
	mov	DWORD PTR _listIndex$1$[ebp], ecx
	mov	DWORD PTR tv547[ebp], eax
	cmp	ecx, DWORD PTR _table$[ebp+4]
	jb	SHORT $LL13@TestHashTa

; 108  : 
; 109  : 	if (!outFile)

	mov	eax, DWORD PTR _hash_data$1$[ebp]
	jmp	SHORT $clear_and_return$58
$LN55@TestHashTa:

; 147  : 		}
; 148  : 	}
; 149  : 
; 150  : clear_and_return:
; 151  : 
; 152  : 	free(hash_data);

	xor	eax, eax
$clear_and_return$58:
	push	eax
	call	DWORD PTR __imp__free

; 153  : 	HashTableDestructor(&table);

	lea	eax, DWORD PTR _table$[ebp]
	push	eax
	call	?HashTableDestructor@@YAHPAUHashTable@@@Z ; HashTableDestructor

; 154  : 	TextDestructor(&text);

	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	?TextDestructor@@YAXPAUTextAnalyzer@@@Z	; TextDestructor

; 155  : 	WordsArrayDestructor(&words);

	lea	eax, DWORD PTR _words$[ebp]
	push	eax
	call	?WordsArrayDestructor@@YAXPAUWordsArray128@@@Z ; WordsArrayDestructor

; 156  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 16					; 00000010H
	xor	ecx, ebp
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?TestHashTable_Sheakspear@@YAXXZ ENDP			; TestHashTable_Sheakspear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

	push	ebp
	mov	ebp, esp

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);
; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H

; 961  :         __crt_va_end(_ArgList);
; 962  :         return _Result;
; 963  :     }

	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Stream$[ebp]

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);
; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	DWORD PTR __Format$[ebp]
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H

; 842  :         __crt_va_end(_ArgList);
; 843  :         return _Result;
; 844  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

	push	ebp
	mov	ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 646  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
