; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31105.0 

	TITLE	D:\Language C\HashTable\HashTable\Release\Text.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?TextConstructor@@YAHPAUTextAnalyzer@@II@Z	; TextConstructor
PUBLIC	?TextReadFile@@YAHPAUTextAnalyzer@@PBD@Z	; TextReadFile
PUBLIC	?TextDestructor@@YAXPAUTextAnalyzer@@@Z		; TextDestructor
PUBLIC	??_C@_0DA@BFHEBCEK@D?3?2Language?5C?2HashTable?2HashTab@ ; `string'
PUBLIC	??_C@_0FJ@LGAEIDEK@int?5__cdecl?5TextConstructor?$CIstr@ ; `string'
PUBLIC	??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@ ; `string'
PUBLIC	??_C@_0DN@OIMHOGMJ@int?5__cdecl?5TextReadFile?$CIstruct@ ; `string'
PUBLIC	??_C@_0DN@IDDDHHGD@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?r?e?j?q?r?5?b?5?g?$OA?o?n?k?m@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0BL@FFNDJPJA@?N?x?h?a?j?$OA?5?n?r?j?p?$PL?r?h?$PP?5?t?$OA?i?k?$OA?5?$CC?$CFs?$CC@ ; `string'
PUBLIC	??_C@_0BJ@JLPNHHCA@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h?4@ ; `string'
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fread:PROC
EXTRN	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z:PROC ; LogLine
EXTRN	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ:PROC ; LogFLine
EXTRN	?GetFileSize@@YAIPAU_iobuf@@@Z:PROC		; GetFileSize
;	COMDAT ??_C@_0BJ@JLPNHHCA@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h?4@
CONST	SEGMENT
??_C@_0BJ@JLPNHHCA@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h?4@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0e2H, 0fbH, 0e4H, 0e5H, 0ebH
	DB	0e5H, 0edH, 0e8H, 0ffH, ' ', 0efH, 0e0H, 0ecH, 0ffH, 0f2H, 0e8H
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FFNDJPJA@?N?x?h?a?j?$OA?5?n?r?j?p?$PL?r?h?$PP?5?t?$OA?i?k?$OA?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0BL@FFNDJPJA@?N?x?h?a?j?$OA?5?n?r?j?p?$PL?r?h?$PP?5?t?$OA?i?k?$OA?5?$CC?$CFs?$CC@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0eeH, 0f2H, 0eaH, 0f0H, 0fbH
	DB	0f2H, 0e8H, 0ffH, ' ', 0f4H, 0e0H, 0e9H, 0ebH, 0e0H, ' "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IDDDHHGD@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?r?e?j?q?r?5?b?5?g?$OA?o?n?k?m@
CONST	SEGMENT
??_C@_0DN@IDDDHHGD@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?r?e?j?q?r?5?b?5?g?$OA?o?n?k?m@ DB 0cfH
	DB	0eeH, 0efH, 0fbH, 0f2H, 0eaH, 0e0H, ' ', 0e4H, 0eeH, 0e1H, 0e0H
	DB	0e2H, 0e8H, 0f2H, 0fcH, ' ', 0f2H, 0e5H, 0eaH, 0f1H, 0f2H, ' ', 0e2H
	DB	' ', 0e7H, 0e0H, 0efH, 0eeH, 0ebH, 0edH, 0e5H, 0edH, 0edH, 0f3H
	DB	0feH, ' ', 0f1H, 0f2H, 0f0H, 0f3H, 0eaH, 0f2H, 0f3H, 0f0H, 0f3H
	DB	' TextAnalyzer.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@OIMHOGMJ@int?5__cdecl?5TextReadFile?$CIstruct@
CONST	SEGMENT
??_C@_0DN@OIMHOGMJ@int?5__cdecl?5TextReadFile?$CIstruct@ DB 'int __cdecl '
	DB	'TextReadFile(struct TextAnalyzer *,const char *)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
CONST	SEGMENT
??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0e2H, 0fbH, 0e4H, 0e5H, 0ebH
	DB	0e5H, 0edH, 0e8H, 0ffH, ' ', 0efH, 0e0H, 0ecH, 0ffH, 0f2H, 0e8H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@LGAEIDEK@int?5__cdecl?5TextConstructor?$CIstr@
CONST	SEGMENT
??_C@_0FJ@LGAEIDEK@int?5__cdecl?5TextConstructor?$CIstr@ DB 'int __cdecl '
	DB	'TextConstructor(struct TextAnalyzer *,const unsigned int,cons'
	DB	't unsigned int)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BFHEBCEK@D?3?2Language?5C?2HashTable?2HashTab@
CONST	SEGMENT
??_C@_0DA@BFHEBCEK@D?3?2Language?5C?2HashTable?2HashTab@ DB 'D:\Language '
	DB	'C\HashTable\HashTable\Text\Text.cpp', 00H	; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\Text\Text.cpp
;	COMDAT ?TextDestructor@@YAXPAUTextAnalyzer@@@Z
_TEXT	SEGMENT
_text$ = 8						; size = 4
?TextDestructor@@YAXPAUTextAnalyzer@@@Z PROC		; TextDestructor, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp

; 53   : 	
; 54   : 	Text* texts = text->Texts;
; 55   : 
; 56   : 	for (size_t st = 0; st < textsCount; st++)

	mov	eax, DWORD PTR __imp__free
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _text$[ebp]
	mov	ebx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [edi+8]
	test	ebx, ebx
	je	SHORT $LN3@TextDestru

; 50   : 	assert(text);
; 51   : 
; 52   : 	const size_t textsCount = text->TextsCount;

	add	esi, 4
	npad	5
$LL4@TextDestru:

; 57   : 	{
; 58   : 		free(texts[st].Data);

	push	DWORD PTR [esi]
	call	eax
	mov	eax, DWORD PTR __imp__free
	lea	esi, DWORD PTR [esi+8]
	add	esp, 4

; 59   : 
; 60   : 		texts[st].Size  = 0;

	mov	DWORD PTR [esi-12], 0

; 61   : 		texts[st].Data  = nullptr;

	mov	DWORD PTR [esi-8], 0
	sub	ebx, 1
	jne	SHORT $LL4@TextDestru
$LN3@TextDestru:

; 62   : 	}
; 63   : 
; 64   : 	free(text->Texts);

	push	DWORD PTR [edi+8]
	call	eax

; 65   : 
; 66   : 	text->TextsCount    = 0;
; 67   : 	text->Texts         = nullptr;
; 68   : 
; 69   : 	free(text->Words);

	push	DWORD PTR [edi+20]
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
	call	DWORD PTR __imp__free
	add	esp, 8

; 70   : 
; 71   : 	text->WordsCapacity = 0;

	mov	DWORD PTR [edi+16], 0

; 72   : 	text->WordsSize     = 0;

	mov	DWORD PTR [edi+12], 0

; 73   : 
; 74   : 	text->Status        = TEXT_ERR_NO_ERRORS;

	mov	DWORD PTR [edi+24], 0
	pop	edi
	pop	esi
	pop	ebx

; 75   : }

	pop	ebp
	ret	0
?TextDestructor@@YAXPAUTextAnalyzer@@@Z ENDP		; TextDestructor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\Text\Text.cpp
;	COMDAT ?TextReadFile@@YAHPAUTextAnalyzer@@PBD@Z
_TEXT	SEGMENT
_buffer$1$ = -4						; size = 4
_textsSize$1$ = 8					; size = 4
_text$ = 8						; size = 4
_fileName$ = 12						; size = 4
?TextReadFile@@YAHPAUTextAnalyzer@@PBD@Z PROC		; TextReadFile, COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 82   : 	assert(text);
; 83   : 	assert(fileName);
; 84   : 
; 85   : 	const size_t textsSize = text->TextsSize;

	mov	esi, DWORD PTR _text$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _textsSize$1$[ebp], eax

; 86   : 
; 87   : 	if (textsSize > text->TextsCount)

	cmp	eax, DWORD PTR [esi+4]
	jbe	SHORT $LN2@TextReadFi

; 88   : 	{
; 89   : 		LOG_ERR("Попытка добавить текст в заполненную структуру TextAnalyzer.");

	push	89					; 00000059H
	push	OFFSET ??_C@_0DA@BFHEBCEK@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0DN@OIMHOGMJ@int?5__cdecl?5TextReadFile?$CIstruct@
	push	1
	push	0
	push	4
	push	OFFSET ??_C@_0DN@IDDDHHGD@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?r?e?j?q?r?5?b?5?g?$OA?o?n?k?m@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine
	add	esp, 28					; 0000001cH

; 90   : 
; 91   : 		text->Status = TEXT_ERR_OVERFLOW;

	mov	DWORD PTR [esi+24], 8

; 92   : 
; 93   : 		return text->Status;

	mov	eax, 8
	pop	esi

; 130  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@TextReadFi:
	push	ebx

; 94   : 	}
; 95   : 
; 96   : 	FILE* file = fopen(fileName, "r");

	mov	ebx, DWORD PTR _fileName$[ebp]
	push	edi
	push	OFFSET ??_C@_01KDCPPGHE@r@
	push	ebx
	call	DWORD PTR __imp__fopen
	mov	edi, eax
	add	esp, 8

; 97   : 
; 98   : 	if (!file)

	test	edi, edi
	jne	SHORT $LN3@TextReadFi

; 99   : 	{
; 100  : 		LOG_F_ERR("Ошибка открытия файла \"%s\"", fileName);

	push	ebx
	push	OFFSET ??_C@_0BL@FFNDJPJA@?N?x?h?a?j?$OA?5?n?r?j?p?$PL?r?h?$PP?5?t?$OA?i?k?$OA?5?$CC?$CFs?$CC@
	push	100					; 00000064H
	push	OFFSET ??_C@_0DA@BFHEBCEK@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0DN@OIMHOGMJ@int?5__cdecl?5TextReadFile?$CIstruct@
	push	1
	push	eax
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine
	add	esp, 32					; 00000020H

; 101  : 
; 102  : 		text->Status = TEXT_ERR_FILE;

	mov	DWORD PTR [esi+24], 4

; 103  : 
; 104  : 		return text->Status;

	lea	eax, DWORD PTR [edi+4]
	pop	edi
	pop	ebx
	pop	esi

; 130  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@TextReadFi:

; 105  : 	}
; 106  : 
; 107  : 	const size_t fileSize = GetFileSize(file);

	push	edi
	call	?GetFileSize@@YAIPAU_iobuf@@@Z		; GetFileSize
	mov	ebx, eax

; 108  : 
; 109  : 	char* buffer = (char*)calloc(fileSize + 1, sizeof(char));

	xor	edx, edx
	mov	ecx, ebx
	add	ecx, 1
	push	1
	setb	dl
	neg	edx
	or	edx, ecx
	push	edx
	call	DWORD PTR __imp__calloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buffer$1$[ebp], eax

; 110  : 
; 111  : 	if (!buffer)

	test	eax, eax
	jne	SHORT $LN4@TextReadFi

; 112  : 	{
; 113  : 		LOG_ERR("Ошибка выделения памяти.");

	push	113					; 00000071H
	push	OFFSET ??_C@_0DA@BFHEBCEK@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0DN@OIMHOGMJ@int?5__cdecl?5TextReadFile?$CIstruct@
	push	1
	push	eax
	push	4
	push	OFFSET ??_C@_0BJ@JLPNHHCA@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h?4@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine
	add	esp, 28					; 0000001cH

; 114  : 
; 115  : 		text->Status = TEXT_ERR_MEMORY;

	mov	DWORD PTR [esi+24], 2

; 116  : 
; 117  : 		return text->Status;

	mov	eax, 2
	pop	edi
	pop	ebx
	pop	esi

; 130  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@TextReadFi:

; 118  : 	}
; 119  : 
; 120  : 	size_t readed = fread(buffer, sizeof(char), fileSize, file);

	push	edi
	push	ebx
	push	1
	push	eax
	call	DWORD PTR __imp__fread

; 121  : 
; 122  : 	fclose(file);

	push	edi
	call	DWORD PTR __imp__fclose

; 123  : 
; 124  : 	text->Texts[textsSize].Data = buffer;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _textsSize$1$[ebp]
	mov	edx, DWORD PTR _buffer$1$[ebp]
	pop	edi
	mov	DWORD PTR [eax+ecx*8+4], edx

; 125  : 	text->Texts[textsSize].Size = fileSize;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*8], ebx

; 126  : 
; 127  : 	text->TextsSize++;

	inc	DWORD PTR [esi]

; 128  : 
; 129  : 	return text->Status;

	mov	eax, DWORD PTR [esi+24]
	pop	ebx
	pop	esi

; 130  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TextReadFile@@YAHPAUTextAnalyzer@@PBD@Z ENDP		; TextReadFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\Text\Text.cpp
;	COMDAT ?TextConstructor@@YAHPAUTextAnalyzer@@II@Z
_TEXT	SEGMENT
_text$ = 8						; size = 4
_wordsCapacity$ = 12					; size = 4
_textsCapacity$ = 16					; size = 4
?TextConstructor@@YAHPAUTextAnalyzer@@II@Z PROC		; TextConstructor, COMDAT

; 13   : {

	push	ebp
	mov	ebp, esp

; 14   : 	assert(text);
; 15   : 	assert(textsCapacity);
; 16   : 	
; 17   : 	text->Status        = TEXT_ERR_NO_ERRORS;
; 18   : 
; 19   : 	text->TextsSize     = 0;
; 20   : 	text->TextsCount = textsCapacity;

	mov	eax, DWORD PTR _textsCapacity$[ebp]
	push	esi
	mov	esi, DWORD PTR _text$[ebp]

; 21   : 	text->Texts         = (Text*)calloc(textsCapacity, sizeof(Text));

	push	8
	push	eax
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	mov	DWORD PTR [esi+8], eax

; 22   : 
; 23   : 	if (!text->Texts)

	test	eax, eax
	jne	SHORT $LN2@TextConstr

; 24   : 	{
; 25   : 		LOG_ERR_MEMORY;

	push	25					; 00000019H
$LN5@TextConstr:

; 46   : }

	push	OFFSET ??_C@_0DA@BFHEBCEK@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0FJ@LGAEIDEK@int?5__cdecl?5TextConstructor?$CIstr@
	push	1
	push	0
	push	4
	push	OFFSET ??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine
	mov	eax, DWORD PTR [esi+24]
	add	esp, 28					; 0000001cH
	or	eax, 2
	mov	DWORD PTR [esi+24], eax
	pop	esi
	pop	ebp
	ret	0
$LN2@TextConstr:

; 26   : 
; 27   : 		text->Status |= TEXT_ERR_MEMORY;
; 28   : 		
; 29   : 		return text->Status;
; 30   : 	}
; 31   : 							    
; 32   : 	text->WordsSize     = 0;
; 33   : 	text->WordsCapacity = wordsCapacity;

	mov	eax, DWORD PTR _wordsCapacity$[ebp]

; 34   : 	text->Words         = (Word*)calloc(wordsCapacity, sizeof(Word));

	push	8
	push	eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	mov	DWORD PTR [esi+20], eax

; 35   : 
; 36   : 	if (!text->Words)

	test	eax, eax
	jne	SHORT $LN3@TextConstr

; 37   : 	{
; 38   : 		LOG_ERR_MEMORY;

	push	38					; 00000026H

; 39   : 
; 40   : 		text->Status |= TEXT_ERR_MEMORY;
; 41   : 
; 42   : 		return text->Status;

	jmp	SHORT $LN5@TextConstr
$LN3@TextConstr:

; 43   : 	}
; 44   : 
; 45   : 	return text->Status;

	mov	eax, DWORD PTR [esi+24]
	pop	esi

; 46   : }

	pop	ebp
	ret	0
?TextConstructor@@YAHPAUTextAnalyzer@@II@Z ENDP		; TextConstructor
_TEXT	ENDS
END
