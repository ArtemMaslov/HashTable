; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31105.0 

	TITLE	D:\Language C\HashTable\HashTable\Release\List_Verify.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?GraphHeaderBegin@@3PBDB			; GraphHeaderBegin
PUBLIC	??_C@_0BML@DHNEPMJC@digraph?5G?6?$HL?6?7graph?$FLdpi?5?$DN?5100?$FN?$DL?6@ ; `string'
PUBLIC	?GraphHeaderNodeInt@@3PBDB			; GraphHeaderNodeInt
PUBLIC	??_C@_0BP@NPCAFBCA@?7?7?$CFs?$FLlabel?5?5?5?5?$DN?5?$CC?$CFs?5?2n?5?$CFzd?$CC?$FN?$DL?6@ ; `string'
PUBLIC	?GraphHeaderNodeStr@@3PBDB			; GraphHeaderNodeStr
PUBLIC	??_C@_0BO@OJIMPGHJ@?7?7?$CFs?$FLlabel?5?5?5?5?$DN?5?$CC?$CFs?5?2n?5?$CFs?$CC?$FN?$DL?6@ ; `string'
PUBLIC	?GraphHeaderEnd@@3PBDB				; GraphHeaderEnd
PUBLIC	??_C@_04FKOAHPIO@?7?$HN?6?6@			; `string'
PUBLIC	?GraphListDataBegin@@3PBDB			; GraphListDataBegin
PUBLIC	??_C@_0CH@OAOIFOMJ@?7?$HL?6?7?7rankdir?5?$DN?5LR?$DL?6?7?7rank?5?5?5?5?$DN?5@ ; `string'
PUBLIC	?GraphListDataEnd@@3PBDB			; GraphListDataEnd
PUBLIC	??_C@_0IF@LIOMBPHL@?7?$HN?6?6?7?$HL?6?7?7rank?5?$DN?5max?$DL?6?7?7maxNode?$FL@ ; `string'
PUBLIC	?PrevEdgeColor@@3PBDB				; PrevEdgeColor
PUBLIC	??_C@_0DB@HLOEBEIP@?7edge?5?$FLcolor?5?$DN?5?$CC?$CD4ECDC4?$CC?0?5const@ ; `string'
PUBLIC	?NextEdgeColor@@3PBDB				; NextEdgeColor
PUBLIC	??_C@_0DB@MGFNIKHM@?7edge?5?$FLcolor?5?$DN?5?$CC?$CDC7F464?$CC?0?5const@ ; `string'
PUBLIC	?ListHeaderEdgeColor@@3PBDB			; ListHeaderEdgeColor
PUBLIC	??_C@_0DB@MMBHBDCG@?7edge?5?$FLcolor?5?$DN?5?$CC?$CDFF3E50?$CC?0?5const@ ; `string'
PUBLIC	?ListConstraint@@3PBDB				; ListConstraint
PUBLIC	??_C@_0CM@GJMNPBGO@?7edge?5?$FLstyle?5?$DN?5invis?0?5constrain@ ; `string'
PUBLIC	?EdgeFormatIntInt@@3PBDB			; EdgeFormatIntInt
PUBLIC	??_C@_0BA@FIJJJDP@?7f?$CFzd?5?9?$DO?5f?$CFzd?$DL?6@ ; `string'
PUBLIC	?EdgeFormatStrInt@@3PBDB			; EdgeFormatStrInt
PUBLIC	??_C@_0O@DENNDLKA@?7?$CFs?5?9?$DO?5f?$CFzd?$DL?6@ ; `string'
PUBLIC	?EdgeFormatIntStr@@3PBDB			; EdgeFormatIntStr
PUBLIC	??_C@_0O@NHBPBNIO@?7f?$CFzd?5?9?$DO?5?$CFs?$DL?6@ ; `string'
PUBLIC	?NodeBegin@@3PBDB				; NodeBegin
PUBLIC	??_C@_0DD@MDPOPBHM@?7?7f?$CFzd?5?$FLlabel?5?$DN?5?$CC?$HL?$HL?5?$DMl3?$DO?5index?5@ ; `string'
PUBLIC	?NodeEnd@@3PBDB					; NodeEnd
PUBLIC	??_C@_0DA@GCGKBMDP@?5?$HN?$HM?$HL?5?$DMl1?$DO?5prev?5?2n?5?$CFzd?5?$HM?5?$DMl2?$DO?5ne@ ; `string'
;	COMDAT ??_C@_0DA@GCGKBMDP@?5?$HN?$HM?$HL?5?$DMl1?$DO?5prev?5?2n?5?$CFzd?5?$HM?5?$DMl2?$DO?5ne@
CONST	SEGMENT
??_C@_0DA@GCGKBMDP@?5?$HN?$HM?$HL?5?$DMl1?$DO?5prev?5?2n?5?$CFzd?5?$HM?5?$DMl2?$DO?5ne@ DB ' '
	DB	'}|{ <l1> prev \n %zd | <l2> next \n %zd }}"];', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@MDPOPBHM@?7?7f?$CFzd?5?$FLlabel?5?$DN?5?$CC?$HL?$HL?5?$DMl3?$DO?5index?5@
CONST	SEGMENT
??_C@_0DD@MDPOPBHM@?7?7f?$CFzd?5?$FLlabel?5?$DN?5?$CC?$HL?$HL?5?$DMl3?$DO?5index?5@ DB 09H
	DB	09H, 'f%zd [label = "{{ <l3> index \n %zd }|{ value \n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NHBPBNIO@?7f?$CFzd?5?9?$DO?5?$CFs?$DL?6@
CONST	SEGMENT
??_C@_0O@NHBPBNIO@?7f?$CFzd?5?9?$DO?5?$CFs?$DL?6@ DB 09H, 'f%zd -> %s;', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DENNDLKA@?7?$CFs?5?9?$DO?5f?$CFzd?$DL?6@
CONST	SEGMENT
??_C@_0O@DENNDLKA@?7?$CFs?5?9?$DO?5f?$CFzd?$DL?6@ DB 09H, '%s -> f%zd;', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FIJJJDP@?7f?$CFzd?5?9?$DO?5f?$CFzd?$DL?6@
CONST	SEGMENT
??_C@_0BA@FIJJJDP@?7f?$CFzd?5?9?$DO?5f?$CFzd?$DL?6@ DB 09H, 'f%zd -> f%zd'
	DB	';', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@GJMNPBGO@?7edge?5?$FLstyle?5?$DN?5invis?0?5constrain@
CONST	SEGMENT
??_C@_0CM@GJMNPBGO@?7edge?5?$FLstyle?5?$DN?5invis?0?5constrain@ DB 09H, 'e'
	DB	'dge [style = invis, constraint = true];', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MMBHBDCG@?7edge?5?$FLcolor?5?$DN?5?$CC?$CDFF3E50?$CC?0?5const@
CONST	SEGMENT
??_C@_0DB@MMBHBDCG@?7edge?5?$FLcolor?5?$DN?5?$CC?$CDFF3E50?$CC?0?5const@ DB 09H
	DB	'edge [color = "#FF3E50", constraint = false];', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MGFNIKHM@?7edge?5?$FLcolor?5?$DN?5?$CC?$CDC7F464?$CC?0?5const@
CONST	SEGMENT
??_C@_0DB@MGFNIKHM@?7edge?5?$FLcolor?5?$DN?5?$CC?$CDC7F464?$CC?0?5const@ DB 09H
	DB	'edge [color = "#C7F464", constraint = false];', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HLOEBEIP@?7edge?5?$FLcolor?5?$DN?5?$CC?$CD4ECDC4?$CC?0?5const@
CONST	SEGMENT
??_C@_0DB@HLOEBEIP@?7edge?5?$FLcolor?5?$DN?5?$CC?$CD4ECDC4?$CC?0?5const@ DB 09H
	DB	'edge [color = "#4ECDC4", constraint = false];', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IF@LIOMBPHL@?7?$HN?6?6?7?$HL?6?7?7rank?5?$DN?5max?$DL?6?7?7maxNode?$FL@
CONST	SEGMENT
??_C@_0IF@LIOMBPHL@?7?$HN?6?6?7?$HL?6?7?7rank?5?$DN?5max?$DL?6?7?7maxNode?$FL@ DB 09H
	DB	'}', 0aH, 0aH, 09H, '{', 0aH, 09H, 09H, 'rank = max;', 0aH, 09H
	DB	09H, 'maxNode[label = "utilNode", style = invis];', 0aH, 09H, '}'
	DB	0aH, 0aH, 09H, 'minNode -> f0[style = invis]', 0aH, 09H, 'maxN'
	DB	'ode -> f0[style = invis]', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OAOIFOMJ@?7?$HL?6?7?7rankdir?5?$DN?5LR?$DL?6?7?7rank?5?5?5?5?$DN?5@
CONST	SEGMENT
??_C@_0CH@OAOIFOMJ@?7?$HL?6?7?7rankdir?5?$DN?5LR?$DL?6?7?7rank?5?5?5?5?$DN?5@ DB 09H
	DB	'{', 0aH, 09H, 09H, 'rankdir = LR;', 0aH, 09H, 09H, 'rank    ='
	DB	' same;', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FKOAHPIO@?7?$HN?6?6@
CONST	SEGMENT
??_C@_04FKOAHPIO@?7?$HN?6?6@ DB 09H, '}', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OJIMPGHJ@?7?7?$CFs?$FLlabel?5?5?5?5?$DN?5?$CC?$CFs?5?2n?5?$CFs?$CC?$FN?$DL?6@
CONST	SEGMENT
??_C@_0BO@OJIMPGHJ@?7?7?$CFs?$FLlabel?5?5?5?5?$DN?5?$CC?$CFs?5?2n?5?$CFs?$CC?$FN?$DL?6@ DB 09H
	DB	09H, '%s[label    = "%s \n %s"];', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NPCAFBCA@?7?7?$CFs?$FLlabel?5?5?5?5?$DN?5?$CC?$CFs?5?2n?5?$CFzd?$CC?$FN?$DL?6@
CONST	SEGMENT
??_C@_0BP@NPCAFBCA@?7?7?$CFs?$FLlabel?5?5?5?5?$DN?5?$CC?$CFs?5?2n?5?$CFzd?$CC?$FN?$DL?6@ DB 09H
	DB	09H, '%s[label    = "%s \n %zd"];', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BML@DHNEPMJC@digraph?5G?6?$HL?6?7graph?$FLdpi?5?$DN?5100?$FN?$DL?6@
CONST	SEGMENT
??_C@_0BML@DHNEPMJC@digraph?5G?6?$HL?6?7graph?$FLdpi?5?$DN?5100?$FN?$DL?6@ DB 'd'
	DB	'igraph G', 0aH, '{', 0aH, 09H, 'graph[dpi = 100];', 0aH, 09H, 's'
	DB	'plines   = ortho;', 0aH, 09H, 'ranksep   = 1;', 0aH, 09H, 'bg'
	DB	'color   = "#303030";', 0aH, 0aH, 09H, 'edge', 0aH, 09H, '[', 0aH
	DB	09H, 09H, 'minlen   = 3,', 0aH, 09H, 09H, 'penwidth = 3,', 0aH
	DB	09H, 09H, 'color    = "green"', 0aH, 09H, '];', 0aH, 0aH, 09H, 'n'
	DB	'ode', 0aH, 09H, '[', 0aH, 09H, 09H, 'shape     = "record",', 0aH
	DB	09H, 09H, 'style     = "rounded, filled",', 0aH, 09H, 09H, 'fi'
	DB	'llcolor = "#404040",', 0aH, 09H, 09H, 'fontsize  = 18,', 0aH, 09H
	DB	09H, 'penwidth  = 1,', 0aH, 09H, 09H, 'color     = "#F9D423",', 0aH
	DB	09H, 09H, 'margin    = "0.05 0.4",', 0aH, 09H, 09H, 'fontcolor'
	DB	' = "#E1F5C4"', 0aH, 09H, ']', 0aH, 0aH, 09H, '{', 0aH, 09H, 09H
	DB	'rankdir       = LR;', 0aH, 09H, 09H, 'rank          = min;', 0aH
	DB	09H, 09H, 'minNode[label = "utilNode", style = invis];', 0aH, 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?GraphHeaderBegin@@3PBDB DD FLAT:??_C@_0BML@DHNEPMJC@digraph?5G?6?$HL?6?7graph?$FLdpi?5?$DN?5100?$FN?$DL?6@ ; GraphHeaderBegin
?GraphHeaderNodeInt@@3PBDB DD FLAT:??_C@_0BP@NPCAFBCA@?7?7?$CFs?$FLlabel?5?5?5?5?$DN?5?$CC?$CFs?5?2n?5?$CFzd?$CC?$FN?$DL?6@ ; GraphHeaderNodeInt
?GraphHeaderNodeStr@@3PBDB DD FLAT:??_C@_0BO@OJIMPGHJ@?7?7?$CFs?$FLlabel?5?5?5?5?$DN?5?$CC?$CFs?5?2n?5?$CFs?$CC?$FN?$DL?6@ ; GraphHeaderNodeStr
?GraphHeaderEnd@@3PBDB DD FLAT:??_C@_04FKOAHPIO@?7?$HN?6?6@ ; GraphHeaderEnd
?GraphListDataBegin@@3PBDB DD FLAT:??_C@_0CH@OAOIFOMJ@?7?$HL?6?7?7rankdir?5?$DN?5LR?$DL?6?7?7rank?5?5?5?5?$DN?5@ ; GraphListDataBegin
?GraphListDataEnd@@3PBDB DD FLAT:??_C@_0IF@LIOMBPHL@?7?$HN?6?6?7?$HL?6?7?7rank?5?$DN?5max?$DL?6?7?7maxNode?$FL@ ; GraphListDataEnd
?PrevEdgeColor@@3PBDB DD FLAT:??_C@_0DB@HLOEBEIP@?7edge?5?$FLcolor?5?$DN?5?$CC?$CD4ECDC4?$CC?0?5const@ ; PrevEdgeColor
?NextEdgeColor@@3PBDB DD FLAT:??_C@_0DB@MGFNIKHM@?7edge?5?$FLcolor?5?$DN?5?$CC?$CDC7F464?$CC?0?5const@ ; NextEdgeColor
?ListHeaderEdgeColor@@3PBDB DD FLAT:??_C@_0DB@MMBHBDCG@?7edge?5?$FLcolor?5?$DN?5?$CC?$CDFF3E50?$CC?0?5const@ ; ListHeaderEdgeColor
?ListConstraint@@3PBDB DD FLAT:??_C@_0CM@GJMNPBGO@?7edge?5?$FLstyle?5?$DN?5invis?0?5constrain@ ; ListConstraint
?EdgeFormatIntInt@@3PBDB DD FLAT:??_C@_0BA@FIJJJDP@?7f?$CFzd?5?9?$DO?5f?$CFzd?$DL?6@ ; EdgeFormatIntInt
?EdgeFormatStrInt@@3PBDB DD FLAT:??_C@_0O@DENNDLKA@?7?$CFs?5?9?$DO?5f?$CFzd?$DL?6@ ; EdgeFormatStrInt
?EdgeFormatIntStr@@3PBDB DD FLAT:??_C@_0O@NHBPBNIO@?7f?$CFzd?5?9?$DO?5?$CFs?$DL?6@ ; EdgeFormatIntStr
?NodeBegin@@3PBDB DD FLAT:??_C@_0DD@MDPOPBHM@?7?7f?$CFzd?5?$FLlabel?5?$DN?5?$CC?$HL?$HL?5?$DMl3?$DO?5index?5@ ; NodeBegin
?NodeEnd@@3PBDB DD FLAT:??_C@_0DA@GCGKBMDP@?5?$HN?$HM?$HL?5?$DMl1?$DO?5prev?5?2n?5?$CFzd?5?$HM?5?$DMl2?$DO?5ne@ ; NodeEnd
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	__vsnprintf_l
PUBLIC	_vsnprintf
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_snprintf
PUBLIC	?ListVerify@@YAHPAUList@@@Z			; ListVerify
PUBLIC	?ListDump@@YAXPAUList@@II@Z			; ListDump
PUBLIC	?ListGraphicDump@@YAHPAUList@@@Z		; ListGraphicDump
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_03HIJPJGOM@?$CF?$CKs@			; `string'
PUBLIC	??_C@_0DH@GDDOOIAH@D?3?2Language?5C?2HashTable?2HashTab@ ; `string'
PUBLIC	??_C@_0DP@KJNINJCO@void?5__cdecl?5ListDump?$CIstruct?5Li@ ; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_0JN@IMIPCLFP@List?$DM?$CFp?$DO?5dump?4?6?6?7Nodes?5?5?5?5?$DN?5?$DM?$CFp@ ; `string'
PUBLIC	??_C@_0CG@KNNOCGGK@?7Index?5?$CFzd?6?7?7n?5?$DN?5?$CFzd?6?7?7p?5?$DN?5?$CFzd?6@ ; `string'
PUBLIC	??_C@_02PHMGELLB@?6?6@				; `string'
PUBLIC	??_C@_0BA@GGMJEJAI@List?5dump?5end?4?6@		; `string'
PUBLIC	??_C@_0BB@KABHEABK@_logs?2_listImgs?2@		; `string'
PUBLIC	??_C@_0BL@GNCDKN@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?o?$OA?o?j?h?5?$CC?$CFs?$CC@ ; `string'
PUBLIC	??_C@_0CL@DHNDODM@int?5__cdecl?5ListGraphicDump?$CIstr@ ; `string'
PUBLIC	??_C@_0BM@CMNAGCKF@_logs?2_listImgs?2listDump?4gv@ ; `string'
PUBLIC	??_C@_0CA@OKEADHPO@_logs?2_listImgs?2listDump?$CFzd?4png@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0BL@BOFFHFB@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?t?$OA?i?k?$OA?5?$CC?$CFs?$CC@ ; `string'
PUBLIC	??_C@_04BFCCBDOP@Head@				; `string'
PUBLIC	??_C@_04PJJKCFIL@Tail@				; `string'
PUBLIC	??_C@_04HJMOFLDF@Free@				; `string'
PUBLIC	??_C@_04EBKMHHBE@Size@				; `string'
PUBLIC	??_C@_08PINBMPEF@Capacity@			; `string'
PUBLIC	??_C@_06PGDKHFME@Status@			; `string'
PUBLIC	??_C@_06KBMOENCI@Sorted@			; `string'
PUBLIC	??_C@_02JHLIKEIA@?6?$HN@			; `string'
PUBLIC	??_C@_0BG@EBGIHKBL@dot?5?$CC?$CFs?$CC?5?9Tpng?5?$DO?5?$CC?$CFs?$CC@ ; `string'
PUBLIC	??_C@_0BK@BAAAHDEP@_listImgs?2listDump?$CFzd?4png@ ; `string'
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fputc:PROC
EXTRN	__imp__fputs:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__system:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	?DirectoryExist@@YA_NPBD@Z:PROC			; DirectoryExist
EXTRN	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ:PROC ; LogFLine
EXTRN	?LogBeginDump@@YAPAU_iobuf@@W4LogSignature@@W4LogLevel@@PBD2H@Z:PROC ; LogBeginDump
EXTRN	?LogEndDump@@YAXW4LogSignature@@@Z:PROC		; LogEndDump
EXTRN	?LogAddImage@@YAXW4LogSignature@@PBD@Z:PROC	; LogAddImage
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?imageIndex@?1??ListGraphicDump@@YAHPAUList@@@Z@4IA
_BSS	SEGMENT
?imageIndex@?1??ListGraphicDump@@YAHPAUList@@@Z@4IA DD 01H DUP (?) ; `ListGraphicDump'::`2'::imageIndex
_BSS	ENDS
;	COMDAT ??_C@_0BK@BAAAHDEP@_listImgs?2listDump?$CFzd?4png@
CONST	SEGMENT
??_C@_0BK@BAAAHDEP@_listImgs?2listDump?$CFzd?4png@ DB '_listImgs\listDump'
	DB	'%zd.png', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EBGIHKBL@dot?5?$CC?$CFs?$CC?5?9Tpng?5?$DO?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0BG@EBGIHKBL@dot?5?$CC?$CFs?$CC?5?9Tpng?5?$DO?5?$CC?$CFs?$CC@ DB 'd'
	DB	'ot "%s" -Tpng > "%s"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JHLIKEIA@?6?$HN@
CONST	SEGMENT
??_C@_02JHLIKEIA@?6?$HN@ DB 0aH, '}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KBMOENCI@Sorted@
CONST	SEGMENT
??_C@_06KBMOENCI@Sorted@ DB 'Sorted', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PGDKHFME@Status@
CONST	SEGMENT
??_C@_06PGDKHFME@Status@ DB 'Status', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PINBMPEF@Capacity@
CONST	SEGMENT
??_C@_08PINBMPEF@Capacity@ DB 'Capacity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBKMHHBE@Size@
CONST	SEGMENT
??_C@_04EBKMHHBE@Size@ DB 'Size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJMOFLDF@Free@
CONST	SEGMENT
??_C@_04HJMOFLDF@Free@ DB 'Free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJJKCFIL@Tail@
CONST	SEGMENT
??_C@_04PJJKCFIL@Tail@ DB 'Tail', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BFCCBDOP@Head@
CONST	SEGMENT
??_C@_04BFCCBDOP@Head@ DB 'Head', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BOFFHFB@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?t?$OA?i?k?$OA?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0BL@BOFFHFB@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?t?$OA?i?k?$OA?5?$CC?$CFs?$CC@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0f1H, 0eeH, 0e7H, 0e4H, 0e0H
	DB	0edH, 0e8H, 0ffH, ' ', 0f4H, 0e0H, 0e9H, 0ebH, 0e0H, ' "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OKEADHPO@_logs?2_listImgs?2listDump?$CFzd?4png@
CONST	SEGMENT
??_C@_0CA@OKEADHPO@_logs?2_listImgs?2listDump?$CFzd?4png@ DB '_logs\_list'
	DB	'Imgs\listDump%zd.png', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CMNAGCKF@_logs?2_listImgs?2listDump?4gv@
CONST	SEGMENT
??_C@_0BM@CMNAGCKF@_logs?2_listImgs?2listDump?4gv@ DB '_logs\_listImgs\li'
	DB	'stDump.gv', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DHNDODM@int?5__cdecl?5ListGraphicDump?$CIstr@
CONST	SEGMENT
??_C@_0CL@DHNDODM@int?5__cdecl?5ListGraphicDump?$CIstr@ DB 'int __cdecl L'
	DB	'istGraphicDump(struct List *)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GNCDKN@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?o?$OA?o?j?h?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0BL@GNCDKN@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?o?$OA?o?j?h?5?$CC?$CFs?$CC@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0f1H, 0eeH, 0e7H, 0e4H, 0e0H
	DB	0edH, 0e8H, 0ffH, ' ', 0efH, 0e0H, 0efH, 0eaH, 0e8H, ' "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KABHEABK@_logs?2_listImgs?2@
CONST	SEGMENT
??_C@_0BB@KABHEABK@_logs?2_listImgs?2@ DB '_logs\_listImgs\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GGMJEJAI@List?5dump?5end?4?6@
CONST	SEGMENT
??_C@_0BA@GGMJEJAI@List?5dump?5end?4?6@ DB 'List dump end.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PHMGELLB@?6?6@
CONST	SEGMENT
??_C@_02PHMGELLB@?6?6@ DB 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KNNOCGGK@?7Index?5?$CFzd?6?7?7n?5?$DN?5?$CFzd?6?7?7p?5?$DN?5?$CFzd?6@
CONST	SEGMENT
??_C@_0CG@KNNOCGGK@?7Index?5?$CFzd?6?7?7n?5?$DN?5?$CFzd?6?7?7p?5?$DN?5?$CFzd?6@ DB 09H
	DB	'Index %zd', 0aH, 09H, 09H, 'n = %zd', 0aH, 09H, 09H, 'p = %zd'
	DB	0aH, 09H, 09H, 'd = ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0JN@IMIPCLFP@List?$DM?$CFp?$DO?5dump?4?6?6?7Nodes?5?5?5?5?$DN?5?$DM?$CFp@
CONST	SEGMENT
??_C@_0JN@IMIPCLFP@List?$DM?$CFp?$DO?5dump?4?6?6?7Nodes?5?5?5?5?$DN?5?$DM?$CFp@ DB 'L'
	DB	'ist<%p> dump.', 0aH, 0aH, 09H, 'Nodes    = <%p>', 0aH, 09H, 'F'
	DB	'ree     = %zd', 0aH, 09H, 'Head     = %zd', 0aH, 09H, 'Tail  '
	DB	'   = %zd', 0aH, 09H, 'Size     = %zd', 0aH, 09H, 'Capacity = '
	DB	'%zd', 0aH, 09H, 'Sorted   = %s', 0aH, 09H, 'Status   = %d', 0aH
	DB	0aH, 'Data info:', 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KJNINJCO@void?5__cdecl?5ListDump?$CIstruct?5Li@
CONST	SEGMENT
??_C@_0DP@KJNINJCO@void?5__cdecl?5ListDump?$CIstruct?5Li@ DB 'void __cdec'
	DB	'l ListDump(struct List *,unsigned int,unsigned int)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@GDDOOIAH@D?3?2Language?5C?2HashTable?2HashTab@
CONST	SEGMENT
??_C@_0DH@GDDOOIAH@D?3?2Language?5C?2HashTable?2HashTab@ DB 'D:\Language '
	DB	'C\HashTable\HashTable\List\List_Verify.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HIJPJGOM@?$CF?$CKs@
CONST	SEGMENT
??_C@_03HIJPJGOM@?$CF?$CKs@ DB '%*s', 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List_Verify.cpp
;	COMDAT ?ListGraphicDump@@YAHPAUList@@@Z
_TEXT	SEGMENT
tv568 = -384						; size = 4
tv566 = -384						; size = 4
tv563 = -384						; size = 4
_cmd$ = -380						; size = 256
_fileImagePath$ = -124					; size = 100
_convertBuffer$ = -24					; size = 17
__$ArrayPad$ = -4					; size = 4
_list$ = 8						; size = 4
?ListGraphicDump@@YAHPAUList@@@Z PROC			; ListGraphicDump, COMDAT

; 288  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 384				; 00000180H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _list$[ebp]

; 289  :     LOG_LIST_TRACE_VERIFY;
; 290  : 
; 291  :     assert(list);
; 292  : 
; 293  :     //LIST_ASSERT_STATUS;
; 294  : 
; 295  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 296  : 
; 297  :     const  size_t filePathSize = 100;
; 298  :     static size_t imageIndex   = 0;
; 299  : 
; 300  :     const char* folder          = LOGS_FOLDER LIST_LOG_IMAGE_FOLDER;
; 301  : 
; 302  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 303  : 
; 304  :     // Создаём папку, куда будут сохраняться изображения, чтобы не мусорить папку с логами.
; 305  :     if (!DirectoryExist(folder) &&

	push	OFFSET ??_C@_0BB@KABHEABK@_logs?2_listImgs?2@
	call	?DirectoryExist@@YA_NPBD@Z		; DirectoryExist
	add	esp, 4
	test	al, al
	jne	SHORT $LN14@ListGraphi
	push	0
	push	OFFSET ??_C@_0BB@KABHEABK@_logs?2_listImgs?2@
	call	DWORD PTR __imp__CreateDirectoryA@8
	test	eax, eax
	jne	SHORT $LN14@ListGraphi

; 306  :         !CreateDirectoryA(folder, nullptr))
; 307  :     {
; 308  :         LOG_F_LIST_ERR("Ошибка создания папки \"%s\"", folder);

	push	OFFSET ??_C@_0BB@KABHEABK@_logs?2_listImgs?2@
	push	OFFSET ??_C@_0BL@GNCDKN@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?o?$OA?o?j?h?5?$CC?$CFs?$CC@
	push	308					; 00000134H
	push	OFFSET ??_C@_0DH@GDDOOIAH@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0CL@DHNDODM@int?5__cdecl?5ListGraphicDump?$CIstr@
	push	1
	push	2
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 309  : 
; 310  :         list->Status |= LIST_ERR_FOLDER;

	mov	eax, DWORD PTR [esi+28]
	add	esp, 32					; 00000020H
	or	eax, 8192				; 00002000H
	mov	DWORD PTR [esi+28], eax
	pop	esi

; 425  :     }
; 426  : 
; 427  :     imageIndex++;
; 428  : 
; 429  :     return list->Status;
; 430  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@ListGraphi:
	push	edi

; 311  : 
; 312  :         return list->Status;
; 313  :     }
; 314  : 
; 315  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 316  :     
; 317  :     // Создаём файл описания графа .gv для создания изображения с помощью GraphViz.
; 318  :     char convertBuffer[ListToStringSize] = "";
; 319  : 
; 320  :     const char* fileGraphvizPath            = LOGS_FOLDER LIST_LOG_IMAGE_FOLDER "listDump.gv";
; 321  :     char        fileImagePath[filePathSize] = "";

	push	100					; 00000064H
	lea	eax, DWORD PTR _fileImagePath$[ebp]
	mov	BYTE PTR _convertBuffer$[ebp+16], 0
	xorps	xmm0, xmm0
	push	0
	push	eax
	movups	XMMWORD PTR _convertBuffer$[ebp], xmm0
	call	_memset

; 322  : 
; 323  :     snprintf(fileImagePath, filePathSize, LOGS_FOLDER LIST_LOG_IMAGE_FOLDER "listDump%zd." LIST_GRAPH_TYPE, imageIndex);

	push	DWORD PTR ?imageIndex@?1??ListGraphicDump@@YAHPAUList@@@Z@4IA
	lea	eax, DWORD PTR _fileImagePath$[ebp]
	push	OFFSET ??_C@_0CA@OKEADHPO@_logs?2_listImgs?2listDump?$CFzd?4png@
	push	100					; 00000064H
	push	eax
	call	_snprintf

; 324  : 
; 325  :     FILE* outGraphFile = fopen(fileGraphvizPath, "w");

	push	OFFSET ??_C@_01NOFIACDB@w@
	push	OFFSET ??_C@_0BM@CMNAGCKF@_logs?2_listImgs?2listDump?4gv@
	call	DWORD PTR __imp__fopen
	mov	edi, eax
	add	esp, 36					; 00000024H

; 326  : 
; 327  :     if (!outGraphFile)

	test	edi, edi
	jne	SHORT $LN15@ListGraphi

; 328  :     {
; 329  :         LOG_F_LIST_ERR("Ошибка создания файла \"%s\"", fileGraphvizPath);

	push	OFFSET ??_C@_0BM@CMNAGCKF@_logs?2_listImgs?2listDump?4gv@
	push	OFFSET ??_C@_0BL@BOFFHFB@?N?x?h?a?j?$OA?5?q?n?g?d?$OA?m?h?$PP?5?t?$OA?i?k?$OA?5?$CC?$CFs?$CC@
	push	329					; 00000149H
	push	OFFSET ??_C@_0DH@GDDOOIAH@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0CL@DHNDODM@int?5__cdecl?5ListGraphicDump?$CIstr@
	push	1
	push	2
	push	4
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPBD3H3ZZ ; LogFLine

; 330  : 
; 331  :         list->Status |= LIST_ERR_FILE;

	mov	eax, DWORD PTR [esi+28]
	add	esp, 32					; 00000020H
	or	eax, 16384				; 00004000H
	mov	DWORD PTR [esi+28], eax
	pop	edi
	pop	esi

; 425  :     }
; 426  : 
; 427  :     imageIndex++;
; 428  : 
; 429  :     return list->Status;
; 430  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@ListGraphi:
	push	ebx

; 332  : 
; 333  :         return list->Status;
; 334  :     }
; 335  : 
; 336  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 337  :     
; 338  :     // Создание заголовка графа.
; 339  :     fputs(GraphHeaderBegin, outGraphFile);

	mov	ebx, DWORD PTR __imp__fputs
	push	edi
	push	DWORD PTR ?GraphHeaderBegin@@3PBDB	; GraphHeaderBegin
	call	ebx

; 340  : 
; 341  :     fprintf(outGraphFile, GraphHeaderNodeInt, "Head",     "Head",     list->Head);

	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_04BFCCBDOP@Head@
	push	OFFSET ??_C@_04BFCCBDOP@Head@
	push	DWORD PTR ?GraphHeaderNodeInt@@3PBDB	; GraphHeaderNodeInt
	push	edi
	call	_fprintf

; 342  :     fprintf(outGraphFile, GraphHeaderNodeInt, "Tail",     "Tail",     list->Tail);

	push	DWORD PTR [esi+12]
	push	OFFSET ??_C@_04PJJKCFIL@Tail@
	push	OFFSET ??_C@_04PJJKCFIL@Tail@
	push	DWORD PTR ?GraphHeaderNodeInt@@3PBDB	; GraphHeaderNodeInt
	push	edi
	call	_fprintf

; 343  :     fprintf(outGraphFile, GraphHeaderNodeInt, "Free",     "Free",     list->Free);

	push	DWORD PTR [esi+4]
	push	OFFSET ??_C@_04HJMOFLDF@Free@
	push	OFFSET ??_C@_04HJMOFLDF@Free@
	push	DWORD PTR ?GraphHeaderNodeInt@@3PBDB	; GraphHeaderNodeInt
	push	edi
	call	_fprintf
	add	esp, 68					; 00000044H

; 344  :     fprintf(outGraphFile, GraphHeaderNodeInt, "Size",     "Size",     list->Size);

	push	DWORD PTR [esi+16]
	push	OFFSET ??_C@_04EBKMHHBE@Size@
	push	OFFSET ??_C@_04EBKMHHBE@Size@
	push	DWORD PTR ?GraphHeaderNodeInt@@3PBDB	; GraphHeaderNodeInt
	push	edi
	call	_fprintf

; 345  :     fprintf(outGraphFile, GraphHeaderNodeInt, "Capacity", "Capacity", list->Capacity);

	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_08PINBMPEF@Capacity@
	push	OFFSET ??_C@_08PINBMPEF@Capacity@
	push	DWORD PTR ?GraphHeaderNodeInt@@3PBDB	; GraphHeaderNodeInt
	push	edi
	call	_fprintf

; 346  :     fprintf(outGraphFile, GraphHeaderNodeInt, "Status",   "Status",   list->Status);

	push	DWORD PTR [esi+28]
	push	OFFSET ??_C@_06PGDKHFME@Status@
	push	OFFSET ??_C@_06PGDKHFME@Status@
	push	DWORD PTR ?GraphHeaderNodeInt@@3PBDB	; GraphHeaderNodeInt
	push	edi
	call	_fprintf

; 347  :     fprintf(outGraphFile, GraphHeaderNodeStr, "Sorted",   "Sorted",   list->Sorted ? "true" : "false");

	cmp	BYTE PTR [esi+24], 0
	mov	ecx, OFFSET ??_C@_05LAPONLG@false@
	mov	eax, OFFSET ??_C@_04LOAJBDKD@true@
	cmove	eax, ecx
	push	eax
	push	OFFSET ??_C@_06KBMOENCI@Sorted@
	push	OFFSET ??_C@_06KBMOENCI@Sorted@
	push	DWORD PTR ?GraphHeaderNodeStr@@3PBDB	; GraphHeaderNodeStr
	push	edi
	call	_fprintf
	add	esp, 80					; 00000050H

; 348  : 
; 349  :     fputs(GraphHeaderEnd, outGraphFile);

	push	edi
	push	DWORD PTR ?GraphHeaderEnd@@3PBDB	; GraphHeaderEnd
	call	ebx

; 350  : 
; 351  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 352  : 
; 353  :     // Создание узлов элементов списка.
; 354  :     fputs(GraphListDataBegin, outGraphFile);

	push	edi
	push	DWORD PTR ?GraphListDataBegin@@3PBDB	; GraphListDataBegin
	call	ebx
	add	esp, 16					; 00000010H

; 355  : 
; 356  :     for (size_t st = 0; st <= list->Capacity; st++)

	xor	ebx, ebx
	mov	DWORD PTR tv568[ebp], ebx
$LL4@ListGraphi:

; 357  :     {
; 358  :         fprintf(outGraphFile, NodeBegin, st, st);

	push	ebx
	push	ebx
	push	DWORD PTR ?NodeBegin@@3PBDB		; NodeBegin
	push	edi
	call	_fprintf

; 359  : 
; 360  :         ListElementToString(convertBuffer, ListToStringSize, &list->Nodes[st].Data);

	mov	ecx, DWORD PTR tv568[ebp]
	mov	eax, DWORD PTR [esi]
	add	ecx, 16					; 00000010H
	add	eax, ecx
	push	eax
	lea	eax, DWORD PTR _convertBuffer$[ebp]
	push	17					; 00000011H
	push	eax
	call	?ListElementToString@@YAXPADIPBT__m128i@@@Z ; ListElementToString

; 361  : 
; 362  :         fputs(convertBuffer, outGraphFile);

	lea	eax, DWORD PTR _convertBuffer$[ebp]
	push	edi
	push	eax
	call	DWORD PTR __imp__fputs

; 363  : 
; 364  :         fprintf(outGraphFile, NodeEnd, list->Nodes[st].Prev, list->Nodes[st].Next);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR tv568[ebp]
	push	DWORD PTR [eax+ecx]
	push	DWORD PTR [eax+ecx+4]
	push	DWORD PTR ?NodeEnd@@3PBDB		; NodeEnd
	push	edi
	call	_fprintf
	add	DWORD PTR tv568[ebp], 32		; 00000020H
	inc	ebx
	add	esp, 52					; 00000034H
	cmp	ebx, DWORD PTR [esi+20]
	jbe	SHORT $LL4@ListGraphi

; 365  :     }
; 366  : 
; 367  :     fputs(GraphListDataEnd, outGraphFile);

	mov	ebx, DWORD PTR __imp__fputs
	push	edi
	push	DWORD PTR ?GraphListDataEnd@@3PBDB	; GraphListDataEnd
	call	ebx

; 368  : 
; 369  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 370  :     
; 371  :     // Создание связи Prev.
; 372  :     fputs(PrevEdgeColor, outGraphFile);

	push	edi
	push	DWORD PTR ?PrevEdgeColor@@3PBDB		; PrevEdgeColor
	call	ebx

; 373  :     for (size_t st = 1; st <= list->Capacity; st++)

	mov	ebx, 1
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [esi+20], ebx
	jb	SHORT $LN37@ListGraphi

; 365  :     }
; 366  : 
; 367  :     fputs(GraphListDataEnd, outGraphFile);

	mov	ecx, 32					; 00000020H
	mov	DWORD PTR tv566[ebp], ecx
$LL7@ListGraphi:

; 374  :         if (list->Nodes[st].Prev != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+eax+4]
	test	eax, eax
	je	SHORT $LN5@ListGraphi

; 375  :             fprintf(outGraphFile, EdgeFormatIntInt, st, list->Nodes[st].Prev);

	push	eax
	push	ebx
	push	DWORD PTR ?EdgeFormatIntInt@@3PBDB	; EdgeFormatIntInt
	push	edi
	call	_fprintf
	mov	ecx, DWORD PTR tv566[ebp]
	add	esp, 16					; 00000010H
$LN5@ListGraphi:

; 373  :     for (size_t st = 1; st <= list->Capacity; st++)

	inc	ebx
	add	ecx, 32					; 00000020H
	mov	DWORD PTR tv566[ebp], ecx
	cmp	ebx, DWORD PTR [esi+20]
	jbe	SHORT $LL7@ListGraphi
$LN37@ListGraphi:

; 376  : 
; 377  :     fputc('\n', outGraphFile);

	push	edi
	push	10					; 0000000aH
	call	DWORD PTR __imp__fputc

; 378  : 
; 379  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 380  :     
; 381  :     // Создание связи Next.
; 382  :     fputs(NextEdgeColor, outGraphFile);

	push	edi
	push	DWORD PTR ?NextEdgeColor@@3PBDB		; NextEdgeColor
	call	DWORD PTR __imp__fputs

; 383  :     for (size_t st = 1; st <= list->Capacity; st++)

	mov	ebx, 1
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [esi+20], ebx
	jb	SHORT $LN9@ListGraphi

; 376  : 
; 377  :     fputc('\n', outGraphFile);

	mov	ecx, 32					; 00000020H
	mov	DWORD PTR tv563[ebp], ecx
$LL10@ListGraphi:

; 384  :         if (list->Nodes[st].Next != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+eax]
	test	eax, eax
	je	SHORT $LN8@ListGraphi

; 385  :             fprintf(outGraphFile, EdgeFormatIntInt, st, list->Nodes[st].Next);

	push	eax
	push	ebx
	push	DWORD PTR ?EdgeFormatIntInt@@3PBDB	; EdgeFormatIntInt
	push	edi
	call	_fprintf
	mov	ecx, DWORD PTR tv563[ebp]
	add	esp, 16					; 00000010H
$LN8@ListGraphi:

; 383  :     for (size_t st = 1; st <= list->Capacity; st++)

	inc	ebx
	add	ecx, 32					; 00000020H
	mov	DWORD PTR tv563[ebp], ecx
	cmp	ebx, DWORD PTR [esi+20]
	jbe	SHORT $LL10@ListGraphi
$LN9@ListGraphi:

; 386  : 
; 387  :     fputc('\n', outGraphFile);

	push	edi
	push	10					; 0000000aH
	call	DWORD PTR __imp__fputc

; 388  : 
; 389  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 390  :     
; 391  :     // Создание линий связи информационных полей списка с узлами элементов.
; 392  :     fputs(ListHeaderEdgeColor, outGraphFile);

	mov	ebx, DWORD PTR __imp__fputs
	push	edi
	push	DWORD PTR ?ListHeaderEdgeColor@@3PBDB	; ListHeaderEdgeColor
	call	ebx

; 393  : 
; 394  :     fprintf(outGraphFile, EdgeFormatStrInt, "Head", list->Head);

	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_04BFCCBDOP@Head@
	push	DWORD PTR ?EdgeFormatStrInt@@3PBDB	; EdgeFormatStrInt
	push	edi
	call	_fprintf

; 395  :     fprintf(outGraphFile, EdgeFormatIntStr, list->Tail, "Tail");

	push	OFFSET ??_C@_04PJJKCFIL@Tail@
	push	DWORD PTR [esi+12]
	push	DWORD PTR ?EdgeFormatIntStr@@3PBDB	; EdgeFormatIntStr
	push	edi
	call	_fprintf

; 396  :     fprintf(outGraphFile, EdgeFormatStrInt, "Free", list->Free);

	push	DWORD PTR [esi+4]
	push	OFFSET ??_C@_04HJMOFLDF@Free@
	push	DWORD PTR ?EdgeFormatStrInt@@3PBDB	; EdgeFormatStrInt
	push	edi
	call	_fprintf
	add	esp, 64					; 00000040H

; 397  : 
; 398  :     fputc('\n', outGraphFile);

	push	edi
	push	10					; 0000000aH
	call	DWORD PTR __imp__fputc

; 399  : 
; 400  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 401  :    
; 402  :     // Создание вспомогательных линий, чтобы узлы располагались в правильном порядке.
; 403  :     fputs(ListConstraint, outGraphFile);

	push	edi
	push	DWORD PTR ?ListConstraint@@3PBDB	; ListConstraint
	call	ebx

; 404  : 
; 405  :     for (size_t st = 1; st <= list->Capacity; st++)

	mov	ebx, 1
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [esi+20], ebx
	jb	SHORT $LN12@ListGraphi
$LL13@ListGraphi:

; 406  :         fprintf(outGraphFile, EdgeFormatIntInt, st - 1, st);

	push	ebx
	lea	eax, DWORD PTR [ebx-1]
	push	eax
	push	DWORD PTR ?EdgeFormatIntInt@@3PBDB	; EdgeFormatIntInt
	push	edi
	call	_fprintf
	inc	ebx
	add	esp, 16					; 00000010H
	cmp	ebx, DWORD PTR [esi+20]
	jbe	SHORT $LL13@ListGraphi
$LN12@ListGraphi:

; 407  : 
; 408  :     fputs("\n}", outGraphFile);

	push	edi
	push	OFFSET ??_C@_02JHLIKEIA@?6?$HN@
	call	DWORD PTR __imp__fputs

; 409  : 
; 410  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 411  :    
; 412  :     // Закрытие файла, преобразование его в изображение.
; 413  :     fclose(outGraphFile);

	push	edi
	call	DWORD PTR __imp__fclose

; 414  : 
; 415  :     char cmd[256] = "";

	push	256					; 00000100H
	lea	eax, DWORD PTR _cmd$[ebp]
	push	0
	push	eax
	call	_memset

; 416  :     sprintf(cmd, "dot \"%s\" -T" LIST_GRAPH_TYPE " > \"%s\"", fileGraphvizPath, fileImagePath);

	lea	eax, DWORD PTR _fileImagePath$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@CMNAGCKF@_logs?2_listImgs?2listDump?4gv@
	lea	eax, DWORD PTR _cmd$[ebp]
	push	OFFSET ??_C@_0BG@EBGIHKBL@dot?5?$CC?$CFs?$CC?5?9Tpng?5?$DO?5?$CC?$CFs?$CC@
	push	eax
	call	_sprintf

; 417  :     int status = system(cmd);

	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	DWORD PTR __imp__system
	add	esp, 44					; 0000002cH
	pop	ebx

; 418  : 
; 419  :     // Если нет ошибок, то добавляем изображение в лог.
; 420  :     if (status == 0)

	test	eax, eax
	jne	SHORT $LN18@ListGraphi

; 421  :     {
; 422  :         snprintf(fileImagePath, filePathSize, LIST_LOG_IMAGE_FOLDER "listDump%zd." LIST_GRAPH_TYPE, imageIndex);

	push	DWORD PTR ?imageIndex@?1??ListGraphicDump@@YAHPAUList@@@Z@4IA
	lea	eax, DWORD PTR _fileImagePath$[ebp]
	push	OFFSET ??_C@_0BK@BAAAHDEP@_listImgs?2listDump?$CFzd?4png@
	push	100					; 00000064H
	push	eax
	call	_snprintf

; 423  : 
; 424  :         LogAddImage(LOG_SIG_LIST, fileImagePath);

	lea	eax, DWORD PTR _fileImagePath$[ebp]
	push	eax
	push	2
	call	?LogAddImage@@YAXW4LogSignature@@PBD@Z	; LogAddImage
	add	esp, 24					; 00000018H
$LN18@ListGraphi:

; 425  :     }
; 426  : 
; 427  :     imageIndex++;
; 428  : 
; 429  :     return list->Status;
; 430  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR [esi+28]
	xor	ecx, ebp
	inc	DWORD PTR ?imageIndex@?1??ListGraphicDump@@YAHPAUList@@@Z@4IA
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ListGraphicDump@@YAHPAUList@@@Z ENDP			; ListGraphicDump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List_Verify.cpp
;	COMDAT ?ListDump@@YAXPAUList@@II@Z
_TEXT	SEGMENT
_buffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_list$ = 8						; size = 4
_dataStartIndex$ = 12					; size = 4
_dataEndIndex$ = 16					; size = 4
?ListDump@@YAXPAUList@@II@Z PROC			; ListDump, COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1028				; 00000404H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _list$[ebp]

; 141  :     LOG_LIST_TRACE_VERIFY;
; 142  : 
; 143  :     assert(list);
; 144  : 
; 145  :     //LIST_ASSERT_STATUS;
; 146  : 
; 147  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 148  :     
; 149  :     size_t capacity = list->Capacity;
; 150  :     size_t size     = list->Size;
; 151  : 
; 152  :     size_t filled = 0;
; 153  : 
; 154  :     const size_t bufferSize = 1024;
; 155  : 
; 156  :     char buffer[bufferSize] = "";

	lea	eax, DWORD PTR _buffer$[ebp]
	push	edi
	push	1024					; 00000400H
	push	0
	push	eax
	call	_memset

; 157  : 
; 158  :     FILE* log = LOG_LIST_BEGIN_DUMP;

	push	158					; 0000009eH
	push	OFFSET ??_C@_0DH@GDDOOIAH@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0DP@KJNINJCO@void?5__cdecl?5ListDump?$CIstruct?5Li@
	push	1
	push	2
	call	?LogBeginDump@@YAPAU_iobuf@@W4LogSignature@@W4LogLevel@@PBD2H@Z ; LogBeginDump

; 159  : 
; 160  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 161  :     
; 162  :     sprintf(buffer,

	push	DWORD PTR [esi+28]
	cmp	BYTE PTR [esi+24], 0
	mov	ebx, eax
	mov	eax, OFFSET ??_C@_05LAPONLG@false@
	mov	ecx, OFFSET ??_C@_04LOAJBDKD@true@
	cmove	ecx, eax
	lea	eax, DWORD PTR _buffer$[ebp]
	push	ecx
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+16]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	push	esi
	push	OFFSET ??_C@_0JN@IMIPCLFP@List?$DM?$CFp?$DO?5dump?4?6?6?7Nodes?5?5?5?5?$DN?5?$DM?$CFp@
	push	eax
	call	_sprintf
	add	esp, 76					; 0000004cH

; 163  :             "List<%p> dump.\n\n"
; 164  :             "\tNodes    = <%p>\n"
; 165  :             "\tFree     = %zd\n"
; 166  :             "\tHead     = %zd\n"
; 167  :             "\tTail     = %zd\n"
; 168  :             "\tSize     = %zd\n"
; 169  :             "\tCapacity = %zd\n"
; 170  :             "\tSorted   = %s\n"
; 171  :             "\tStatus   = %d\n\n"
; 172  :             "Data info:\n\n",
; 173  :             (void*)list,
; 174  :             (void*)list->Nodes,
; 175  :             list->Free,
; 176  :             list->Head,
; 177  :             list->Tail,
; 178  :             list->Size,
; 179  :             list->Capacity,
; 180  :             (list->Sorted)? "true" : "false",
; 181  :             list->Status);
; 182  : 
; 183  :     fputs(buffer, log);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	ebx
	push	eax
	call	DWORD PTR __imp__fputs

; 184  : 
; 185  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 186  :     
; 187  :     const size_t endIndex = list->Size < dataEndIndex? list->Size : dataEndIndex;
; 188  : 
; 189  :     const ListNode* nodes = list->Nodes;
; 190  : 
; 191  :     for (size_t st = dataStartIndex; st < dataEndIndex; st++)

	mov	edi, DWORD PTR _dataStartIndex$[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR [esi]
	cmp	edi, DWORD PTR _dataEndIndex$[ebp]
	jae	SHORT $LN3@ListDump

; 140  : {

	mov	eax, edi
	lea	esi, DWORD PTR [ecx+16]
	shl	eax, 5
	add	esi, eax
	npad	10
$LL4@ListDump:

; 192  :     {
; 193  :         sprintf(buffer,

	push	DWORD PTR [esi-12]
	lea	eax, DWORD PTR _buffer$[ebp]
	push	DWORD PTR [esi-16]
	push	edi
	push	OFFSET ??_C@_0CG@KNNOCGGK@?7Index?5?$CFzd?6?7?7n?5?$DN?5?$CFzd?6?7?7p?5?$DN?5?$CFzd?6@
	push	eax
	call	_sprintf

; 194  :                 "\tIndex %zd\n\t\tn = %zd\n\t\tp = %zd\n\t\td = ",
; 195  :                 st,
; 196  :                 nodes[st].Next,
; 197  :                 nodes[st].Prev);
; 198  : 
; 199  :         fputs(buffer, log);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	ebx
	push	eax
	call	DWORD PTR __imp__fputs

; 200  : 
; 201  :         ListElementToString(buffer, bufferSize, &nodes[st].Data);

	push	esi
	lea	eax, DWORD PTR _buffer$[ebp]
	push	1024					; 00000400H
	push	eax
	call	?ListElementToString@@YAXPADIPBT__m128i@@@Z ; ListElementToString

; 202  : 
; 203  :         fputs(buffer, log);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	ebx
	push	eax
	call	DWORD PTR __imp__fputs

; 204  : 
; 205  :         fputs("\n\n", log);

	push	ebx
	push	OFFSET ??_C@_02PHMGELLB@?6?6@
	call	DWORD PTR __imp__fputs
	inc	edi
	add	esp, 56					; 00000038H
	add	esi, 32					; 00000020H
	cmp	edi, DWORD PTR _dataEndIndex$[ebp]
	jb	SHORT $LL4@ListDump
$LN3@ListDump:

; 206  :     }
; 207  : 
; 208  :     fputs("List dump end.\n", log);

	push	ebx
	push	OFFSET ??_C@_0BA@GGMJEJAI@List?5dump?5end?4?6@
	call	DWORD PTR __imp__fputs

; 209  : 
; 210  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 211  : 
; 212  :     LOG_LIST_END_DUMP;

	push	2
	call	?LogEndDump@@YAXW4LogSignature@@@Z	; LogEndDump

; 213  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	xor	ecx, ebp
	pop	edi
	pop	esi
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ListDump@@YAXPAUList@@II@Z ENDP			; ListDump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List_Verify.cpp
;	COMDAT ?ListVerify@@YAHPAUList@@@Z
_TEXT	SEGMENT
_size$1$ = -24						; size = 4
_prevCount$1$ = -20					; size = 4
_nextCount$1$ = -16					; size = 4
_fillCount$1$ = -12					; size = 4
_prevIndex$1$ = -8					; size = 4
_nodeChecker$1$ = -4					; size = 4
_list$ = 8						; size = 4
?ListVerify@@YAHPAUList@@@Z PROC			; ListVerify, COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	esi, DWORD PTR _list$[ebp]
	push	edi

; 31   :     LOG_LIST_TRACE_VERIFY;
; 32   : 
; 33   :     assert(list);
; 34   : 
; 35   :     //LIST_ASSERT_STATUS;
; 36   : 
; 37   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 38   : 
; 39   :     list->Status = LIST_ERR_NO_ERRORS;
; 40   : 
; 41   :     const size_t capacity = list->Capacity;
; 42   :     const size_t size     = list->Size;

	mov	edi, DWORD PTR [esi+16]

; 43   : 
; 44   :     ListNode* nodes       = list->Nodes;

	mov	ebx, DWORD PTR [esi]

; 45   : 
; 46   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 47   : 
; 48   :     if ((size >  0 && list->Head == 0) ||
; 49   :         (size == 0 && list->Head != 0) ||

	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR _size$1$[ebp], edi
	test	edi, edi
	je	SHORT $LN63@ListVerify
	test	edx, edx
	je	SHORT $LN9@ListVerify
	jmp	SHORT $LN52@ListVerify
$LN63@ListVerify:
	test	edx, edx
	jne	SHORT $LN9@ListVerify
$LN52@ListVerify:
	mov	edx, DWORD PTR [esi+8]
	xor	ecx, ecx
	cmp	edx, DWORD PTR [ebx]
	je	SHORT $LN59@ListVerify
$LN9@ListVerify:

; 50   :         (list->Head != nodes[0].Next))
; 51   :         list->Status |= LIST_ERR_HEAD;

	mov	DWORD PTR [esi+28], 1024		; 00000400H
	mov	ecx, 1024				; 00000400H
$LN59@ListVerify:

; 52   : 
; 53   :     if ((size == 0 && list->Tail != 0) ||
; 54   :         (size >  0 && list->Tail == 0) ||

	test	edi, edi
	jne	SHORT $LN60@ListVerify
	cmp	DWORD PTR [esi+12], edi
	jne	SHORT $LN13@ListVerify
	jmp	SHORT $LN41@ListVerify
$LN60@ListVerify:
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN13@ListVerify
$LN41@ListVerify:
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [ebx+4]
	je	SHORT $LN57@ListVerify
$LN13@ListVerify:

; 55   :         (list->Tail != nodes[0].Prev))
; 56   :         list->Status |= LIST_ERR_TAIL;

	or	ecx, 2048				; 00000800H
	mov	DWORD PTR [esi+28], ecx
$LN57@ListVerify:

; 57   : 
; 58   :     if (size > capacity)

	cmp	edi, DWORD PTR [esi+20]
	jbe	SHORT $LN58@ListVerify

; 59   :         list->Status |= LIST_ERR_SIZE;

	or	ecx, 2
	mov	DWORD PTR [esi+28], ecx
$LN58@ListVerify:

; 60   : 
; 61   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 62   : 
; 63   :     size_t fillCount = 0;
; 64   :     size_t prevCount = 0;
; 65   :     size_t nextCount = 0;
; 66   : 
; 67   :     size_t nextIndex = 0;
; 68   :     size_t prevIndex = 0;
; 69   : 
; 70   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 71   : 
; 72   :     for (size_t st = 1; st <= capacity; st++)

	mov	ecx, DWORD PTR [esi+20]
	xor	edi, edi
	mov	DWORD PTR _fillCount$1$[ebp], 0
	mov	DWORD PTR _prevCount$1$[ebp], 0
	mov	DWORD PTR _nextCount$1$[ebp], 0
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR _prevIndex$1$[ebp], edi
	cmp	ecx, eax
	jb	SHORT $LN3@ListVerify
	lea	ecx, DWORD PTR [ebx+36]
$LL4@ListVerify:

; 73   :     {
; 74   :         if (! CHECK_FREE_ELEM(list, st))

	cmp	eax, edx
	je	SHORT $LN42@ListVerify
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN2@ListVerify
$LN42@ListVerify:

; 75   :             fillCount++;

	inc	DWORD PTR _fillCount$1$[ebp]
$LN2@ListVerify:

; 60   : 
; 61   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 62   : 
; 63   :     size_t fillCount = 0;
; 64   :     size_t prevCount = 0;
; 65   :     size_t nextCount = 0;
; 66   : 
; 67   :     size_t nextIndex = 0;
; 68   :     size_t prevIndex = 0;
; 69   : 
; 70   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 71   : 
; 72   :     for (size_t st = 1; st <= capacity; st++)

	inc	eax
	add	ecx, 32					; 00000020H
	cmp	eax, DWORD PTR [esi+20]
	jbe	SHORT $LL4@ListVerify
	mov	ecx, DWORD PTR [esi+20]
$LN3@ListVerify:

; 76   :     }
; 77   : 
; 78   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 79   : 
; 80   :     ListNodeCheck* nodeChecker = (ListNodeCheck*)calloc(list->Capacity + 1, sizeof(ListNodeCheck));

	xor	eax, eax
	add	ecx, 1
	push	2
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	mov	DWORD PTR _nodeChecker$1$[ebp], eax

; 81   : 
; 82   :     if (nodeChecker)

	test	eax, eax
	je	$LN19@ListVerify

; 83   :     {
; 84   :         for (size_t st = 0; st <= size + 1; st++)

	xor	edx, edx
$LL7@ListVerify:

; 85   :         {
; 86   :             if (! CHECK_FREE_ELEM(list, nextIndex))

	cmp	edi, DWORD PTR [esi+8]
	je	SHORT $LN55@ListVerify
	mov	eax, DWORD PTR [esi]
	mov	ecx, edi
	shl	ecx, 5
	cmp	DWORD PTR [ecx+eax+4], 0
	je	SHORT $LN54@ListVerify
	mov	eax, DWORD PTR _nodeChecker$1$[ebp]
$LN55@ListVerify:

; 87   :             {
; 88   :                 nextIndex = nodes[st].Next;

	mov	edi, DWORD PTR [ebx]

; 89   : 
; 90   :                 // Массив Next имеет малые закольцованные части, так быть не должно. 
; 91   :                 if (nodeChecker[nextIndex].Next != 0)

	cmp	BYTE PTR [eax+edi*2], 0
	jne	SHORT $LN32@ListVerify

; 92   :                 {
; 93   :                     list->Status |= LIST_ERR_DATA;
; 94   :                     break;
; 95   :                 }
; 96   : 
; 97   :                 nodeChecker[nextIndex].Next++;
; 98   :                 nextCount++;

	inc	DWORD PTR _nextCount$1$[ebp]
	mov	BYTE PTR [eax+edi*2], 1
$LN54@ListVerify:

; 99   :             }
; 100  : 
; 101  :             if (! CHECK_FREE_ELEM(list, prevIndex))

	mov	eax, DWORD PTR _prevIndex$1$[ebp]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN53@ListVerify
	mov	ecx, eax
	mov	eax, DWORD PTR [esi]
	shl	ecx, 5
	cmp	DWORD PTR [ecx+eax+4], 0
	je	SHORT $LN5@ListVerify
$LN53@ListVerify:

; 102  :             {
; 103  :                 prevIndex = nodes[st].Prev;

	mov	eax, DWORD PTR [ebx+4]

; 104  : 
; 105  :                 // Массив Prev имеет малые закольцованные части, так быть не должно. 
; 106  :                 if (nodeChecker[nextIndex].Prev++ != 0)

	mov	esi, DWORD PTR _nodeChecker$1$[ebp]
	mov	DWORD PTR _prevIndex$1$[ebp], eax
	mov	eax, DWORD PTR _nodeChecker$1$[ebp]
	mov	cl, BYTE PTR [eax+edi*2+1]
	lea	eax, DWORD PTR [ecx+1]
	mov	BYTE PTR [esi+edi*2+1], al
	mov	esi, DWORD PTR _list$[ebp]
	test	cl, cl
	jne	SHORT $LN33@ListVerify

; 109  :                     break;
; 110  :                 }
; 111  : 
; 112  :                 prevCount++;

	inc	DWORD PTR _prevCount$1$[ebp]
$LN5@ListVerify:

; 83   :     {
; 84   :         for (size_t st = 0; st <= size + 1; st++)

	mov	ecx, DWORD PTR _size$1$[ebp]
	inc	edx
	mov	eax, DWORD PTR _nodeChecker$1$[ebp]
	inc	ecx
	add	ebx, 32					; 00000020H
	cmp	edx, ecx
	jbe	SHORT $LL7@ListVerify

; 104  : 
; 105  :                 // Массив Prev имеет малые закольцованные части, так быть не должно. 
; 106  :                 if (nodeChecker[nextIndex].Prev++ != 0)

	jmp	SHORT $LN6@ListVerify
$LN33@ListVerify:

; 107  :                 {
; 108  :                     list->Status |= LIST_ERR_DATA;

	mov	eax, DWORD PTR _nodeChecker$1$[ebp]
$LN32@ListVerify:

; 113  :             }
; 114  :         }
; 115  : 
; 116  :         free(nodeChecker);

	or	DWORD PTR [esi+28], 4096		; 00001000H
$LN6@ListVerify:
	push	eax
	call	DWORD PTR __imp__free
	mov	ecx, DWORD PTR [esi+28]
	add	esp, 4

; 121  :     }
; 122  : 
; 123  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 124  : 
; 125  :     if (nextIndex != 0              || // Массив Next не закольцован.
; 126  :         prevIndex != 0              || // Массив Prev не закольцован.
; 127  :         fillCount != size           || // Количество элементов не соответствует значению Size.
; 128  :         nextCount != size           || // + 0 так как считаем не количество связей, 

	mov	eax, ecx
	test	edi, edi
	jne	SHORT $LN28@ListVerify
	mov	edx, ecx
	cmp	DWORD PTR _prevIndex$1$[ebp], edi
	je	SHORT $LN50@ListVerify
$LN28@ListVerify:

; 129  :                                        // которых Size + 1, а количество элементов.
; 130  :         prevCount != size)             // + 0 <---^
; 131  :         list->Status |= LIST_ERR_DATA;

	or	eax, 4096				; 00001000H
	pop	edi
	mov	DWORD PTR [esi+28], eax

; 132  : 
; 133  :     return list->Status;
; 134  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@ListVerify:

; 117  :     }
; 118  :     else
; 119  :     {
; 120  :         list->Status |= LIST_ERR_MEMORY;

	or	DWORD PTR [esi+28], 1
	mov	ecx, DWORD PTR [esi+28]
	mov	edx, ecx
$LN50@ListVerify:

; 121  :     }
; 122  : 
; 123  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 124  : 
; 125  :     if (nextIndex != 0              || // Массив Next не закольцован.
; 126  :         prevIndex != 0              || // Массив Prev не закольцован.
; 127  :         fillCount != size           || // Количество элементов не соответствует значению Size.
; 128  :         nextCount != size           || // + 0 так как считаем не количество связей, 

	mov	ebx, DWORD PTR _size$1$[ebp]
	mov	eax, edx
	cmp	DWORD PTR _fillCount$1$[ebp], ebx
	jne	SHORT $LN28@ListVerify
	cmp	DWORD PTR _nextCount$1$[ebp], ebx
	jne	SHORT $LN28@ListVerify
	cmp	DWORD PTR _prevCount$1$[ebp], ebx
	jne	SHORT $LN28@ListVerify

; 132  : 
; 133  :     return list->Status;
; 134  : }

	pop	edi
	pop	esi
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ListVerify@@YAHPAUList@@@Z ENDP			; ListVerify
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\List\List_Config.h
;	COMDAT ?ListElementToString@@YAXPADIPBT__m128i@@@Z
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_bufferSize$ = 12					; size = 4
_value$ = 16						; size = 4
?ListElementToString@@YAXPADIPBT__m128i@@@Z PROC	; ListElementToString, COMDAT

; 62   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 63   : 	snprintf(buffer, bufferSize, "%*s", (unsigned int)MaximumWordSize, (char*)value);

	push	DWORD PTR _value$[ebp]
	mov	esi, DWORD PTR _buffer$[ebp]
	push	16					; 00000010H
	push	OFFSET ??_C@_03HIJPJGOM@?$CF?$CKs@
	push	DWORD PTR _bufferSize$[ebp]
	push	esi
	call	_snprintf
	add	esp, 20					; 00000014H

; 64   : 
; 65   : 	buffer[MaximumWordSize + 1] = '\0';

	mov	BYTE PTR [esi+17], 0
	pop	esi

; 66   : }

	pop	ebp
	ret	0
?ListElementToString@@YAXPADIPBT__m128i@@@Z ENDP	; ListElementToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1927 :     {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Buffer$[ebp]

; 1928 :         int _Result;
; 1929 :         va_list _ArgList;
; 1930 :         __crt_va_start(_ArgList, _Format);
; 1931 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	eax
	call	_vsnprintf
	add	esp, 16					; 00000010H

; 1932 :         __crt_va_end(_ArgList);
; 1933 :         return _Result;
; 1934 :     }

	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Buffer$[ebp]

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	DWORD PTR __Format$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

	push	ebp
	mov	ebp, esp

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1460 :     }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1438 :     {

	push	ebp
	mov	ebp, esp

; 1439 :         int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 2
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1440 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1441 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1442 : 
; 1443 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1444 :     }

	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

	push	ebp
	mov	ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1397 :     }

	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Stream$[ebp]

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);
; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	DWORD PTR __Format$[ebp]
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H

; 842  :         __crt_va_end(_ArgList);
; 843  :         return _Result;
; 844  :     }

	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

	push	ebp
	mov	ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 646  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
