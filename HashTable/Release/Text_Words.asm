; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31105.0 

	TITLE	D:\Language C\HashTable\HashTable\Release\Text_Words.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?TextParseIntoWords@@YAXPAUTextAnalyzer@@I@Z	; TextParseIntoWords
PUBLIC	?TextParseIntoWordsDirectory_32@@YAXPAUTextAnalyzer@@PBDI@Z ; TextParseIntoWordsDirectory_32
PUBLIC	?TextCountWords@@YAIPBUTextAnalyzer@@I@Z	; TextCountWords
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0DG@PLFIFBKD@D?3?2Language?5C?2HashTable?2HashTab@ ; `string'
PUBLIC	??_C@_0GD@IKFAMKAC@void?5__cdecl?5TextParseIntoWords@ ; `string'
PUBLIC	??_C@_0CP@LPDEDFJB@?M?e?5?s?d?$OA?$LI?r?q?$PP?5?m?$OA?i?r?h?5?r?e?j?q?r?n?b?$PL?e?5?t?$OA?i?k@ ; `string'
PUBLIC	??_C@_08GELMNGAN@tests?2?$CFs@			; `string'
PUBLIC	??_C@_0M@MOGBNGBP@File?5parsed@			; `string'
PUBLIC	??_C@_0EG@DEFJMDHN@void?5__cdecl?5TextAllocWords?$CIstr@ ; `string'
PUBLIC	??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@ ; `string'
EXTRN	__imp__realloc:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z:PROC ; LogLine
EXTRN	?TextReadFile@@YAHPAUTextAnalyzer@@PBD@Z:PROC	; TextReadFile
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
CONST	SEGMENT
??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ' ', 0e2H, 0fbH, 0e4H, 0e5H, 0ebH
	DB	0e5H, 0edH, 0e8H, 0ffH, ' ', 0efH, 0e0H, 0ecH, 0ffH, 0f2H, 0e8H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@DEFJMDHN@void?5__cdecl?5TextAllocWords?$CIstr@
CONST	SEGMENT
??_C@_0EG@DEFJMDHN@void?5__cdecl?5TextAllocWords?$CIstr@ DB 'void __cdecl'
	DB	' TextAllocWords(struct TextAnalyzer *,const unsigned int)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MOGBNGBP@File?5parsed@
CONST	SEGMENT
??_C@_0M@MOGBNGBP@File?5parsed@ DB 'File parsed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GELMNGAN@tests?2?$CFs@
CONST	SEGMENT
??_C@_08GELMNGAN@tests?2?$CFs@ DB 'tests\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LPDEDFJB@?M?e?5?s?d?$OA?$LI?r?q?$PP?5?m?$OA?i?r?h?5?r?e?j?q?r?n?b?$PL?e?5?t?$OA?i?k@
CONST	SEGMENT
??_C@_0CP@LPDEDFJB@?M?e?5?s?d?$OA?$LI?r?q?$PP?5?m?$OA?i?r?h?5?r?e?j?q?r?n?b?$PL?e?5?t?$OA?i?k@ DB 0cdH
	DB	0e5H, ' ', 0f3H, 0e4H, 0e0H, 0b8H, 0f2H, 0f1H, 0ffH, ' ', 0edH
	DB	0e0H, 0e9H, 0f2H, 0e8H, ' ', 0f2H, 0e5H, 0eaH, 0f1H, 0f2H, 0eeH
	DB	0e2H, 0fbH, 0e5H, ' ', 0f4H, 0e0H, 0e9H, 0ebH, 0fbH, ' ', 0e2H
	DB	' ', 0efH, 0e0H, 0efH, 0eaH, 0e5H, ' tests', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@IKFAMKAC@void?5__cdecl?5TextParseIntoWords@
CONST	SEGMENT
??_C@_0GD@IKFAMKAC@void?5__cdecl?5TextParseIntoWords@ DB 'void __cdecl Te'
	DB	'xtParseIntoWordsDirectory_32(struct TextAnalyzer *,const char'
	DB	' *,const unsigned int)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PLFIFBKD@D?3?2Language?5C?2HashTable?2HashTab@
CONST	SEGMENT
??_C@_0DG@PLFIFBKD@D?3?2Language?5C?2HashTable?2HashTab@ DB 'D:\Language '
	DB	'C\HashTable\HashTable\Text\Text_Words.cpp', 00H ; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\Text\Text_Words.cpp
;	COMDAT ?TextAllocWords@@YAXPAUTextAnalyzer@@I@Z
_TEXT	SEGMENT
_text$ = 8						; size = 4
_newCapacity$ = 12					; size = 4
?TextAllocWords@@YAXPAUTextAnalyzer@@I@Z PROC		; TextAllocWords, COMDAT

; 196  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 197  : 	assert(text);
; 198  : 
; 199  : 	if (newCapacity < text->WordsCapacity)

	mov	esi, DWORD PTR _text$[ebp]
	push	edi
	mov	edi, DWORD PTR _newCapacity$[ebp]
	cmp	edi, DWORD PTR [esi+16]
	jb	SHORT $LN1@TextAllocW

; 200  : 		return;
; 201  : 
; 202  : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 203  : 
; 204  : 	Word* ptr = (Word*)realloc(text->Words, sizeof(Word) * newCapacity);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	push	DWORD PTR [esi+20]
	call	DWORD PTR __imp__realloc
	add	esp, 8

; 205  : 
; 206  : 	if (!ptr)

	test	eax, eax
	jne	SHORT $LN3@TextAllocW

; 207  : 	{
; 208  : 		LOG_ERR_MEMORY;

	push	208					; 000000d0H
	push	OFFSET ??_C@_0DG@PLFIFBKD@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0EG@DEFJMDHN@void?5__cdecl?5TextAllocWords?$CIstr@
	push	1
	push	eax
	push	4
	push	OFFSET ??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine
	add	esp, 28					; 0000001cH

; 209  : 
; 210  : 		text->Status |= TEXT_ERR_MEMORY;

	or	DWORD PTR [esi+24], 2
	pop	edi

; 219  : }

	pop	esi
	pop	ebp
	ret	0
$LN3@TextAllocW:

; 211  : 
; 212  : 		return;
; 213  : 	}
; 214  : 
; 215  : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 216  : 
; 217  : 	text->WordsCapacity = newCapacity;

	mov	DWORD PTR [esi+16], edi

; 218  : 	text->Words = ptr;

	mov	DWORD PTR [esi+20], eax
$LN1@TextAllocW:

; 219  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	0
?TextAllocWords@@YAXPAUTextAnalyzer@@I@Z ENDP		; TextAllocWords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\Text\Text_Words.cpp
;	COMDAT ?TextCountWords@@YAIPBUTextAnalyzer@@I@Z
_TEXT	SEGMENT
_textsCount$1$ = 8					; size = 4
_text$ = 8						; size = 4
_maxWordLength$ = 12					; size = 4
?TextCountWords@@YAIPBUTextAnalyzer@@I@Z PROC		; TextCountWords, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp

; 145  : 	assert(text);
; 146  : 
; 147  : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 148  : 
; 149  : 	size_t wordsCount = 0;
; 150  : 
; 151  : 	const size_t textsCount = text->TextsSize;

	mov	eax, DWORD PTR _text$[ebp]
	push	edi
	xor	edi, edi
	mov	ecx, DWORD PTR [eax]

; 152  : 	const Text*  texts      = text->Texts;

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _textsCount$1$[ebp], ecx

; 153  : 
; 154  : 	for (size_t st = 0; st < textsCount; st++)

	test	ecx, ecx
	je	SHORT $LN27@TextCountW

; 145  : 	assert(text);
; 146  : 
; 147  : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 148  : 
; 149  : 	size_t wordsCount = 0;
; 150  : 
; 151  : 	const size_t textsCount = text->TextsSize;

	push	ebx
	push	esi
	lea	ebx, DWORD PTR [eax+4]
	npad	6
$LL4@TextCountW:

; 155  : 	{
; 156  : 		size_t wordSize    = 0;
; 157  : 		bool   wordStarted = false;
; 158  : 
; 159  : 		const char* data = texts[st].Data;

	mov	esi, DWORD PTR [ebx]
	xor	ecx, ecx
	xor	dl, dl

; 160  : 
; 161  : 		//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 162  : 
; 163  : 		while (*data)

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN2@TextCountW
	npad	4
$LL5@TextCountW:

; 164  : 		{
; 165  : 			if (wordStarted == false)

	test	dl, dl
	jne	SHORT $LN7@TextCountW

; 166  : 			{
; 167  : 				if (IS_LETTER(*data))

	cmp	al, 97					; 00000061H
	jl	SHORT $LN11@TextCountW
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN10@TextCountW
$LN11@TextCountW:
	sub	al, 65					; 00000041H
	cmp	al, 25					; 00000019H
	ja	SHORT $LN13@TextCountW
$LN10@TextCountW:

; 168  : 				{
; 169  : 					wordSize    = 1;

	mov	ecx, 1

; 170  : 					wordStarted = true;

	mov	dl, cl

; 171  : 				}
; 172  : 			}

	jmp	SHORT $LN13@TextCountW
$LN7@TextCountW:

; 173  : 			else
; 174  : 			{
; 175  : 				if (!IS_LETTER(*data))

	cmp	al, 97					; 00000061H
	jl	SHORT $LN14@TextCountW
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN26@TextCountW
$LN14@TextCountW:
	sub	al, 65					; 00000041H
	cmp	al, 25					; 00000019H
	ja	SHORT $LN15@TextCountW
$LN26@TextCountW:

; 181  : 				}
; 182  : 				else
; 183  : 					wordSize++;

	inc	ecx
	jmp	SHORT $LN13@TextCountW
$LN15@TextCountW:

; 176  : 				{
; 177  : 					if (wordSize <= maxWordLength)
; 178  : 						wordsCount++;
; 179  : 
; 180  : 					wordStarted = false;

	xor	dl, dl
	lea	eax, DWORD PTR [edi+1]
	cmp	ecx, DWORD PTR _maxWordLength$[ebp]
	cmova	eax, edi
	mov	edi, eax
$LN13@TextCountW:

; 184  : 			}
; 185  : 
; 186  : 			data++;

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	jne	SHORT $LL5@TextCountW
$LN2@TextCountW:

; 153  : 
; 154  : 	for (size_t st = 0; st < textsCount; st++)

	add	ebx, 8
	sub	DWORD PTR _textsCount$1$[ebp], 1
	jne	SHORT $LL4@TextCountW

; 187  : 		}
; 188  : 	}
; 189  : 
; 190  : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 191  : 
; 192  : 	return wordsCount;

	pop	esi
	pop	ebx
$LN27@TextCountW:

; 193  : }

	mov	eax, edi
	pop	edi
	pop	ebp
	ret	0
?TextCountWords@@YAIPBUTextAnalyzer@@I@Z ENDP		; TextCountWords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\Text\Text_Words.cpp
;	COMDAT ?TextParseIntoWordsDirectory_32@@YAXPAUTextAnalyzer@@PBDI@Z
_TEXT	SEGMENT
_fileData$ = -1348					; size = 320
_filePath$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_folderPath$ = 12					; size = 4
_maximumWordSize$ = 16					; size = 4
?TextParseIntoWordsDirectory_32@@YAXPAUTextAnalyzer@@PBDI@Z PROC ; TextParseIntoWordsDirectory_32, COMDAT

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1348				; 00000544H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _folderPath$[ebp]

; 32   : 	assert(text);
; 33   : 	assert(folderPath);
; 34   : 
; 35   : 	WIN32_FIND_DATAA fileData = {};

	lea	eax, DWORD PTR _fileData$[ebp]
	push	edi
	mov	edi, DWORD PTR _text$[ebp]
	push	320					; 00000140H
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 36   : 
; 37   : 	HANDLE handle = FindFirstFileA(folderPath, &fileData);

	lea	eax, DWORD PTR _fileData$[ebp]
	push	eax
	push	esi
	call	DWORD PTR __imp__FindFirstFileA@8
	mov	esi, eax

; 38   : 
; 39   : 	if (handle == INVALID_HANDLE_VALUE)

	cmp	esi, -1
	jne	SHORT $LN5@TextParseI

; 40   : 	{
; 41   : 		LOG_ERR("Не удаётся найти текстовые файлы в папке tests");

	push	41					; 00000029H
	push	OFFSET ??_C@_0DG@PLFIFBKD@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0GD@IKFAMKAC@void?5__cdecl?5TextParseIntoWords@
	push	1
	push	0
	push	4
	push	OFFSET ??_C@_0CP@LPDEDFJB@?M?e?5?s?d?$OA?$LI?r?q?$PP?5?m?$OA?i?r?h?5?r?e?j?q?r?n?b?$PL?e?5?t?$OA?i?k@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine
	add	esp, 28					; 0000001cH

; 42   : 
; 43   : 		text->Status |= TEXT_ERR_FILE;

	or	DWORD PTR [edi+24], 4
	pop	edi

; 66   : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@TextParseI:
	push	ebx

; 44   : 
; 45   : 		return;
; 46   : 	}
; 47   : 
; 48   : 	char filePath[1024] = "";

	push	1024					; 00000400H
	lea	eax, DWORD PTR _filePath$[ebp]
	push	0
	push	eax
	call	_memset
	mov	ebx, DWORD PTR __imp__FindNextFileA@8
	add	esp, 12					; 0000000cH
	npad	10
$LL4@TextParseI:

; 49   : 
; 50   : 	do
; 51   : 	{
; 52   : 		sprintf(filePath, "tests\\%s", fileData.cFileName);

	lea	eax, DWORD PTR _fileData$[ebp+44]
	push	eax
	lea	eax, DWORD PTR _filePath$[ebp]
	push	OFFSET ??_C@_08GELMNGAN@tests?2?$CFs@
	push	eax
	call	_sprintf

; 53   : 
; 54   : 		TextReadFile(text, filePath);

	lea	eax, DWORD PTR _filePath$[ebp]
	push	eax
	push	edi
	call	?TextReadFile@@YAHPAUTextAnalyzer@@PBD@Z ; TextReadFile
	add	esp, 20					; 00000014H

; 55   : 
; 56   : 		if (text->Status != TEXT_ERR_NO_ERRORS)

	cmp	DWORD PTR [edi+24], 0
	jne	SHORT $LN3@TextParseI

; 57   : 			break;
; 58   : 
; 59   : 	} while (FindNextFileA(handle, &fileData));

	lea	eax, DWORD PTR _fileData$[ebp]
	push	eax
	push	esi
	call	ebx
	test	eax, eax
	jne	SHORT $LL4@TextParseI
$LN3@TextParseI:

; 60   : 
; 61   : 	TextParseIntoWords(text, maximumWordSize);

	push	DWORD PTR _maximumWordSize$[ebp]
	push	edi
	call	?TextParseIntoWords@@YAXPAUTextAnalyzer@@I@Z ; TextParseIntoWords

; 62   : 
; 63   : 	LOG_DBG("File parsed");

	push	63					; 0000003fH
	push	OFFSET ??_C@_0DG@PLFIFBKD@D?3?2Language?5C?2HashTable?2HashTab@
	push	OFFSET ??_C@_0GD@IKFAMKAC@void?5__cdecl?5TextParseIntoWords@
	push	1
	push	0
	push	1
	push	OFFSET ??_C@_0M@MOGBNGBP@File?5parsed@
	call	?LogLine@@YAXPBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine
	add	esp, 36					; 00000024H

; 64   : 
; 65   : 	FindClose(handle);

	push	esi
	call	DWORD PTR __imp__FindClose@4

; 66   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?TextParseIntoWordsDirectory_32@@YAXPAUTextAnalyzer@@PBDI@Z ENDP ; TextParseIntoWordsDirectory_32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Language C\HashTable\HashTable\Text\Text_Words.cpp
;	COMDAT ?TextParseIntoWords@@YAXPAUTextAnalyzer@@I@Z
_TEXT	SEGMENT
_words$1$ = -12						; size = 4
_textsCount$1$ = -8					; size = 4
tv413 = -4						; size = 4
_text$ = 8						; size = 4
_maxWordLength$ = 12					; size = 4
?TextParseIntoWords@@YAXPAUTextAnalyzer@@I@Z PROC	; TextParseIntoWords, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 70   : 	assert(text);
; 71   : 	assert(text->Texts);
; 72   : 
; 73   : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 74   : 
; 75   : 	size_t  wordIndex   = text->WordsSize;

	mov	ebx, DWORD PTR _text$[ebp]
	push	edi

; 76   : 	bool    wordStarted = false;
; 77   : 
; 78   : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 79   : 	
; 80   : 	size_t newCapacity = TextCountWords(text, maxWordLength) + text->WordsSize;

	push	DWORD PTR _maxWordLength$[ebp]
	mov	edi, DWORD PTR [ebx+12]
	push	ebx
	call	?TextCountWords@@YAIPBUTextAnalyzer@@I@Z ; TextCountWords
	add	eax, edi

; 81   : 
; 82   : 	TextAllocWords(text, newCapacity);

	push	eax
	push	ebx
	call	?TextAllocWords@@YAXPAUTextAnalyzer@@I@Z ; TextAllocWords
	add	esp, 16					; 00000010H

; 83   : 
; 84   : 	if (text->Status != TEXT_ERR_NO_ERRORS)

	cmp	DWORD PTR [ebx+24], 0
	jne	$LN1@TextParseI

; 85   : 		return;
; 86   : 
; 87   : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 88   : 	
; 89   : 	const size_t textsCount = text->TextsSize;

	mov	edx, DWORD PTR [ebx]

; 90   : 	const Text*  texts      = text->Texts;
; 91   : 	      Word*  words      = text->Words;

	mov	ecx, DWORD PTR [ebx+20]
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _textsCount$1$[ebp], edx
	mov	DWORD PTR _words$1$[ebp], ecx

; 92   : 
; 93   : 	for (size_t st = 0; st < textsCount; st++)

	test	edx, edx
	je	SHORT $LN3@TextParseI

; 85   : 		return;
; 86   : 
; 87   : 	//***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 88   : 	
; 89   : 	const size_t textsCount = text->TextsSize;

	add	eax, 4
	mov	DWORD PTR tv413[ebp], eax
	push	esi
$LL4@TextParseI:

; 94   : 	{
; 95   : 		size_t wordSize    = 0;
; 96   : 		bool   wordStarted = false;
; 97   : 		char*  wordStart   = nullptr;
; 98   : 
; 99   : 		char*  data        = texts[st].Data;

	mov	esi, DWORD PTR [eax]
	xor	ecx, ecx
	xor	dl, dl
	xor	ebx, ebx

; 100  : 
; 101  : 		while (*data)

	mov	al, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN2@TextParseI
$LL5@TextParseI:

; 102  : 		{
; 103  : 			if (wordStarted == false)

	test	dl, dl
	jne	SHORT $LN8@TextParseI

; 104  : 			{
; 105  : 				if (IS_LETTER(*data))

	cmp	al, 97					; 00000061H
	jl	SHORT $LN12@TextParseI
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN11@TextParseI
$LN12@TextParseI:
	sub	al, 65					; 00000041H
	cmp	al, 25					; 00000019H
	ja	SHORT $LN14@TextParseI
$LN11@TextParseI:

; 106  : 				{
; 107  : 					wordStart   = data;
; 108  : 					wordSize    = 1;

	mov	ecx, 1
	mov	ebx, esi

; 109  : 
; 110  : 					wordStarted = true;

	mov	dl, cl

; 111  : 				}
; 112  : 			}

	jmp	SHORT $LN14@TextParseI
$LN8@TextParseI:

; 113  : 			else
; 114  : 			{
; 115  : 				if (IS_LETTER(*data))

	cmp	al, 97					; 00000061H
	jl	SHORT $LN16@TextParseI
	cmp	al, 122					; 0000007aH
	jle	SHORT $LN27@TextParseI
$LN16@TextParseI:
	sub	al, 65					; 00000041H
	cmp	al, 25					; 00000019H
	ja	SHORT $LN13@TextParseI
$LN27@TextParseI:

; 116  : 				{
; 117  : 					wordSize++;

	inc	ecx

; 118  : 				}

	jmp	SHORT $LN14@TextParseI
$LN13@TextParseI:

; 119  : 				else
; 120  : 				{
; 121  : 					if (wordSize <= maxWordLength)

	cmp	ecx, DWORD PTR _maxWordLength$[ebp]
	ja	SHORT $LN17@TextParseI

; 122  : 					{
; 123  : 						words[wordIndex].Data = wordStart;

	mov	eax, DWORD PTR _words$1$[ebp]
	mov	DWORD PTR [eax+edi*8], ebx

; 124  : 						words[wordIndex].Size = wordSize;

	mov	DWORD PTR [eax+edi*8+4], ecx

; 125  : 
; 126  : 						wordIndex++;

	inc	edi
$LN17@TextParseI:

; 127  : 					}
; 128  : 
; 129  : 					wordStarted = false;

	xor	dl, dl
$LN14@TextParseI:

; 100  : 
; 101  : 		while (*data)

	mov	al, BYTE PTR [esi+1]

; 130  : 				}
; 131  : 			}
; 132  : 
; 133  : 			data++;

	inc	esi
	test	al, al
	jne	SHORT $LL5@TextParseI
$LN2@TextParseI:

; 92   : 
; 93   : 	for (size_t st = 0; st < textsCount; st++)

	mov	eax, DWORD PTR tv413[ebp]
	add	eax, 8
	sub	DWORD PTR _textsCount$1$[ebp], 1
	mov	DWORD PTR tv413[ebp], eax
	jne	SHORT $LL4@TextParseI
	mov	ebx, DWORD PTR _text$[ebp]
	pop	esi
$LN3@TextParseI:

; 134  : 		}
; 135  : 	}
; 136  : 
; 137  : 	text->WordsSize = wordIndex;

	mov	DWORD PTR [ebx+12], edi
$LN1@TextParseI:
	pop	edi

; 138  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TextParseIntoWords@@YAXPAUTextAnalyzer@@I@Z ENDP	; TextParseIntoWords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Buffer$[ebp]

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	DWORD PTR __Format$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

	push	ebp
	mov	ebp, esp

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1460 :     }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

	push	ebp
	mov	ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1397 :     }

	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
