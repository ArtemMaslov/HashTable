; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31105.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@ ; `string'
PUBLIC	??_C@_0EC@KEKCIHEG@int?5__cdecl?5ListConstructor?$CIstr@ ; `string'
PUBLIC	??_C@_0CN@DEHHELMC@?P?$OA?g?l?e?p?5?q?o?h?q?j?$OA?5?$DN?5?$CFzd?5?a?n?k?$PM?x?e?5?b?l?e?q@ ; `string'
PUBLIC	??_C@_0FJ@HAJEJENN@int?5__cdecl?5ListAddElemAfter?$CIst@ ; `string'
PUBLIC	??_C@_0DJ@LCGIIKOJ@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?n?q?k?e?5@ ; `string'
PUBLIC	??_C@_0FK@PLCLFHKH@int?5__cdecl?5ListAddElemBefore?$CIs@ ; `string'
PUBLIC	??_C@_0DI@GIIDHNGH@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?e?p?e?d?5@ ; `string'
PUBLIC	??_C@_0EB@JHOHHLIL@int?5__cdecl?5ListRemoveElem?$CIstru@ ; `string'
PUBLIC	??_C@_0CL@IKBFECN@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?$PN?k?e?l?e?m?r?5?h?g?5?o?s?q?r@ ; `string'
PUBLIC	??_C@_0DB@GHEAINCG@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?o?s?q?r?n?i?5?$PN?k?e?l?e?m?r?4@ ; `string'
PUBLIC	??_C@_0GB@GEKNKDCH@?O?n?o?$PL?r?j?$OA?5?o?n?k?s?w?h?r?$PM?5?d?n?q?r?s?o?5?j?5?m?e?5?q?s@ ; `string'
PUBLIC	??_C@_0EL@CAKBLDLE@union?5__m128i?5?$CK__cdecl?5ListGetE@ ; `string'
PUBLIC	??_C@_0GB@ELFHLDAC@?M?e?o?p?e?d?b?h?d?e?m?m?$OA?$PP?5?n?x?h?a?j?$OA?4?5?H?q?o?n?k?m?e?m@ ; `string'
PUBLIC	??_C@_0FA@NIHCFIGK@unsigned?5__int64?5__cdecl?5GetPhy@ ; `string'
PUBLIC	??_C@_0CG@HCIHDPOL@int?5__cdecl?5ListResize?$CIstruct?5L@ ; `string'
;	COMDAT ??_C@_0CG@HCIHDPOL@int?5__cdecl?5ListResize?$CIstruct?5L@
CONST	SEGMENT
??_C@_0CG@HCIHDPOL@int?5__cdecl?5ListResize?$CIstruct?5L@ DB 'int __cdecl'
	DB	' ListResize(struct List *)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NIHCFIGK@unsigned?5__int64?5__cdecl?5GetPhy@
CONST	SEGMENT
??_C@_0FA@NIHCFIGK@unsigned?5__int64?5__cdecl?5GetPhy@ DB 'unsigned __int'
	DB	'64 __cdecl GetPhysicalIndex(struct List *,const unsigned __in'
	DB	't64)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@ELFHLDAC@?M?e?o?p?e?d?b?h?d?e?m?m?$OA?$PP?5?n?x?h?a?j?$OA?4?5?H?q?o?n?k?m?e?m@
CONST	SEGMENT
??_C@_0GB@ELFHLDAC@?M?e?o?p?e?d?b?h?d?e?m?m?$OA?$PP?5?n?x?h?a?j?$OA?4?5?H?q?o?n?k?m?e?m@ DB 0cdH
	DB	0e5H, 0efH, 0f0H, 0e5H, 0e4H, 0e2H, 0e8H, 0e4H, 0e5H, 0edH, 0edH
	DB	0e0H, 0ffH, ' ', 0eeH, 0f8H, 0e8H, 0e1H, 0eaH, 0e0H, '. ', 0c8H
	DB	0f1H, 0efH, 0eeH, 0ebH, 0edH, 0e5H, 0edH, 0e8H, 0e5H, ' ', 0edH
	DB	0e5H, ' ', 0e2H, 0eeH, 0e7H, 0ecH, 0eeH, 0e6H, 0edH, 0eeH, 0e3H
	DB	0eeH, ' ', 0eaH, 0eeH, 0e4H, 0e0H, '. ', 0cbH, 0eeH, 0e3H, 0e8H
	DB	0f7H, 0e5H, 0f1H, 0eaH, 0e8H, 0e9H, ' ', 0fdH, 0ebH, 0e5H, 0ecH
	DB	0e5H, 0edH, 0f2H, ' ', 0edH, 0e5H, ' ', 0e1H, 0fbH, 0ebH, ' ', 0edH
	DB	0e0H, 0e9H, 0e4H, 0e5H, 0edH, ' ', 0e2H, ' ', 0f1H, 0efH, 0e8H
	DB	0f1H, 0eaH, 0e5H, '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@CAKBLDLE@union?5__m128i?5?$CK__cdecl?5ListGetE@
CONST	SEGMENT
??_C@_0EL@CAKBLDLE@union?5__m128i?5?$CK__cdecl?5ListGetE@ DB 'union __m12'
	DB	'8i *__cdecl ListGetElemAt(struct List *,const unsigned __int6'
	DB	'4)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@GEKNKDCH@?O?n?o?$PL?r?j?$OA?5?o?n?k?s?w?h?r?$PM?5?d?n?q?r?s?o?5?j?5?m?e?5?q?s@
CONST	SEGMENT
??_C@_0GB@GEKNKDCH@?O?n?o?$PL?r?j?$OA?5?o?n?k?s?w?h?r?$PM?5?d?n?q?r?s?o?5?j?5?m?e?5?q?s@ DB 0cfH
	DB	0eeH, 0efH, 0fbH, 0f2H, 0eaH, 0e0H, ' ', 0efH, 0eeH, 0ebH, 0f3H
	DB	0f7H, 0e8H, 0f2H, 0fcH, ' ', 0e4H, 0eeH, 0f1H, 0f2H, 0f3H, 0efH
	DB	' ', 0eaH, ' ', 0edH, 0e5H, ' ', 0f1H, 0f3H, 0f9H, 0e5H, 0f1H, 0f2H
	DB	0e2H, 0f3H, 0feH, 0f9H, 0e5H, 0ecH, 0f3H, ' ', 0fdH, 0ebH, 0e5H
	DB	0ecH, 0e5H, 0edH, 0f2H, 0f3H, ' ', 0f1H, 0efH, 0e8H, 0f1H, 0eaH
	DB	0e0H, '. logicalIndex = %zd, list->Size = %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GHEAINCG@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?o?s?q?r?n?i?5?$PN?k?e?l?e?m?r?4@
CONST	SEGMENT
??_C@_0DB@GHEAINCG@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?o?s?q?r?n?i?5?$PN?k?e?l?e?m?r?4@ DB 0cfH
	DB	0eeH, 0efH, 0fbH, 0f2H, 0eaH, 0e0H, ' ', 0f3H, 0e4H, 0e0H, 0ebH
	DB	0e8H, 0f2H, 0fcH, ' ', 0efH, 0f3H, 0f1H, 0f2H, 0eeH, 0e9H, ' ', 0fdH
	DB	0ebH, 0e5H, 0ecH, 0e5H, 0edH, 0f2H, '. dataIndex = %zd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IKBFECN@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?$PN?k?e?l?e?m?r?5?h?g?5?o?s?q?r@
CONST	SEGMENT
??_C@_0CL@IKBFECN@?O?n?o?$PL?r?j?$OA?5?s?d?$OA?k?h?r?$PM?5?$PN?k?e?l?e?m?r?5?h?g?5?o?s?q?r@ DB 0cfH
	DB	0eeH, 0efH, 0fbH, 0f2H, 0eaH, 0e0H, ' ', 0f3H, 0e4H, 0e0H, 0ebH
	DB	0e8H, 0f2H, 0fcH, ' ', 0fdH, 0ebH, 0e5H, 0ecH, 0e5H, 0edH, 0f2H
	DB	' ', 0e8H, 0e7H, ' ', 0efH, 0f3H, 0f1H, 0f2H, 0eeH, 0e3H, 0eeH
	DB	' ', 0f1H, 0efH, 0e8H, 0f1H, 0eaH, 0e0H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@JHOHHLIL@int?5__cdecl?5ListRemoveElem?$CIstru@
CONST	SEGMENT
??_C@_0EB@JHOHHLIL@int?5__cdecl?5ListRemoveElem?$CIstru@ DB 'int __cdecl '
	DB	'ListRemoveElem(struct List *,const unsigned __int64)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GIIDHNGH@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?e?p?e?d?5@
CONST	SEGMENT
??_C@_0DI@GIIDHNGH@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?e?p?e?d?5@ DB 0cfH
	DB	0eeH, 0efH, 0fbH, 0f2H, 0eaH, 0e0H, ' ', 0e4H, 0eeH, 0e1H, 0e0H
	DB	0e2H, 0e8H, 0f2H, 0fcH, ' ', 0fdH, 0ebH, 0e5H, 0ecH, 0e5H, 0edH
	DB	0f2H, ' ', 0efH, 0e5H, 0f0H, 0e5H, 0e4H, ' ', 0efH, 0f3H, 0f1H
	DB	0f2H, 0fbH, 0ecH, '. dataIndex = %zd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@PLCLFHKH@int?5__cdecl?5ListAddElemBefore?$CIs@
CONST	SEGMENT
??_C@_0FK@PLCLFHKH@int?5__cdecl?5ListAddElemBefore?$CIs@ DB 'int __cdecl '
	DB	'ListAddElemBefore(struct List *,const union __m128i *,const u'
	DB	'nsigned __int64)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LCGIIKOJ@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?n?q?k?e?5@
CONST	SEGMENT
??_C@_0DJ@LCGIIKOJ@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?n?q?k?e?5@ DB 0cfH
	DB	0eeH, 0efH, 0fbH, 0f2H, 0eaH, 0e0H, ' ', 0e4H, 0eeH, 0e1H, 0e0H
	DB	0e2H, 0e8H, 0f2H, 0fcH, ' ', 0fdH, 0ebH, 0e5H, 0ecH, 0e5H, 0edH
	DB	0f2H, ' ', 0efH, 0eeH, 0f1H, 0ebH, 0e5H, ' ', 0efH, 0f3H, 0f1H
	DB	0f2H, 0eeH, 0e3H, 0eeH, '. dataIndex = %zd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@HAJEJENN@int?5__cdecl?5ListAddElemAfter?$CIst@
CONST	SEGMENT
??_C@_0FJ@HAJEJENN@int?5__cdecl?5ListAddElemAfter?$CIst@ DB 'int __cdecl '
	DB	'ListAddElemAfter(struct List *,const union __m128i *,const un'
	DB	'signed __int64)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DEHHELMC@?P?$OA?g?l?e?p?5?q?o?h?q?j?$OA?5?$DN?5?$CFzd?5?a?n?k?$PM?x?e?5?b?l?e?q@
CONST	SEGMENT
??_C@_0CN@DEHHELMC@?P?$OA?g?l?e?p?5?q?o?h?q?j?$OA?5?$DN?5?$CFzd?5?a?n?k?$PM?x?e?5?b?l?e?q@ DB 0d0H
	DB	0e0H, 0e7H, 0ecH, 0e5H, 0f0H, ' ', 0f1H, 0efH, 0e8H, 0f1H, 0eaH
	DB	0e0H, ' = %zd ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0e5H, ' ', 0e2H
	DB	0ecH, 0e5H, 0f1H, 0f2H, 0e8H, 0ecH, 0eeH, 0f1H, 0f2H, 0e8H, ' '
	DB	'= %zd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@KEKCIHEG@int?5__cdecl?5ListConstructor?$CIstr@
CONST	SEGMENT
??_C@_0EC@KEKCIHEG@int?5__cdecl?5ListConstructor?$CIstr@ DB 'int __cdecl '
	DB	'ListConstructor(struct List *,const unsigned __int64)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
CONST	SEGMENT
??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@ DB 'D:\Language '
	DB	'C\HashTable\HashTable\List\List.cpp', 00H	; `string'
PUBLIC	?ListFind@@YA_KPEBUList@@PEBT__m128i@@@Z	; ListFind
PUBLIC	?ListConstructor@@YAHPEAUList@@_K@Z		; ListConstructor
PUBLIC	?ListDestructor@@YAXPEAUList@@@Z		; ListDestructor
PUBLIC	?ListAddElemAfter@@YAHPEAUList@@PEBT__m128i@@_K@Z ; ListAddElemAfter
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ListResize@@YAHPEAUList@@@Z DD imagerel ?ListResize@@YAHPEAUList@@@Z
	DD	imagerel ?ListResize@@YAHPEAUList@@@Z+670
	DD	imagerel $unwind$?ListResize@@YAHPEAUList@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ListFind@@YA_KPEBUList@@PEBT__m128i@@@Z DD imagerel $LN17
	DD	imagerel $LN17+112
	DD	imagerel $unwind$?ListFind@@YA_KPEBUList@@PEBT__m128i@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ListConstructor@@YAHPEAUList@@_K@Z DD imagerel $LN19
	DD	imagerel $LN19+410
	DD	imagerel $unwind$?ListConstructor@@YAHPEAUList@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ListDestructor@@YAXPEAUList@@@Z DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$?ListDestructor@@YAXPEAUList@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ListAddElemAfter@@YAHPEAUList@@PEBT__m128i@@_K@Z DD imagerel $LN17
	DD	imagerel $LN17+354
	DD	imagerel $unwind$?ListAddElemAfter@@YAHPEAUList@@PEBT__m128i@@_K@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ListAddElemAfter@@YAHPEAUList@@PEBT__m128i@@_K@Z DD 088301H
	DD	0c7483H
	DD	0e540fH
	DD	0d340fH
	DD	0600b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ListDestructor@@YAXPEAUList@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ListConstructor@@YAHPEAUList@@_K@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ListFind@@YA_KPEBUList@@PEBT__m128i@@@Z DD 020601H
	DD	030021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ListResize@@YAHPEAUList@@@Z DD 08c901H
	DD	0a54c9H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
; Function compile flags: /Ogtpy
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListAddElemAfter@@YAHPEAUList@@PEBT__m128i@@_K@Z
_TEXT	SEGMENT
list$ = 96
value$ = 104
dataIndex$ = 112
?ListAddElemAfter@@YAHPEAUList@@PEBT__m128i@@_K@Z PROC	; ListAddElemAfter, COMDAT

; 118  : {

$LN17:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	sub	rsp, 80					; 00000050H
	mov	rbx, rcx
	mov	rsi, r8

; 119  :     LOG_LIST_TRACE_FUNC_0;
; 120  : 
; 121  :     assert(list);
; 122  :     assert(value);
; 123  : 
; 124  :     LIST_ASSERT_STATUS;
; 125  : 
; 126  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 127  : 
; 128  :     if (list->Size > list->Capacity)

	mov	rcx, QWORD PTR [rcx+32]
	mov	rbp, rdx
	mov	r8, QWORD PTR [rbx+40]
	cmp	rcx, r8
	jbe	SHORT $LN2@ListAddEle

; 129  :     {
; 130  :         LOG_F_LIST_ERR("Размер списка = %zd больше вместимости = %zd", list->Size, list->Capacity);

	mov	QWORD PTR [rsp+64], r8
	lea	rax, OFFSET FLAT:??_C@_0CN@DEHHELMC@?P?$OA?g?l?e?p?5?q?o?h?q?j?$OA?5?$DN?5?$CFzd?5?a?n?k?$PM?x?e?5?b?l?e?q@
	mov	QWORD PTR [rsp+56], rcx
	lea	r9, OFFSET FLAT:??_C@_0FJ@HAJEJENN@int?5__cdecl?5ListAddElemAfter?$CIst@
	mov	QWORD PTR [rsp+48], rax
	xor	r8d, r8d
	lea	rax, OFFSET FLAT:??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	mov	DWORD PTR [rsp+40], 130			; 00000082H
	mov	QWORD PTR [rsp+32], rax
	lea	edx, QWORD PTR [r8+2]
	lea	ecx, QWORD PTR [rdx+2]
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPEBD3H3ZZ ; LogFLine

; 131  : 
; 132  :         list->Status |= LIST_ERR_SIZE;

	mov	eax, DWORD PTR [rbx+52]
	or	eax, 2
	mov	DWORD PTR [rbx+52], eax

; 199  : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rsi
	ret	0
$LN2@ListAddEle:
	mov	QWORD PTR [rsp+96], rdi

; 133  : 
; 134  :         return list->Status;
; 135  :     }
; 136  : 
; 137  :     if (CHECK_FREE_ELEM(list, dataIndex))

	mov	rdi, rsi
	shl	rdi, 5
	cmp	rsi, QWORD PTR [rbx+16]
	je	SHORT $LN10@ListAddEle
	mov	rax, QWORD PTR [rbx]
	cmp	QWORD PTR [rax+rdi+8], 0
	jne	SHORT $LN10@ListAddEle

; 138  :     {
; 139  :         LOG_F_LIST_ERR("Попытка добавить элемент после пустого. dataIndex = %zd.", dataIndex);

	mov	QWORD PTR [rsp+56], rsi
	lea	rax, OFFSET FLAT:??_C@_0DJ@LCGIIKOJ@?O?n?o?$PL?r?j?$OA?5?d?n?a?$OA?b?h?r?$PM?5?$PN?k?e?l?e?m?r?5?o?n?q?k?e?5@
	mov	QWORD PTR [rsp+48], rax
	lea	r9, OFFSET FLAT:??_C@_0FJ@HAJEJENN@int?5__cdecl?5ListAddElemAfter?$CIst@
	xor	r8d, r8d
	mov	DWORD PTR [rsp+40], 139			; 0000008bH
	lea	rax, OFFSET FLAT:??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	mov	QWORD PTR [rsp+32], rax
	lea	edx, QWORD PTR [r8+2]
	lea	ecx, QWORD PTR [rdx+2]
	call	?LogFLine@@YAXW4LogLevel@@W4LogSignature@@_NPEBD3H3ZZ ; LogFLine

; 140  : 
; 141  :         list->Status |= LIST_ERR_ADD_FREE;

	mov	eax, DWORD PTR [rbx+52]
	or	eax, 8
	mov	DWORD PTR [rbx+52], eax

; 142  : 
; 143  :         return list->Status;

	jmp	SHORT $LN14@ListAddEle
$LN10@ListAddEle:

; 144  :     }
; 145  : 
; 146  :     // Список полон, выделяем место.
; 147  :     if (CHECK_LIST_FULL(list))

	cmp	rcx, r8
	jne	SHORT $LN13@ListAddEle

; 148  :     {
; 149  :         if (ListResize(list) != LIST_ERR_NO_ERRORS)

	mov	rcx, rbx
	call	?ListResize@@YAHPEAUList@@@Z		; ListResize
	test	eax, eax
	jne	SHORT $LN15@ListAddEle
$LN13@ListAddEle:

; 150  :             return list->Status;
; 151  :     }
; 152  : 
; 153  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 154  : 
; 155  :     ListNode* nodes = list->Nodes;

	mov	r8, QWORD PTR [rbx]

; 156  : 
; 157  :     // Найти пустое место в списке.
; 158  :     const size_t insertElemIndex = FIND_EMPTY_PLACE(list);

	mov	rdx, QWORD PTR [rbx+8]

; 159  : 
; 160  :     // Если вставляем элемент не в конец списка, то сбивается сортировка.
; 161  :     // Иначе он становится хвостом списка.
; 162  :     if (list->Tail != dataIndex) 

	cmp	QWORD PTR [rbx+24], rsi
	je	SHORT $LN6@ListAddEle

; 163  :         list->Sorted = false;

	mov	BYTE PTR [rbx+48], 0
	jmp	SHORT $LN7@ListAddEle
$LN6@ListAddEle:

; 164  :     else
; 165  :         list->Tail = insertElemIndex;

	mov	QWORD PTR [rbx+24], rdx
$LN7@ListAddEle:

; 166  : 
; 167  :     // Если вставляем элемент перед головой списка.
; 168  :     if (dataIndex == 0)

	test	rsi, rsi
	jne	SHORT $LN8@ListAddEle

; 169  :         list->Head = insertElemIndex;

	mov	QWORD PTR [rbx+16], rdx
$LN8@ListAddEle:

; 170  : 
; 171  :     // Копируем содержимое вставляемого элемента.
; 172  :     memcpy(&nodes[insertElemIndex].Data, value, sizeof(ListType)); 

	movups	xmm0, XMMWORD PTR [rbp]
	mov	rcx, rdx
	shl	rcx, 5
	add	rcx, r8

; 173  :     
; 174  :     // Поле Next пустых элементов является односвязным списком пустых мест.
; 175  :     list->Free = nodes[insertElemIndex].Next;

	mov	rax, QWORD PTR [rcx]
	movups	XMMWORD PTR [rcx+16], xmm0
	mov	QWORD PTR [rbx+8], rax

; 176  : 
; 177  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 178  :     // Изменяем поле Next в списке:
; 179  : 
; 180  :     // Поле Next вставляемого элемента.
; 181  :     nodes[insertElemIndex].Next = nodes[dataIndex].Next;

	mov	rax, QWORD PTR [rdi+r8]
	mov	QWORD PTR [rcx], rax

; 182  :     // Поле Next предшествующего элемента.
; 183  :     nodes[dataIndex].Next = insertElemIndex;

	mov	QWORD PTR [rdi+r8], rdx

; 184  : 
; 185  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 186  :     // Изменяем поле Prev:
; 187  : 
; 188  :     // Поле Prev вставляемого элемента.
; 189  :     nodes[insertElemIndex].Prev = dataIndex;
; 190  :     // Поле Prev следующего за вставляемым элементом.
; 191  :     nodes[nodes[insertElemIndex].Next].Prev = insertElemIndex;

	mov	rax, QWORD PTR [rcx]
	shl	rax, 5
	mov	QWORD PTR [rcx+8], rsi
	mov	QWORD PTR [rax+r8+8], rdx

; 192  : 
; 193  :     // Размер списка увеличился.
; 194  :     list->Size++;

	inc	QWORD PTR [rbx+32]
$LN15@ListAddEle:

; 195  : 
; 196  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 197  : 
; 198  :     return list->Status;

	mov	eax, DWORD PTR [rbx+52]
$LN14@ListAddEle:
	mov	rdi, QWORD PTR [rsp+96]

; 199  : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rsi
	ret	0
?ListAddElemAfter@@YAHPEAUList@@PEBT__m128i@@_K@Z ENDP	; ListAddElemAfter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListDestructor@@YAXPEAUList@@@Z
_TEXT	SEGMENT
list$ = 48
?ListDestructor@@YAXPEAUList@@@Z PROC			; ListDestructor, COMDAT

; 66   : {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 67   :     LOG_LIST_TRACE_CTOR;
; 68   : 
; 69   :     assert(list);
; 70   : 
; 71   :     LIST_ASSERT_STATUS;
; 72   : 
; 73   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 74   : 
; 75   :     free(list->Nodes);

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_free
	xorps	xmm0, xmm0

; 76   : 
; 77   :     memset(list, 0, sizeof(List));

	xor	eax, eax
	movups	XMMWORD PTR [rbx], xmm0
	movups	XMMWORD PTR [rbx+16], xmm0
	movups	XMMWORD PTR [rbx+32], xmm0
	mov	QWORD PTR [rbx+48], rax

; 78   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?ListDestructor@@YAXPEAUList@@@Z ENDP			; ListDestructor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListConstructor@@YAHPEAUList@@_K@Z
_TEXT	SEGMENT
list$ = 80
capacity$dead$ = 88
?ListConstructor@@YAHPEAUList@@_K@Z PROC		; ListConstructor, COMDAT

; 20   : {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 21   :     LOG_LIST_TRACE_CTOR;
; 22   : 
; 23   :     assert(list);
; 24   : 
; 25   :     LIST_ASSERT_STATUS;
; 26   : 
; 27   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 28   : 
; 29   :     list->Capacity = capacity;
; 30   :     list->Sorted   = true;
; 31   :     list->Status   = LIST_ERR_NO_ERRORS;

	xor	esi, esi
	mov	QWORD PTR [rcx+40], 20
	mov	rdi, rcx
	mov	BYTE PTR [rcx+48], 1
	mov	DWORD PTR [rcx+52], esi

; 32   : 
; 33   :     list->Head = 0;
; 34   :     list->Tail = 0;
; 35   :     list->Size = 0;
; 36   :     list->Free = 1;

	mov	ebx, 1
	mov	QWORD PTR [rcx+16], rsi
	mov	QWORD PTR [rcx+24], rsi

; 37   : 
; 38   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 39   : 
; 40   :     list->Nodes = (ListNode*)calloc(capacity + 1, sizeof(ListNode));

	lea	edx, QWORD PTR [rsi+32]
	mov	QWORD PTR [rcx+32], rsi
	mov	QWORD PTR [rcx+8], rbx
	lea	ecx, QWORD PTR [rsi+21]
	call	QWORD PTR __imp_calloc
	mov	QWORD PTR [rdi], rax
	mov	rcx, rax

; 41   : 
; 42   :     if (!list->Nodes)

	test	rax, rax
	jne	SHORT $LN5@ListConstr

; 43   :     {
; 44   :         LOG_LIST_ERR_MEMORY;

	lea	rax, OFFSET FLAT:??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	mov	DWORD PTR [rsp+48], 44			; 0000002cH
	mov	QWORD PTR [rsp+40], rax
	lea	r8d, QWORD PTR [rsi+2]
	lea	rax, OFFSET FLAT:??_C@_0EC@KEKCIHEG@int?5__cdecl?5ListConstructor?$CIstr@
	lea	rcx, OFFSET FLAT:??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
	mov	QWORD PTR [rsp+32], rax
	call	?LogLine@@YAXPEBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine

; 45   : 
; 46   :         list->Status |= LIST_ERR_MEMORY;

	mov	eax, DWORD PTR [rdi+52]
	or	eax, ebx
	mov	DWORD PTR [rdi+52], eax

; 57   : 
; 58   :     nodes[capacity].Next = 0;
; 59   : 
; 60   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 61   : 
; 62   :     return list->Status;
; 63   : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN5@ListConstr:

; 47   : 
; 48   :         return list->Status;
; 49   :     }
; 50   : 
; 51   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 52   : 
; 53   :     ListNode* nodes = list->Nodes;

	movdqa	xmm2, XMMWORD PTR __xmm@00000000000000010000000000000000
	lea	rdx, QWORD PTR [rax+96]
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000020000000000000001
	mov	r8d, 8
$LL4@ListConstr:

; 56   :         nodes[st].Next = st + 1;

	lea	rax, QWORD PTR [r8-4]
	movq	xmm0, rbx
	punpcklqdq xmm0, xmm0
	lea	rdx, QWORD PTR [rdx+256]
	paddq	xmm0, xmm3
	movq	xmm1, r8
	movq	QWORD PTR [rdx-320], xmm0
	add	rbx, 8
	psrldq	xmm0, 8
	movq	QWORD PTR [rdx-288], xmm0
	movq	xmm0, rax
	punpcklqdq xmm0, xmm0
	lea	rax, QWORD PTR [r8-2]
	paddq	xmm0, xmm2
	movq	QWORD PTR [rdx-256], xmm0
	psrldq	xmm0, 8
	movq	QWORD PTR [rdx-224], xmm0
	movq	xmm0, rax
	punpcklqdq xmm0, xmm0
	lea	rax, QWORD PTR [r8+1]
	paddq	xmm0, xmm2
	movq	QWORD PTR [rdx-192], xmm0
	psrldq	xmm0, 8
	movq	QWORD PTR [rdx-160], xmm0
	movq	xmm0, rax
	mov	QWORD PTR [rdx-128], r8
	add	r8, 8
	punpcklqdq xmm1, xmm0
	psrldq	xmm1, 8
	movq	QWORD PTR [rdx-96], xmm1
	cmp	r8, 24
	jb	$LL4@ListConstr

; 54   : 
; 55   :     for (size_t st = 1; st < capacity; st++)

	cmp	rbx, 20
	jae	SHORT $LN3@ListConstr
	lea	rax, QWORD PTR [rbx+1]
	shl	rbx, 5
	add	rbx, rcx
	npad	7
$LL9@ListConstr:

; 56   :         nodes[st].Next = st + 1;

	mov	QWORD PTR [rbx], rax
	lea	rbx, QWORD PTR [rbx+32]
	inc	rax
	cmp	rax, 21
	jb	SHORT $LL9@ListConstr
$LN3@ListConstr:

; 57   : 
; 58   :     nodes[capacity].Next = 0;
; 59   : 
; 60   :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 61   : 
; 62   :     return list->Status;
; 63   : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	QWORD PTR [rcx+640], rsi
	mov	eax, DWORD PTR [rdi+52]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?ListConstructor@@YAHPEAUList@@_K@Z ENDP		; ListConstructor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Language C\HashTable\HashTable\List\List.cpp
; File D:\Language C\HashTable\HashTable\List\List_Config.h
; File D:\Language C\HashTable\HashTable\List\List.cpp
; File D:\Language C\HashTable\HashTable\List\List_Config.h
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListFind@@YA_KPEBUList@@PEBT__m128i@@@Z
_TEXT	SEGMENT
$T1 = 0
$T2 = 0
list$ = 32
element$ = 40
?ListFind@@YA_KPEBUList@@PEBT__m128i@@@Z PROC		; ListFind, COMDAT

; 530  : {

$LN17:
	push	rbx
	sub	rsp, 16

; 531  :     LOG_LIST_TRACE_FUNC_0;
; 532  : 
; 533  :     assert(list);
; 534  :     assert(element);
; 535  : 
; 536  :     LIST_ASSERT_STATUS;
; 537  : 
; 538  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 539  :     
; 540  :     size_t          current   = list->Head;
; 541  :     const size_t    listSize  = list->Size;

	mov	r9, QWORD PTR [rcx+32]

; 542  :     const ListNode* nodes     = list->Nodes;
; 543  :     const ListType  elemValue = *element;
; 544  : 
; 545  :     // Линейный поиск элементов.
; 546  :     for (size_t st = 0; st < listSize; st++)

	xor	eax, eax
	mov	r8, QWORD PTR [rcx+16]
	mov	rbx, QWORD PTR [rcx]
	movdqu	xmm0, XMMWORD PTR [rdx]
	test	r9, r9
	je	SHORT $LN15@ListFind

; 548  :         if (ListComparator(elemValue, nodes[current].Data))

	movdqa	XMMWORD PTR $T2[rsp], xmm0
	mov	r10, QWORD PTR $T2[rsp+8]
	mov	r11, QWORD PTR $T2[rsp]
	npad	6
$LL4@ListFind:
	mov	rdx, r8
	shl	rdx, 5
	movdqu	xmm0, XMMWORD PTR [rdx+rbx+16]
; File D:\Language C\HashTable\HashTable\List\List_Config.h

; 41   : 	return memcmp(&val1, &val2, sizeof(ListType)) == 0;

	movq	rcx, xmm0
; File D:\Language C\HashTable\HashTable\List\List.cpp

; 548  :         if (ListComparator(elemValue, nodes[current].Data))

	movdqa	XMMWORD PTR $T1[rsp], xmm0
; File D:\Language C\HashTable\HashTable\List\List_Config.h

; 41   : 	return memcmp(&val1, &val2, sizeof(ListType)) == 0;

	cmp	r11, rcx
	jne	SHORT $LN14@ListFind
	cmp	r10, QWORD PTR $T1[rsp+8]
	je	SHORT $LN10@ListFind
$LN14@ListFind:
; File D:\Language C\HashTable\HashTable\List\List.cpp

; 551  :         current = nodes[current].Next;

	mov	r8, QWORD PTR [rdx+rbx]
	inc	rax
	cmp	rax, r9
	jb	SHORT $LL4@ListFind
$LN15@ListFind:

; 552  :     }
; 553  : 
; 554  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 555  : 
; 556  :     return 0;

	xor	eax, eax

; 557  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN10@ListFind:

; 549  :             return current;

	mov	rax, r8

; 557  : }

	add	rsp, 16
	pop	rbx
	ret	0
?ListFind@@YA_KPEBUList@@PEBT__m128i@@@Z ENDP		; ListFind
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Language C\HashTable\HashTable\List\List_Config.h
;	COMDAT ?ListComparator@@YA_NT__m128i@@0@Z
_TEXT	SEGMENT
val1$ = 8
val2$ = 16
?ListComparator@@YA_NT__m128i@@0@Z PROC			; ListComparator, COMDAT

; 41   : 	return memcmp(&val1, &val2, sizeof(ListType)) == 0;

	mov	rax, QWORD PTR [rcx]
	sub	rax, QWORD PTR [rdx]
	jne	SHORT $LN3@ListCompar
	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rdx+8]
$LN3@ListCompar:
	test	rax, rax
	sete	al

; 42   : }

	ret	0
?ListComparator@@YA_NT__m128i@@0@Z ENDP			; ListComparator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Language C\HashTable\HashTable\List\List.cpp
;	COMDAT ?ListResize@@YAHPEAUList@@@Z
_TEXT	SEGMENT
list$ = 80
?ListResize@@YAHPEAUList@@@Z PROC			; ListResize, COMDAT

; 563  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 564  :     LOG_LIST_TRACE_FUNC_1;
; 565  : 
; 566  :     assert(list);
; 567  : 
; 568  :     LIST_ASSERT_STATUS;
; 569  :     
; 570  :     // Перед вызовом функции нужно проверять, что список полон.
; 571  :     assert(CHECK_LIST_FULL(list));
; 572  : 
; 573  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 574  :     
; 575  :     size_t oldCapacity = list->Capacity;

	mov	rsi, QWORD PTR [rcx+40]
	mov	rdi, rcx

; 576  :     size_t newCapacity = (size_t)((double)oldCapacity * ListResizeCoef);

	xorps	xmm0, xmm0
	test	rsi, rsi
	js	SHORT $LN21@ListResize
	cvtsi2sd xmm0, rsi
	jmp	SHORT $LN22@ListResize
$LN21@ListResize:
	mov	rax, rsi
	mov	rcx, rsi
	shr	rcx, 1
	and	eax, 1
	or	rcx, rax
	cvtsi2sd xmm0, rcx
	addsd	xmm0, xmm0
$LN22@ListResize:
	movsd	xmm1, QWORD PTR __real@43e0000000000000
	addsd	xmm0, xmm0
	xor	eax, eax
	comisd	xmm0, xmm1
	jb	SHORT $LN20@ListResize
	subsd	xmm0, xmm1
	comisd	xmm0, xmm1
	jae	SHORT $LN20@ListResize
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	rax, rcx
$LN20@ListResize:
	cvttsd2si rbx, xmm0
	add	rbx, rax

; 577  : 
; 578  :     if (newCapacity <= oldCapacity)

	cmp	rbx, rsi
	ja	SHORT $LN5@ListResize

; 579  :     {
; 580  :         LOG_LIST_ERR_MEMORY;

	lea	rax, OFFSET FLAT:??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	mov	DWORD PTR [rsp+48], 580			; 00000244H
	mov	QWORD PTR [rsp+40], rax
	lea	rcx, OFFSET FLAT:??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
	lea	rax, OFFSET FLAT:??_C@_0CG@HCIHDPOL@int?5__cdecl?5ListResize?$CIstruct?5L@
	mov	r8d, 2
	mov	QWORD PTR [rsp+32], rax
	call	?LogLine@@YAXPEBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine

; 581  : 
; 582  :         list->Status |= LIST_ERR_MEMORY;

	mov	eax, DWORD PTR [rdi+52]
	or	eax, 1
	mov	DWORD PTR [rdi+52], eax

; 621  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN5@ListResize:

; 583  : 
; 584  :         return list->Status;
; 585  :     }
; 586  : 
; 587  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 588  : 
; 589  :     ListNode* nodes = (ListNode*)realloc(list->Nodes, (newCapacity + 1) * sizeof(ListNode));

	lea	rcx, QWORD PTR [rbx+1]
	mov	QWORD PTR [rsp+80], rbp
	mov	eax, 32					; 00000020H
	mul	rcx
	mov	rcx, -1
	cmovo	rax, rcx
	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rax
	call	QWORD PTR __imp_realloc
	mov	rbp, rax

; 590  : 
; 591  :     if (!nodes)

	test	rax, rax
	jne	SHORT $LN6@ListResize

; 592  :     {
; 593  :         LOG_LIST_ERR_MEMORY;

	lea	rax, OFFSET FLAT:??_C@_0DA@OJAHIMDJ@D?3?2Language?5C?2HashTable?2HashTab@
	mov	DWORD PTR [rsp+48], 593			; 00000251H
	mov	QWORD PTR [rsp+40], rax
	lea	r8d, QWORD PTR [rbp+2]
	lea	rax, OFFSET FLAT:??_C@_0CG@HCIHDPOL@int?5__cdecl?5ListResize?$CIstruct?5L@
	lea	rcx, OFFSET FLAT:??_C@_0BI@EFGDJNAP@?N?x?h?a?j?$OA?5?b?$PL?d?e?k?e?m?h?$PP?5?o?$OA?l?$PP?r?h@
	mov	QWORD PTR [rsp+32], rax
	call	?LogLine@@YAXPEBDW4LogLevel@@W4LogSignature@@_N00H@Z ; LogLine

; 594  : 
; 595  :         list->Status |= LIST_ERR_MEMORY;

	mov	eax, DWORD PTR [rdi+52]
	or	eax, 1
	mov	DWORD PTR [rdi+52], eax

; 596  : 
; 597  :         return list->Status;

	jmp	$LN23@ListResize
$LN6@ListResize:

; 604  :     
; 605  :     // Очищаем новую память.
; 606  :     memset(nodes + (oldCapacity + 1), 0, (newCapacity - oldCapacity) * sizeof(ListNode));

	mov	r8, rbx
	mov	QWORD PTR [rdi], rbp
	sub	r8, rsi
	lea	rcx, QWORD PTR [rsi+1]
	shl	rcx, 5
	xor	edx, edx
	shl	r8, 5
	add	rcx, rbp
	call	memset

; 607  : 
; 608  :     // Добавляем выделенную память в список свободных элементов.
; 609  :     for (size_t st = oldCapacity + 1; st <= newCapacity; st++)

	inc	rsi
	mov	rax, rbx
	sub	rax, rsi
	mov	rcx, rsi
	inc	rax
	cmp	rsi, rbx
	ja	$LN11@ListResize
	cmp	rax, 8
	jb	$LN19@ListResize

; 598  :     }
; 599  : 
; 600  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 601  :     
; 602  :     // Выделение памяти произошло успешно, сохраняем указатель на новый блок памяти.
; 603  :     list->Nodes = nodes;

	movdqa	xmm2, XMMWORD PTR __xmm@00000000000000010000000000000000
	lea	rdx, QWORD PTR [rsi+2]
	movdqa	xmm3, XMMWORD PTR __xmm@00000000000000020000000000000001
	lea	r8, QWORD PTR [rsi+7]
	and	eax, 7
	shl	rdx, 5
	mov	r9, rbx
	sub	r9, rax
	add	rdx, rbp
	npad	9
$LL4@ListResize:

; 610  :         nodes[st].Next = st + 1;

	lea	rax, QWORD PTR [r8-4]
	movq	xmm0, rcx
	punpcklqdq xmm0, xmm0
	lea	rdx, QWORD PTR [rdx+256]
	paddq	xmm0, xmm3
	movq	xmm1, r8
	movq	QWORD PTR [rdx-320], xmm0
	add	rcx, 8
	psrldq	xmm0, 8
	movq	QWORD PTR [rdx-288], xmm0
	movq	xmm0, rax
	punpcklqdq xmm0, xmm0
	lea	rax, QWORD PTR [r8-2]
	paddq	xmm0, xmm2
	movq	QWORD PTR [rdx-256], xmm0
	psrldq	xmm0, 8
	movq	QWORD PTR [rdx-224], xmm0
	movq	xmm0, rax
	punpcklqdq xmm0, xmm0
	lea	rax, QWORD PTR [r8+1]
	paddq	xmm0, xmm2
	movq	QWORD PTR [rdx-192], xmm0
	psrldq	xmm0, 8
	movq	QWORD PTR [rdx-160], xmm0
	movq	xmm0, rax
	mov	QWORD PTR [rdx-128], r8
	add	r8, 8
	punpcklqdq xmm1, xmm0
	psrldq	xmm1, 8
	movq	QWORD PTR [rdx-96], xmm1
	cmp	rcx, r9
	jbe	$LL4@ListResize
$LN11@ListResize:

; 607  : 
; 608  :     // Добавляем выделенную память в список свободных элементов.
; 609  :     for (size_t st = oldCapacity + 1; st <= newCapacity; st++)

	cmp	rcx, rbx
	ja	SHORT $LN3@ListResize
$LN19@ListResize:
	mov	rax, rcx
	shl	rax, 5
	add	rax, rbp
	npad	11
$LL10@ListResize:

; 610  :         nodes[st].Next = st + 1;

	inc	rcx
	mov	QWORD PTR [rax], rcx
	lea	rax, QWORD PTR [rax+32]
	cmp	rcx, rbx
	jbe	SHORT $LL10@ListResize
$LN3@ListResize:

; 611  : 
; 612  :     // Ново выделенная память добавляется перед старой свободной памятью, от этого собьётся сортировка.
; 613  :     nodes[newCapacity].Next = 0;

	mov	rax, rbx

; 614  :     list->Free = oldCapacity + 1;

	mov	QWORD PTR [rdi+8], rsi
	shl	rax, 5

; 615  : 
; 616  :     list->Capacity = newCapacity;

	mov	QWORD PTR [rdi+40], rbx
	mov	QWORD PTR [rax+rbp], 0

; 617  : 
; 618  :     //***\\---//***\\-----//***\\---//***\\-----//*****\\-----//***\\---//***\\-----//***\\---//***\\
; 619  :     
; 620  :     return list->Status;

	mov	eax, DWORD PTR [rdi+52]
$LN23@ListResize:

; 621  : }

	mov	rbp, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?ListResize@@YAHPEAUList@@@Z ENDP			; ListResize
_TEXT	ENDS
END
